{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83c\udf10 Engineering KB: Master MOC","text":"<p>Stato: #active \"L'organizzazione della conoscenza \u00e8 l'inizio della saggezza ingegneristica.\"</p> <p>Benvenuto nel punto di ingresso centrale del tuo secondo cervello tecnico. Questa mappa collega tutte le macro-aree della tua conoscenza.</p>","tags":["hub","directory"]},{"location":"#aree-principali","title":"\ud83c\udfd7\ufe0f Aree Principali","text":"","tags":["hub","directory"]},{"location":"#1-10_theory_moc","title":"1. [[10_Theory_MOC]]","text":"<p>Fondamenta scientifiche e teoriche.</p> <ul> <li>Algoritmi, Strutture Dati, Sistemi Operativi e Reti.</li> </ul>","tags":["hub","directory"]},{"location":"#2-20_languages_moc","title":"2. [[20_Languages_MOC]]","text":"<p>Linguaggi di programmazione e sintassi core.</p> <ul> <li>[[Python_MOC]], [[Java_MOC]]</li> </ul>","tags":["hub","directory"]},{"location":"#3-30_frameworks_tools_moc","title":"3. [[30_Frameworks_Tools_MOC]]","text":"<p>Ecosistemi di sviluppo e strumenti specifici.</p> <ul> <li>[[Android_MOC]], [[Spring_MOC]].</li> </ul>","tags":["hub","directory"]},{"location":"#4-40_design_patterns_moc","title":"4. [[40_Design_Patterns_MOC]]","text":"<p>Architettura del software e qualit\u00e0 del codice.</p> <ul> <li>[[SOLID_Principles]].</li> </ul>","tags":["hub","directory"]},{"location":"#operativita-quotidiana","title":"\ud83d\udcdd Operativit\u00e0 Quotidiana","text":"<ul> <li>[[00_Inbox]]: Note rapide e bozze da elaborare.</li> <li>[[50_Project_Journal]]: Log delle decisioni tecniche e post-mortem dei progetti.</li> </ul>","tags":["hub","directory"]},{"location":"#sistema-meta","title":"\ud83d\udee0\ufe0f Sistema (Meta)","text":"<ul> <li>[[99_Meta_MOC]]: Gestione di template e configurazioni della KB.</li> </ul>","tags":["hub","directory"]},{"location":"00_Inbox/","title":"README","text":"<p>Stato: #seed</p>"},{"location":"00_Inbox/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"10_Theory/Algorithms/Complexity_Basics/","title":"Complexity Basics","text":"<p>Stato: #seed</p>"},{"location":"10_Theory/Algorithms/Complexity_Basics/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"10_Theory/Data_Structures/Trees_and_Graphs/","title":"Trees and Graphs","text":"<p>Stato: #seed</p>"},{"location":"10_Theory/Data_Structures/Trees_and_Graphs/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"20_Languages/Java/Java_MOC/","title":"\ud83d\uddfa\ufe0f Java (MOC)","text":"<p>Stato: #seed | Collegamenti: [[index]]</p>"},{"location":"20_Languages/Java/Java_MOC/#indice-argomenti","title":"\ud83d\udccc Indice Argomenti","text":""},{"location":"20_Languages/Python/Python_MOC/","title":"Python MOC","text":"<p>Stato: #seed</p>"},{"location":"20_Languages/Python/Python_MOC/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"30_Frameworks_Tools/Android/Android/","title":"COMPUTAZIONE PERVASIVA","text":"<p>Con lo sviluppo delle nuove tecnologie che ha portato alla nascita dei dispositivi di compilazione portabili \u00e8 nata una nuova forma di computazione, quella pervasiva.</p> <p>Essendo i dispositivo mobili e non pi\u00f9 fissi si \u00e8 dovuto cercare un nuovo modo di far comunicare i vari dispositivi per via delle connessioni precarie e in continuo cambiamento. Si cerca di progettare anche un software che sia in grado di utilizzare meno risorse possibili e che abbiano una potenza di calcolo minore per evitare di esaurire le risorse del dispositivo punto di tutto questo si occupa l'anno mobile computing. Questi dispositivi pervasivi sono sistemi distribuiti e quindi questi problemi dei sistemi distribuiti e mobile fanno parte del pervasive computing a cui si aggiungono altri problemi come la scalabilit\u00e0 invisibilit\u00e0 la comunicazione remota ecc.</p> <p>Non tutti gli obiettivi del pervasive computer sono stati realizzati infatti creare uno smartplace, uno spazio in cui ci sono dispositivi di calcoli in modo da calcolare il mondo fisico e cyber fisico \u00e8 ancora difficile da realizzare, ma non perch\u00e9 non possediamo le tecnologie adeguate ma perch\u00e9 dobbiamo migliorare i collegamenti.</p> <p>\u00c8 necessario rendere questi dispositivi invisibili, l'uomo non si deve accorgere che ci sono in modo che il mondo fisico e il cyber fisico si fondono in un solo spazio. Un altro problema \u00e8 dovuto al numero sempre crescendo i dispositivi che si connettono tra loro quindi si cerca di realizzare la scalabilit\u00e0 localizzata cio\u00e8 di mantenere le stesse qualit\u00e0 di servizi ma man mano che aumentano i nuovi dispositivi.</p> <p>S\u00ec cerca di mascherare le condizioni di non uniformit\u00e0 dovute diversi dispositivi presenti che possono impedire di collaborare fra loro cercando di creare un sistema per nascondere alle domande e questi problemi.</p> <p>La computazione pervasiva ha modificato anche il modo in cui ci interfacciamo col software perch\u00e9 prima era necessario l'intervento umano per far svolgere qualcosa la macchina mentre oggi il computer \u00e8 in grado di comunicare con tende anche in maniera asincrona.</p> <p>Questo \u00e8 stato reso possibile grazie al fatto che prendono informazioni nel mondo reale tramite i sensori sono in grado di elaborarli e notificare all'uomo qualcosa.</p> <p>Oggi sia una architettura ed Edge cloudcentrica in cui tutti i dispositivi sono connessi tra loro tramite il cloud in cui le risorse informatiche sono regate attraverso la rete internet ospitate e gestite da server remoti.</p> <p>Si provvede di avere un architettura ed internet centrica con cui internet il centro delle connessioni fra i dispositivi e i server. In questo modo l'elaborazione avviene in modo distribuita ai margini della rete contrariamente a come accade in quelle precedenti in cui le elaborazione avviene in economia i server.</p> <p>Nell'architettura di calcolo distribuita ci sono tre segmenti che rappresentano muri diversi di elaborare e archiviare dati a seconda delle distanze dal punto di generazione</p> <p>\ud83d\udccd Edge Computing Alla base di tutto troviamo l\u2019Edge, ovvero il bordo della rete. I dati vengono elaborati il pi\u00f9 vicino possibile alla fonte che li genera, spesso direttamente all\u2019interno del dispositivo stesso. I dati vengono elaborati in tempo reale, senza dover prima inviare i dati a un server esterno.</p> <p>Questo approccio \u00e8 ideale per situazioni in cui la velocit\u00e0 \u00e8 fondamentale, come nelle auto a guida autonoma o nei dispositivi medici. Riduce la latenza, cio\u00e8 il tempo che passa tra l\u2019input e la risposta, e limita il traffico di rete.</p> <p>\ud83c\udf2b\ufe0f Fog Computing Salendo di un livello, troviamo il Fog Computing, un modello pensato per distribuire l\u2019elaborazione pi\u00f9 vicino alla rete, ma non necessariamente sul dispositivo.</p> <p>Nel fog computing, i dati vengono inviati a nodi local, un router o un server che li elaborano e, solo se necessario, li inoltrano al cloud. Questo modello \u00e8 utile quando bisogna elaborare rapidamente grandi quantit\u00e0 di dati provenienti da pi\u00f9 dispositivi, ma non si ha la necessit\u00e0 di farlo in tempo reale estremo.</p> <p>\u2601\ufe0f Cloud Computing Infine, abbiamo il Cloud, che rappresenta l\u2019approccio centralizzato. I dati vengono inviati a server remoti, spesso situati in data center geograficamente lontani. Qui possono essere elaborati con grande potenza computazionale, salvati per lungo tempo o usati per addestrare algoritmi complessi di intelligenza artificiale.</p> <p>Il cloud \u00e8 perfetto per elaborazioni intensive. Tuttavia, presenta limiti in termini di latenza e dipendenza dalla connessione internet.</p> <p>Edge, Fog e Cloud non si escludono a vicenda: collaborano. In un sistema moderno ed efficiente, i dati vengono prima processati localmente (edge), poi aggregati e raffinati in una rete vicina (fog), e infine archiviati o ulteriormente analizzati nel cloud.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#hci","title":"HCI","text":"<p>La Human computer interaction HCI Eh lo studio dell\u2019interazione uomo computer per la progettazione di sistemi informatici che siano usabili e affidabili. Il loro scopo \u00e8 quello di semplificare l\u2019attivit\u00e0 umane e non di ostacolarle. Se hai il computer che le persone offrono diversi modi di interagire fra loro e l\u2019interazione pu\u00f2 essere</p> <ul> <li>diretta cio\u00e8 tramite l\u2019uso del dispositivo e di risposte da parte del calcolatore ;</li> <li>indiretta tramite sensori se analizzano il mondo esterno e danno dei feedback per svolgere azioni</li> </ul> <p>La HCI \u00e8 una materia multidisciplinare che coinvolge</p> <p></p> <p>Il principio base della disciplina \u00e8</p> <p>usabilit\u00e0 cio\u00e8 la facilit\u00e0 con il quale l'utente pu\u00f2 interagire con la macchina per raggiungere obiettivi con efficacia, efficienza e soddisfazione per un certo contesto</p> <p>\u2260</p> <p>accessibilit\u00e0 che indica se un sistema informatico pu\u00f2 essere usato da tutti compreso chi ha disabilit\u00e0</p> <p>Interazione umana</p> <p>L'uomo \u00e8 colui che usa i calcolatori e devono essere progettati per assisterlo. Qui entrano in gioco le scienze cognitive che devono capire le capacit\u00e0 e le limitazioni per progettare in modo corretto un sistema informatico</p> <p>Interazione processo con il quale l'utente fornisce la macchina in un input e la macchina lo processa restituendo un output o viceversa</p> <p>Per la macchina si sono molte forme di IO, ma per l'essere umano sono principalmente i cinque sensi e pi\u00f9 in particolare la vista l'udito e il tatto. Interagiamo con la macchina principalmente con il tatto, le dita fungono da cursore. Solo recentemente siamo in grado di interagire anche con la voce per fornire un input.</p> <p> Vista La vista \u00e8 il principale mezzo con il quale otteniamo informazioni. La percezione visiva si pu\u00f2 dividere in due fasi</p> <ol> <li>ricezione fisica dello stimolo</li> <li>elaborazione e un'interpretazione dello stimolo</li> </ol> <p>Dobbiamo capire come funziona l'occhio e come la mente interpreta gli stimoli per progettare sistemi informatici. La prima cosa da capire \u00e8 cosa l'utente vede punto la vista umana tende ad avere una visione centrale dove l\u2019utente di attento e nota le cose; \u00e8 una visione centrale che trascura le cose che sono fuori da quella centrale.</p> <p>Capire questo ci permette di realizzare un design utile all\u2019utente</p> <p>\ud83e\udc6a le info importanti devono essere al centro del campo</p> <p>\ud83e\udc6a le info meno importanti devono essere pi\u00f9 all'esterno</p> <p>Importante \u00e8 capire anche come percepiamo i colori, dimensioni, e profondit\u00e0 per una buona progettazione delle interfaccia visive. Bisogna definire il contesto in cui gli oggetti si trovano perch\u00e9 diamo sulla base di esso o un'interpretazione diversa dovuta al fatto che possiamo gi\u00e0 conoscere il contesto e le info relative da conoscenze passate. Definiamo correttamente il contesto permette all'utente di capire subito di cosa si tratta ed evita le illusioni ottiche che lo portano in disabilit\u00e0 quindi bisogna definire correttamente le dimensioni degli oggetti dove posizionarli e cos\u00ec via per poter sviluppare una buona interfaccia utente.</p> <p>Udito Un altro canale di output per l'uomo pu\u00f2 essere il canale uditivo grazie al quale siamo in grado di riconoscere i suoni in quanto il nostro sistema filtro i suoni che ascoltiamo per concentrarci sulle informazioni importanti il suono \u00e8 spesso usato nelle interfacce grafiche ad esempio per dare informazioni sullo stato di qualcosa, focalizzare l'attenzione ecc.. quindi per notificare/rafforzare l'idea dell'utente.</p> <p>Tatto Il tatto ci d\u00e0 informazioni sull'ambiente circostante e specialmente nei sistemi informatici \u00e8 la fonte di input ma anche di output. In questo modo siamo in grado di interagire con gli aggettivi fuori dagli smartphone in modo da svolgere determinati compiti. Anche i movimenti importanti perch\u00e9 comporta un elaborazione di informazioni in seguito a uno stimolo ricevuto toccando qualcosa. Ogni movimento richiede tempo che dipende dalle persone dall'et\u00e0 eccetera eccetera. In movimento si valuta con accuratezza cio\u00e8 la precisione del movimento che dipende anche dalla velocit\u00e0 con il quale si reagisce. Quanto si progetta un\u2019interfaccia e bisogna considerare queste caratteristiche del movimento per progettare i bottoni che siano facilmente raggiungibili e premibili. (Pubblicit\u00e0 ingannevole)</p> <p>Il tempo impiegato per colpire un bersaglio \u00e8 una funzione della dimensione del bersaglio della distanza da percorrere</p> <p>Legge di Fitts</p> <p>Dispositivi Il progettista dell'interfaccia deve essere a conoscenza delle propriet\u00e0 del dispositivo e di tutti i fattori che influenzano il comportamento dell'interfaccia perch\u00e9 influenzano la natura dell\u2019interazione.</p> <p>Donald Norman da una definizione di interazione HC stabilimento che si tratta di un ciclo che si compone di due fasi</p> <ol> <li>Esecuzione</li> <li>Valutazione    |    V</li> </ol> <p>L'utente stabilisce l'obiettivo, formula l'intenzione c'\u00e8 l'obiettivo che deve realizzare, esegue le azioni sul dispositivo e percepisce lo stato del sistema e lo interpreta per capire il posto suggestivo per raggiungere l'obiettivo</p> <p>\u00c8 importante che l'utente capisca cosa fare per completare le loro azioni e le interfacce non devono essere di un tralcio anzi devono semplificare il raggiungimento dell'obiettivo.</p> <p>DESIGN SBAGLIATO \ud83e\udc6alapsus cio\u00e8 quando comprendiamo il sistema ma si fanno</p> <p>| errori di distrazione V</p> <p>errori quando si sbaglia perch\u00e9 non si \u00e8 capito il sistema e quindi cosa deve fare per raggiungere l\u2019obiettivo</p> <p>Ergonomia L\u2019ergonomia \u00e8 lo studio delle caratteristiche fisiche dell\u2019interazione quindi come progettare i controlli layout dei dispositivi ecc.</p> <p>L'obiettivo \u00e8 di migliorare come l\u2019utente usi dispositivi per dare migliori prestazioni sull'uso di questi punto questo si riflette anche sul design, su come posizionare gli elementi sulla base dell'utilit\u00e0 del contesto ecc.</p> <p>Quando progettiamo l'interfaccia dobbiamo tenere conto anche di come gli utenti usano i dispositivi infatti secondo studi la maggior parte delle persone usano il dispositivo con una mano sola e usano il pollice per toccare lo schermo, oppure con la seconda mano lo fissiamo oppure usano entrambe le mani quindi in base a come viene utilizzato progettiamo il design mettendo gli elementi importanti nelle parti dello schermo pi\u00f9 facilmente raggiungibili in base alle modalit\u00e0 di uso mentre gli elementi meno utili o di uso frequente nelle parti pi\u00f9 esterne un design corretto porta ad avere una pessima esperienza d'uso per l'utente finale</p>"},{"location":"30_Frameworks_Tools/Android/Android/#architectural-ui-and-data-management-patterns","title":"ARCHITECTURAL UI AND DATA MANAGEMENT PATTERNS","text":"<p>Prima ancora di scrivere codice, \u00e8 importante definire l\u2019architettura del sistema. Progettare l\u2019architettura in anticipo permette di avere una visionechiara di come sar\u00e0 strutturata l\u2019applicazione, come interagiranno i diversi componenti tra loro e quali saranno le dipendenze principali.</p> <p>Questo ha un impatto diretto sulla qualit\u00e0 del progetto nel lungo periodo. Se in futuro sar\u00e0 necessario apportare modifiche, aggiungere funzionalit\u00e0, sostituire una tecnologia, risolvere bug o adattarsi a nuove esigenze\u2026 avere un\u2019architettura solida e ben pensata render\u00e0 tutto pi\u00f9 semplice, veloce e sicuro.</p> <p>\u00c8 necessario strutturare il sistema in modo che sia indipendente dai framework, librerie e linguaggi che usiamo perch\u00e9 cambiano nel tempo: nuove versioni, nuove API, a volte addirittura vengono abbandonati o sostituiti da soluzioni migliori. Se il nostro sistema dipende troppo da queste tecnologie, ogni cambiamento porta ad errori o riscritture pesanti del codice.</p> <p>a modularit\u00e0 \u00e8 uno dei concetti pi\u00f9 importanti. Significa suddividere un sistema in parti indipendenti e riutilizzabili, chiamate moduli o componenti, ognuno dei quali ha una responsabilit\u00e0 chiara e ben definita.</p> <p>Conviene pensare alla modularit\u00e0 cio\u00e8 dividere il codice in moduli in modo che sia pi\u00f9 semplice da capire, da testare, da manutenere e da evolvere. Ogni modulo pu\u00f2 essere sviluppato (e perfino sostituito) senza dover riscrivere tutto il resto. Dobbiamo fare attenzione alle dipendenze circolari che si verificano quando due (o pi\u00f9) moduli dipendono l\u2019uno dall\u2019altro direttamente o indirettamente. Questo crea una situazione di interdipendenza, dove nessuno dei moduli pu\u00f2 essere isolato, testato o riutilizzato in modo indipendente.</p> <p>Il principio che si trova alla base di ogni pattern architetturale \u00e8 la separazione dei problemi in livelli in modo da avere le dipendenze verso un\u2019unica direzione ed evitare le dipendenze circolari. I vari livelli non devono avere riferimenti ai livelli pi\u00f9 esterni di loro, questo violerebbe la modularit\u00e0 e renderebbe quindi i livelli dipendenti fra loro.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#clean-archicture","title":"CLEAN ARCHICTURE","text":"<p>La Clean Architecture mira a creare sistemi intercambiabili con una forte separazione delle preoccupazioni e un accoppiamento debole tra i livelli.</p> <p>L'idea fondamentale di Clean Architecture, concepita da Robert Martin (Uncle Bob), \u00e8 rendere intercambiabile ogni elemento all'interno di un certo confine architetturale, senza richiedere modifiche nei livelli sottostanti.</p> <p>Le dipendenze del codice sorgente possono puntare solo verso l'interno. Questo significa che i livelli interni non devono dipendere da livelli. Questa direzione delle dipendenze \u00e8 fondamentale per ottenere un basso accoppiamento e facilitare il test e la manutenzione.</p> <p>La Clean Architecture divide un'applicazione in diversi livelli con responsabilit\u00e0 distinte:</p> <ol> <li>Domain/Application Core: Contiene le entit\u00e0 e la logica di business dell'applicazione. Questo livello \u00e8 indipendente da qualsiasi framework o dettaglio di implementazione esterna.</li> <li>Use Cases: Il software in questo livello contiene regole aziendali specifiche dell'applicazione ed incapsula e implementa tutti i casi d'uso del sistema. Questi casi d'uso orchestrano il flusso di dati da e verso le entit\u00e0 e indirizzano tali entit\u00e0 per raggiungere gli obiettivi del caso d'uso. I cambiamenti in questo livello non devono influenzare le entit\u00e0 e questo livello non \u00e8 influenzato da modifiche alle componenti esterne come il database, l'interfaccia utente o qualsiasi framework utilizzato. Questo strato \u00e8 isolato da tali problematiche. Tuttavia, modifiche alle funzioni di dominio dell'applicazione influenzeranno i casi d'uso e quindi il software in questo livello.</li> <li>Infrastructure/Frameworks: Contiene i dettagli di implementazione dei sistemi esterni, come database, framework UI, librerie esterne e API. Le implementazioni delle interfacce definite nel livello Application risiedono qui.</li> <li>Interface Adapters: Questo livello funge da ponte tra i livelli Application e Infrastructure. Contiene adapter, presentatori e controller che convertono i dati da un formato all'altro per soddisfare le esigenze dei diversi livelli.</li> <li>API/UI: Il livello pi\u00f9 esterno che presenta l'applicazione all'utente (tramite un'API web o un'interfaccia utente grafica).</li> </ol> <p></p> <p>Per attraversare i confini (cerchi concentrici) si usano i controller e i Presenter che comunicano con i casi d'uso nel livello successivo.</p> <ol> <li>l'esecuzione inizia nel controller</li> <li>si sposta attraverso il caso d'uso</li> <li>finisce per essere eseguito nel presenter.</li> </ol> <p>Per implementare questa logica si utilizza il principio di inversione delle dipendenze che consente ad A di chiamare metodi su un'astrazione implementata da B, rendendo possibile per A chiamare B in fase di esecuzione, ma per B di dipendere da un'interfaccia controllata da A in fase di compilazione (invertendo cos\u00ec la tipica dipendenza in fase di compilazione). In fase di esecuzione, il flusso di esecuzione del programma rimane invariato, ma l'introduzione di interfacce significa che diverse implementazioni di queste interfacce possono essere facilmente collegate. La stessa tecnica viene utilizzata per attraversare tutti i confini nelle architetture.</p> <p>Sfruttiamo il polimorfismo dinamico per creare dipendenze del codice sorgente che si oppongono al flusso di controllo in modo che possiamo rispettare la regola delle dipendenze indipendentemente dalla direzione in cui sta andando il flusso di controllo.</p> <p></p> <p>Il Repository Pattern \u00e8 spesso integrato in Clean Architecture come un meccanismo per astrarre l'accesso ai dati. L'interfaccia del repository \u00e8 definita nel livello Application, mentre l'implementazione concreta che interagisce con il database si trova nel livello Infrastructure. Questo rispetta la regola della dipendenza, poich\u00e9 il livello Application dipende solo dall'interfaccia del repository, non dalla specifica implementazione del database.</p> <p>La separazione dei livelli e la regola della dipendenza rendono le applicazioni Clean Architecture pi\u00f9 facili da testare. I casi d'uso e la logica di business nel livello Application possono essere testati unitariamente senza dipendere da database o UI. Le interfacce nel livello Application facilitano il mocking delle dipendenze esterne durante i test. L'accoppiamento debole tra i livelli rende le applicazioni Clean Architecture pi\u00f9 scalabili e manutenibili. Le modifiche a un livello hanno meno probabilit\u00e0 di influenzare altri livelli, facilitando l'aggiornamento e l'aggiunta di nuove funzionalit\u00e0.</p> <p>I ViewModel spesso interagiscono con un Repository per l'accesso ai dati. Questa struttura (UI - ViewModel - Repository - Data Source) in Android pu\u00f2 essere vista come un'implementazione pratica di alcuni principi di Clean Architecture, in particolare la separazione delle preoccupazioni e l'astrazione dell'accesso ai dati.</p> <p>Una potenziale violazione della regola della dipendenza in Clean Architecture quando si implementa il Repository pattern utilizzando direttamente un ORM (come Entity Framework Core) nel livello Infrastructure. Questo introduce una dipendenza del livello Interface Adapters (dove si troverebbe l'implementazione del repository) verso un framework esterno e verso l'I/O diretto, violando la dipendenza verso l'interno. Per risolvere questo, si suggerisce di spostare l'implementazione del repository nel livello Frameworks/Infrastructure e di definire le interfacce nel livello Application.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#livedata","title":"LIVEDATA","text":"<p>LiveData \u00e8 una classe di dati osservabile che \u00e8 legata al ciclo di vita dei componenti UI, come Activity o Fragment. Questo significa che LiveData permette di aggiornare la UI automaticamente quando i dati cambiano, ma solo quando la UI \u00e8 in uno stato attivo, evitando aggiornamenti inutili o errori quando la UI non \u00e8 visibile (ad esempio, se l'Activity \u00e8 in background). Implementa il pattern Observer.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#room","title":"ROOM","text":"<p>Room \u00e8 una libreria di persistenza fornita da Google che si colloca all'interno dei componenti dell'architettura Android, con l'obiettivo di semplificare l'interazione con il database SQLite del sistema operativo, fornendo un livello di astrazione.</p> <p>Room \u00e8 descritta come un modo efficace per creare database e salvare dati. Fornisce un accesso al database SQLite mappando oggetto-relazionale (ORM) basato su annotazioni.</p> <p>L'utilizzo di Room si articola principalmente su tre tipi di classi:</p> <ul> <li>Entit\u00e0: Sono Plain Old Java Objects (POJO) che modellano i dati da trasferire verso e dal database. Sono annotate con @Entity, specificando la tabella del database a cui corrispondono. Almeno una propriet\u00e0 deve essere designata come chiave primaria usando l'annotazione @PrimaryKey. Room crea una tabella nel database per ogni entit\u00e0.</li> <li>DAOs - Data Access Objects: Definiscono l'API per interagire con i dati, contenendo metodi per operazioni come query, inserimenti, aggiornamenti ed eliminazioni. I DAOs sono interfacce o classi astratte annotate con @Dao. Le operazioni sul database sono definite all'interno dei metodi del DAO tramite annotazioni come @Query, @Insert, @Update e @Delete. Room genera l'implementazione concreta di queste interfacce o classi astratte in fase di compilazione.</li> <li>Database: Rappresenta l'interfaccia principale al database SQLite sottostante. \u00c8 una classe astratta che estende RoomDatabase ed \u00e8 annotata con @Database, elencando tutte le entit\u00e0 utilizzate dal database e la sua versione. Contiene metodi astratti che restituiscono istanze dei DAO. Si ottiene un'istanza del database tramite un RoomDatabase.Builder.</li> <li>Relazioni tra Entit\u00e0: Sebbene Room supporti relazioni tramite chiavi esterne definite con l'annotazione @ForeignKey, non supporta riferimenti diretti tra entit\u00e0. Per rappresentare relazioni uno-a-molti o molti-a-molti e accedere agli oggetti correlati, si utilizza l'annotazione @Relation all'interno di una classe POJO separata che contiene i campi per le entit\u00e0 correlate. Per le relazioni molti-a-molti \u00e8 necessario implementare una \"join entity\" che crea la tabella di join associata.</li> </ul> <p></p> <p>In Room, le entit\u00e0 sono pensate pi\u00f9 come Data Transfer Objects (DTO) oggetti concepiti come un mezzo per trasferire dati tra diversi punti di un'applicazione. Modellano una risposta o sono ottimizzati per la creazione e la persistenza dei dati. Le Entity in Room rappresentano i dati che si desidera memorizzare nel database e sono anche l'unit\u00e0 tipica di un set di risultati recuperato dal database</p> <p></p> <p>Room pu\u00f2 essere integrato con LiveData per osservare i cambiamenti nel database. Un DAO pu\u00f2 restituire un oggetto LiveData da una query, consentendo all'interfaccia utente di aggiornarsi automaticamente quando i dati sottostanti cambiano.</p> <p>Room si integra bene con ViewModel, che gestisce i dati relativi alla View in modo indipendente dai cambiamenti di configurazione. Il ViewModel pu\u00f2 interagire con il database tramite un repository che utilizza Room.</p> <p>\u00c8 una buona pratica utilizzare il pattern Repository come livello intermedio tra Room e il resto dell'applicazione. Questo permette di astrarre l'accesso ai dati e, se in futuro vorrai cambiare il tipo di persistenza (ad esempio passare da Room a una sorgente di rete o cache), potrai farlo senza modificare i ViewModel o altri componenti della business logic.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#mvc","title":"MVC","text":"<p>Il [[MVC]] Model View Controller \u00e8 un modo per organizzare le funzionalit\u00e0 di un'applicazione separando gli oggetti in tre ruoli distinti:</p> <p></p> <p>Gli oggetti del modello non hanno alcuna conoscenza dell'interfaccia utente (UI). Il loro unico scopo \u00e8 la gestione e la detenzione dei dati.</p> <p>Model Il modello contiene i dati dell'applicazione e la logica di business.Le classi del modello sono progettate per rappresentare le entit\u00e0 con cui l'app lavora, come una domanda vero/falso. In Android, il livello del modello \u00e8 generalmente costituito da classi personalizzate create dallo sviluppatore. Il modello pu\u00f2 anche specificare la struttura dei dati dell'app e il codice per accedervi e manipolarli.</p> <p>View La vista \u00e8 responsabile della visualizzazione dei dati all'utente e della risposta alle azioni dell'utente. Ogni elemento visibile sullo schermo \u00e8 una vista. Android fornisce molteplici tipi di viste. Le viste sanno come disegnarsi sullo schermo e come rispondere all'input dell'utente, come i tocchi.</p> <p>Controller Il controllore agisce come un intermediario tra il modello e la vista. Contiene la logica dell'applicazione .I controllori rispondono agli eventi innescati dalle viste e gestiscono il flusso di dati da e verso il modello e la vista. In Android, un controllore \u00e8 tipicamente una sottoclasse di Activity, Fragment o Service.</p> <p>\u00c8 importante notare che il modello e la vista non comunicano direttamente. Il controllore si trova al centro, ricevendo messaggi da un lato e inviando istruzioni all'altro.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#benefici-dellmvc","title":"Benefici dell'MVC","text":"<ul> <li>Separazione delle responsabilit\u00e0: Aiuta a progettare e comprendere l'applicazione come un insieme di classi distinte.</li> <li>Migliore organizzazione del codice: La separazione in livelli (modello, vista, controllore) facilita la progettazione e la comprensione dell'applicazione a un livello superiore.</li> <li>Riutilizzabilit\u00e0 del codice: Le classi con responsabilit\u00e0 limitate sono pi\u00f9 riutilizzabili.</li> </ul>"},{"location":"30_Frameworks_Tools/Android/Android/#observer-synchronization","title":"Observer Synchronization","text":"<p>Questo approccio, strettamente associato all'MVC, si basa sul concetto che le viste e i controllori osservano il modello.</p> <p>Quando il modello subisce una modifica, viene notificato a tutti i suoi osservatori (le viste e potenzialmente i controllori).</p> <p>Le viste reagiscono a queste notifiche aggiornando la propria visualizzazione in base ai nuovi dati del modello.</p> <p>Il controllore, in questo modello, \u00e8 relativamente \"ignorante\" di quali altre viste potrebbero aver bisogno di essere aggiornate quando l'utente interagisce con una specifica vista. Il controllore si limita a modificare il modello, lasciando che il meccanismo di osservazione si occupi di propagare i cambiamenti alle viste interessate.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#flow-synchronization","title":"Flow Synchronization","text":"<p>Nella sincronizzazione tramite flusso, \u00e8 l'applicazione (spesso il controllore) che manipola direttamente le viste per riflettere i cambiamenti nel modello. Ad esempio, quando si apre una schermata o si preme un pulsante di salvataggio, il codice dell'applicazione si occupa di aggiornare esplicitamente i vari controlli (viste) con i dati del modello. In questo caso, il form (o l'attivit\u00e0/il fragment in Android) deve tenere traccia di quali controlli devono essere aggiornati in seguito a un cambiamento, il che pu\u00f2 diventare complesso in schermate elaborate.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#mvvm","title":"MVVM","text":"<p>Il pattern MVVM Model-View-ViewModel permette una gestione pi\u00f9 fluida della UI e una separazione pi\u00f9 chiara tra la logica di business e l'interfaccia utente.</p> <p>Il pattern MVVM \u00e8 composto da tre componenti principali:</p> <ol> <li>Model</li> <li>View</li> <li>ViewModel che da intermediario tra la View e il Model. \u00c8 responsabile della gestione dei dati da visualizzare nella UI e dell'elaborazione della logica necessaria per presentarli. La ViewModel fornisce i dati alla View tramite LiveData, che consente di osservare i cambiamenti dei dati e aggiornare automaticamente la UI quando necessario. La ViewModel non ha conoscenza diretta della View. Comunica con il Model per recuperare i dati e li prepara in una forma che la View pu\u00f2 facilmente consumare.</li> </ol>"},{"location":"30_Frameworks_Tools/Android/Android/#interazione-tra-i-componenti-nel-pattern-mvvm","title":"Interazione tra i componenti nel pattern MVVM","text":"<ol> <li>L'utente interagisce con la View (ad esempio, tocca un pulsante).</li> <li>La View invia un'azione al ViewModel (ad esempio, invoca un metodo che cambia i dati).</li> <li>Il ViewModel interagisce con il Model per recuperare o modificare i dati. In caso di operazioni asincrone, il ViewModel gestisce il flusso di lavoro.</li> <li>Quando il Model restituisce i dati (ad esempio tramite una chiamata API), il ViewModel li prepara (ad esempio, li converte in un formato adatto alla visualizzazione).</li> <li>Il ViewModel aggiorna un LiveData, che \u00e8 osservato dalla View.</li> <li>La View riceve i nuovi dati tramite LiveData e aggiorna automaticamente l'interfaccia utente.</li> </ol> <p>In questo modo, ogni componente ha un compito preciso:</p> <ul> <li>la UI si concentra solo sulla presentazione e l\u2019interazione,</li> <li>il ViewModel gestisce la logica di visualizzazione,</li> <li>il Repository coordina l\u2019accesso ai dati,</li> <li>e il livello Model (Room + Retrofit) fornisce le sorgenti dati reali.</li> </ul>"},{"location":"30_Frameworks_Tools/Android/Android_MOC/","title":"[[Android_OS]]of Content","text":"<p>Stato: #growing MOC Genitore: [[30_Frameworks_Tools_MOC]]</p>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#fondamentali-del-sistema","title":"\ud83c\udfd7\ufe0f Fondamentali del Sistema","text":"<p>Concetti di base sull'architettura e il funzionamento del sistema operativo.</p> <ul> <li>[[Android_OS]] \u2013 Note sull'architettura del kernel e del runtime.</li> <li>[[Compilazione_app]] \u2013 Panoramica generale sulla compilazione app android.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#componenti-core","title":"\ud83e\uddf1 Componenti Core","text":"<p>Le fondamenta di ogni app Android.</p> <ul> <li>[[Activity_e_Fragment]] \u2013 _Gestione dell'interfaccia utente.</li> <li>[[Service]] \u2013 _Operazioni in background.</li> <li>[[Broadcast_Receiver]] \u2013 _Comunicazione tra app e sistema.</li> <li>[[Content_Provider]] \u2013 _Gestione e condivisione dei dati.</li> <li>[[Intent]] - _Comunicazione interena fra applicazione e fra applicazioni diverse</li> <li>[[Notifiche]] -</li> <li>[[Setting]] -</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#fondamenti-di-ui","title":"\ud83c\udfa8 Fondamenti di UI","text":"<ul> <li>[[Gestione_UI_Android]] -</li> <li>[[Layout]] -</li> <li>[[Modelli_navigazionali]] -</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#ui-user-experience","title":"\ud83c\udfa8 UI &amp; User Experience","text":"<ul> <li>[[Jetpack Compose]] \u2013 Il nuovo standard per la UI dichiarativa.</li> <li>[[Material Design]] \u2013 Linee guida estetiche e funzionali.</li> <li>[[Gestione delle Risorse]] \u2013 Layout, stringhe e file in <code>/assets</code>.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#dati-e-networking","title":"\ud83d\udcbe Dati e Networking","text":"<ul> <li>[[Room Persistence Library]] \u2013 Astrazione su SQLite.</li> <li>[[Retrofit &amp; OkHttp]] \u2013 Consumo di API REST.</li> <li>[[Coroutines &amp; Flow]] \u2013 Gestione della concorrenza in Kotlin.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#testing-e-qualita","title":"\ud83e\uddea Testing e Qualit\u00e0","text":"<ul> <li>[[Unit Testing (JUnit)]]</li> <li>[[UI Testing (Espresso)]]</li> <li>[[Android Profiler]] \u2013 Monitoraggio di CPU, Memoria e Network.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#risorse-di-riferimento","title":"\ud83d\udd17 Risorse di Riferimento","text":"<ul> <li>Android Developers Documentation</li> <li>[[50_Project_Journal]] \u2013 Vedi i log dei progetti Android in corso.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_OS/","title":"Android OS","text":"<p>Android \u00e8 un sistema operativo sviluppato da Google basato su Linux e progettato per dispositivi mobile \u00e8 un sistema operativo open source . Quindi il suo codice sorgente \u00e8 pubblico e pu\u00f2 essere modificato da sviluppatori e produttori di hardware per creare la propria versione di Android e adattarlo a loro dispositivo, Il problema di questo \u00e8 che ci\u00f2 porta a una frammentazione eccessiva delle versioni e questo causa problemi quando dobbiamo sviluppare delle applicazioni, perch\u00e9 dobbiamo individuare il numero di dispositivi compatibili con la versione che dovremo sviluppare. Android cerca di risolvere il problema di compatibilit\u00e0 creando degli appositi librerie che si possono utilizzare con andiamo a sviluppare il codice</p> <p>Google gestisce il rilascio delle nuove versioni di Android sia per i propri dispositivi, la cui distribuzione avviene in maniera abbastanza rapida sia per gli altri dispositivi di altri produttori. Il sistema operativo di questi seguire. Deve seguire un processo di qualifica da parte di Google. Questo vuol dire che ogni qualvolta che Google rilascia un aggiornamento ogni produttore deve adattarlo al proprio hardware del dispositivo e questo richiede molto tempo perch\u00e9 modificano anche l\u2019interfaccia. Una volta che hanno effettuato queste modifiche la versione deve essere approvata da Google per garantire che soddisfi standard di qualit\u00e0 compatibilit\u00e0 e sicurezza se si superano questi test al loro i produttori potranno rilasciare il loro aggiornamento per i loro dispositivi.</p> <p>Il sistema Android \u00e8 interamente sviluppato sopra al kernel Linux. Il motivo di questa scelta \u00e8 dovuto al fatto che non sarebbero mai stati in grado di sviluppare un sistema completamente funzionante in tempi rapidi per poter entrare nel mercato. Linux era gi\u00e0 un sistema operativo pienamente funzionante sotto ogni aspetto e che funzionava in modo molto efficiente e quindi l\u2019idea di Google fu quello di estendere il sistema operativo Linux per adattarlo ai dispositivi mobile.</p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#linux-kernel","title":"Linux Kernel","text":"<p>Questo livello fornisce i servizi di gestione dell'hardware. A questo livello, viene applicato uno schema di protezione per limitare l'accesso ai dati e alle risorse e consentirlo solo ai processi che posseggono l'adeguato livello di autorizzazione. Vi sono i moduli per la gestione della memoria, dei processi, del sistema di archiviazione e della comunicazione sulla rete. Vi sono i driver per la gestione dell'hardware in dotazione al dispositivo, ad esempio la memoria ausiliaria, la radio, la fotocamera. Oltre ai servizi offerti dal nucleo del sistema operativo, il kernel di Android include alcuni componenti particolari, quali ad esempio il sistema di risparmio energetico, il sistema di gestione e condivisione della memoria, un meccanismo di comunicazione tra processi chiamato binder, che permette ai processi di condividere dati e servizi.</p> <p></p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#hardware-abstraction-level","title":"Hardware Abstraction Level","text":"<p>Sopra al kernel troviamo HAL che fornisce interfacce standard per esporre le funzionalit\u00e0 hardware del dispositivo al framework API di livello superiore. HAL \u00e8 formato da pi\u00f9 moduli, ognuno dei quali implementa un\u2019interfaccia per un tipo di componente hardware Linux . quando il framework fa una chiamata per accedere all\u2019hardware del dispositivo Android carica il modulo di libreria di quella componente. I moduli sono scritti dal produttore.</p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#android-runtime","title":"Android RunTime","text":"<p>L\u2019Android Runtime \u00e8 composto dalla macchina virtuale ART (che ha sostituito Dalvik) e dalle librerie principali del sistema. ART \u00e8 un ambiente di esecuzione in cui ogni app viene eseguita nel proprio processo, con una propria istanza di ART.</p> <p>ART traduce il codice scritto in Java o Kotlin in bytecode, che viene poi convertito in codice nativo comprensibile dal processore del dispositivo. Utilizza principalmente un approccio di compilazione Ahead-of-Time (AOT): quando si installa una nuova app, questa viene compilata in codice nativo gi\u00e0 durante la fase di installazione, migliorando cos\u00ec le performance in fase di esecuzione.</p> <p>Inoltre, ART pu\u00f2 usare la modalit\u00e0 Just-In-Time (JIT) per compilare dinamicamente solo alcune parti del codice durante l\u2019esecuzione dell\u2019app, migliorando la reattivit\u00e0 e riducendo i tempi di compilazione iniziale.</p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#native-cc-library-ndk","title":"Native C/C++ Library NDK","text":"<p>Sempre sopra ad HAL troviamo le NDK strumenti per sviluppare app in C/C++. Sono utili per implementare funzionalit\u00e0 che richiedono altre performance o se dobbiamo implementare parte di codice che devono comunicare direttamente con l\u2019hardware.</p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#java-api-framework","title":"Java API Framework","text":"<p>Sopra ai livelli di Android Runtime e HAL troviamo il Java API Framework, un insieme di librerie, classi e interfacce scritte in Java/Kotlin che permettono di interagire facilmente con le funzionalit\u00e0 hardware e software del dispositivo.</p> <p>Questo livello \u00e8 progettato per semplificare lo sviluppo delle app, fornendo un accesso ad alto livello alle componenti del sistema operativo Android</p> <p>Le API mettono a disposizione implementazioni predefinite delle componenti fondamentali del sistema, che possono essere estese e personalizzate dagli sviluppatori per costruire le funzionalit\u00e0 specifiche dell'app.</p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#applicazioni","title":"Applicazioni","text":"<p>Sopra questo livello troviamo le applicazioni dell\u2019utente.</p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#android-sdk","title":"Android SDK","text":"<p>L\u2019android software development kit ASDK \u00e8 un set di librerie e strumenti per sviluppare un app android. I tool si dividono in;</p> <ul> <li>SDK platform, tools platform dependent. Una nuova versione di queste \u00e8 rilasciata ad ogni versione di android e include librerie, codici sorgenti ecc</li> <li>SDK tools che sono platform indipendent. Sono strumenti usati per sviluppare , farete bugno a disposizione un emulatore per simulate un dispositivo mobile. Ha un android Debug Brigde che permette di comunicare con il dispositivo per eseguire operazioni varie per fare testing e debug.</li> </ul>"},{"location":"30_Frameworks_Tools/Spring/Spring_MOC/","title":"\ud83d\uddfa\ufe0f Spring (MOC)","text":"<p>Stato: #seed | Collegamenti: [[index]]</p>"},{"location":"30_Frameworks_Tools/Spring/Spring_MOC/#indice-argomenti","title":"\ud83d\udccc Indice Argomenti","text":""},{"location":"40_Design_Patterns/Architecture_Overview/","title":"Architecture Overview","text":"<p>Stato: #seed</p>"},{"location":"40_Design_Patterns/Architecture_Overview/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"40_Design_Patterns/SOLID_Principles/","title":"SOLID Principles","text":"<p>Stato: #seed</p>"},{"location":"40_Design_Patterns/SOLID_Principles/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"40_Design_Patterns/Software%20Design%20Note/","title":"Software Design Note","text":"<p>SOFTWARE DESIGN</p> <p>Andare a definire il concetto di qualit\u00e0 per un software non \u00e8 proprio semplice, perch\u00e9 pe un software non \u00e8 possibile definire degli obiettivi precisi, questi dipendono da cosa ha bisogno chi richiede il software</p> <p>La qualit\u00e0 viene definita sulla base di alcune caratteristiche si possono attribuire al codice come:</p> <ul> <li>Funzionalit\u00e0</li> <li>Reliabulity</li> <li>Usabilit\u00e0</li> <li>Efficienza</li> <li>Manutenibilit\u00e0</li> <li>Portabilit\u00e0</li> <li>Component replacebility</li> </ul> <p>Partendo da queste caratteristiche si definiscono delle metriche per misurare queste, e sulla base di queste \u00e8 definita la qualit\u00e0 di un software. \u00c8 necesarrio capire quindi come aggregare queste misure.</p> <p>La progettazione del software (il processo) \u00e8 la costruzione di astrazioni di dati e calcolo e l'organizzazione di queste astrazioni in un'applicazione software funzionante - Martin P. Robillard</p> <p>Quindi questo vuol dire andare a definire che struttura dati usiamo per il contesto, come gestiamo le eccezione ecc. Si tratta di un processo euristico e iterativo guidato dalla conoscenza della materia e che porta a scrivere un codice che sia progettualmente pulito in modo da avere meno errori ed \u00e8 possibile modificare con pi\u00f9 semplicit\u00e0.</p> <p>L\u2019obiettivo del software design \u00e8 quello di andare a definire in modo chiaro il contesto che andiamo a modellare, definendo i requisiti e constraint del dominio.</p> <p>Il design pu\u00f2 essere inteso come un insieme di decisioni per modellare il problema e che ci permettono di catturare la conoscenza del dominio. Per poter fare questo le soluzione sono descritte tramite dei modelli che vengono chiamati design patter e che furono introdotti dalla GoF, i quattro cristi che hanno dato via e evoluto il movimento agile.</p> <p>Crearono un catalogo di 23 design patter, dando soluzioni a problemi ricorrenti.</p> <p>I pattern non sono implementazioni concrete, ma \u201cschemi che defiscono un certo modo d struttura il codice per poter rendere il codice pulito e comprensibile.</p> <p>DESIGN PATTER</p> <p>Un design pattern ha 4 componenti principali:</p> <ul> <li>nome del pattern, \u00e8 il modo con cui in una o due parole possiamo riferirci ad un problema, la sua soluzione e le conseguenze della sua applicazione.</li> <li>problema descrive quando \u00e8 possibile applicare il pattern. Esso cio\u00e8 esplicita il contesto.</li> </ul> <p>contestoinsieme di condizioni e situazioni in cui un pattern \u00e8 applicabile</p> <ul> <li>soluzione, descrive gli elementi che fanno parte del progetto, le loro relazioni, responsabilit\u00e0 e collaborazioni. Essa non descrive una specifica implementazione in quanto un pattern deve poter essere applicabile in diverse situazioni concrete.</li> <li>conseguenze, sono il risultato di trade-offs derivanti dall'applicazione del pattern. Esse sono di importanza critica nella valutazione di alternative di progetto e per la comprensione di costi e benefici relative all'applicazione del pattern.</li> </ul> <p>I pattern sono classificai sulla base del</p> <ul> <li>purpose, cosa fa</li> <li>scope, se si applica alle classi o agli oggetti</li> </ul> <p>Creational Patterns</p> <p>Gestiscono la creazione degli oggetti, cercando di astrarre il processo di istanziazione. Lo scopo \u00e8 rendere il sistema indipendente dalla modalit\u00e0 di creazione, composizione e rappresentazione degli oggetti.</p> <p>Structural Patterns</p> <p>Si occupano della composizione delle classi e degli oggetti, facilitando la creazione di strutture flessibili ed efficienti.</p> <p>Behavioral Patterns</p> <p>Si concentrano sugli algoritmi e sulla comunicazione tra oggetti, migliorando l'interazione e la responsabilit\u00e0 tra componenti.</p> <p>Principi della OOP alla Base dei Design Pattern</p> <p>I principali concetti su cui si basano i design pattern sono quattro: incapsulamento, astrazione, ereditariet\u00e0 e polimorfismo.</p> <p>Incapsulamento il principio secondo cui i dettagli interni di un oggetto devono essere nascosti (Information Hiding) al mondo esterno, esponendo solo ci\u00f2 che \u00e8 strettamente necessario attraverso un\u2019interfaccia pubblica. Questo consente di proteggere lo stato interno dell\u2019oggetto da modifiche non autorizzate e di mantenere sotto controllo la complessit\u00e0 del sistema.</p> <p>Astrazione permette di modellare concetti complessi nascondendone i dettagli non rilevanti, concentrandosi solo sulle caratteristiche fondamentali. Questo principio guida la progettazione di interfacce e classi astratte, che permettono di definire comportamenti generici che possono poi essere specializzati da classi concrete.</p> <p>Ereditariet\u00e0 consente di riutilizzare il codice definito in una classe base in una o pi\u00f9 classi derivate. Questo facilita la costruzione di gerarchie di classi in cui le specializzazioni si basano su un comportamento generico gi\u00e0 definito. Nei design pattern, questo principio \u00e8 spesso usato per delegare la responsabilit\u00e0 di alcune operazioni a sottoclassi.</p> <p>Polimorfismo consente di trattare oggetti di classi diverse come se appartenessero alla stessa interfaccia, sfruttando la possibilit\u00e0 di invocare metodi in modo dinamico a seconda del tipo reale dell\u2019oggetto.</p> <p>I Principi SOLID</p> <p>Oltre ai principi fondamentali dell\u2019OOP, molti design pattern si ispirano ai principi SOLID, un insieme di linee guida introdotte da Robert C. Martin (Uncle Bob) per facilitare la progettazione di software mantenibile ed estensibile:</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-single-responsibility-principle-srp-ogni-classe-o-metodo-dovrebbe-avere-una-sola-responsabilita-o-motivo-di-cambiamento","title":"1. Single Responsibility Principle (SRP) \u2013 Ogni classe o metodo dovrebbe avere una sola responsabilit\u00e0 o motivo di cambiamento.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-openclosed-principle-ocp-le-entita-software-dovrebbero-essere-aperte-allestensione-ma-chiuse-alla-modifica","title":"2. Open/Closed Principle (OCP) \u2013 Le entit\u00e0 software dovrebbero essere aperte all\u2019estensione ma chiuse alla modifica.","text":"<p>Le classi sono aperte alle estensioni tramite l\u2019implementazione di interfacce o l\u2019ereditariet\u00e0, ma chiuse alle modifiche, poich\u00e9 il comportamento esistente rimane inalterato. Favorisce la modularit\u00e0 del codice e la facilit\u00e0 di estensione del sistema. Possiamo aggiungere nuovi tipi di veicoli senza dover modificare il codice esistente, garantendo una maggiore stabilit\u00e0 e riducendo il rischio di introdurre nuovi bug.</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#3-liskov-substitution-principle-lsp-le-classi-derivate-devono-poter-sostituire-le-classi-base-senza-alterare-il-comportamento-previsto-questo-principio-e-fondamentale-per-garantire-che-luso-del-polimorfismo-sia-corretto-e-prevedibile","title":"3. Liskov Substitution Principle (LSP) \u2013 Le classi derivate devono poter sostituire le classi base senza alterare il comportamento previsto. Questo principio \u00e8 fondamentale per garantire che l\u2019uso del polimorfismo sia corretto e prevedibile.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#4-interface-segregation-principle-isp-e-meglio-avere-interfacce-specifiche-e-limitate-piuttosto-che-una-singola-interfaccia-generica-e-pesante","title":"4. Interface Segregation Principle (ISP) \u2013 \u00c8 meglio avere interfacce specifiche e limitate piuttosto che una singola interfaccia generica e pesante.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#5-dependency-inversion-principle-dip-le-classi-dovrebbero-dipendere-da-astrazioni-non-da-classi-concrete-riducendo-laccoppiamento-tra-le-componenti-del-sistema","title":"5. Dependency Inversion Principle (DIP) \u2013 Le classi dovrebbero dipendere da astrazioni, non da classi concrete riducendo l\u2019accoppiamento tra le componenti del sistema.","text":"<p>ANTIPATTER</p> <p>Come esistono le buone idee, esistono anche le idee di merda\u2026 i bad smells, o antipattern, soluzioni che sembrano ottime, ma fanno cagare.</p> <p>ENCAPSULATION</p> <p>Il PRIMITIVE OBSESSION \u00e8 un antipattern in cui si usa eccessivamente tipi primitivi (come stringhe, interi, booleani, ecc.) per rappresentare concetti complessi o entit\u00e0 del dominio del problema, invece di creare tipi o classi specifiche per quei concetti.</p> <p>Questo \u00e8 un problema perch\u00e9 ci\u00f2 rende il codice meno chiaro e meno espressivo, aumenta il rischio di errori perch\u00e9 non c\u2019\u00e8 nessuna validazione o comportamento incapsulato o controllo sui valori che pu\u00f2 assumere.</p> <p>Quindi quando dobbiamo rappresentare oggetti della realt\u00e0 nel codice conviene creare un classe che li modelli per avere pi\u00f9 controllo su di esso. Creando una classe incapsuliamo anche la logica e di funzionamento con tutte le informazioni ad essere relative.</p> <p>L\u2019Escaping References accade quando un oggetto \u201clascia scappare\u201d i riferimenti ai suoi dati interni, cio\u00e8 quando d\u00e0 accesso diretto a qualcosa che dovrebbe invece tenere nascosto e sotto controllo.</p> <p>Per esempio, immagina che una classe abbia una lista di cose importanti, tipo le transazioni di un conto bancario. Se questa lista viene restituita direttamente quando qualcuno la chiede, allora quella persona pu\u00f2 cambiarla a piacimento, anche senza passare dai metodi sicuri della classe.</p> <p>Questo \u00e8 un problema perch\u00e9 cos\u00ec perdi il controllo su cosa succede dentro l\u2019oggetto. La lista potrebbe essere modificata in modo sbagliato, causando errori o dati incoerenti.</p> <p>Non basta dichiarare una variabile di istanza privata per evitare l\u2019escape reference, perch\u00e9 anche usando i getter, potremmo degradare l\u2019incapsulamento. Avere una classe a cui si accede solo tramite i getter e i setter \u00e8 una debolezza delle progettazione, noto come INAPPROPRIATE INTIMACY, perch\u00e9 le classi passano troppo tempo a esplorare le parti private delle altre. BAH! Sono gli oggetti che dovrebbero interagire tra loro usando i metodi che hanno a disposizione.</p> <p>La soluzione? Non dare mai direttamente i tuoi dati \u201cinterni\u201d, ma invece restituisci una copia di quei dati. In questo modo chi riceve la lista pu\u00f2 modificarla quanto vuole, ma senza influenzare quella originale dentro l\u2019oggetto. Oppure, puoi usare metodi specifici per far fare le modifiche solo in modo controllato. Cos\u00ec, mantenere tutto sotto controllo diventa pi\u00f9 facile e il codice rimane pi\u00f9 robusto.</p> <p>Un\u2019altra soluzione \u00e8 l\u2019immutabilit\u00e0 in modo da rendere le classi immodificabili nel loro stato interno, se non tramite i suoi metodi.</p> <p>Design by Contract, \u00e8 un approccio in cui ogni componente software \u00e8 visto come un contratto e stabilisce cosa ogni parte deve garantire e cosa si aspetta in cambio.Un contratto, nel contesto del software, si basa su tre elementi:</p> <ul> <li>Precondizioni: sono le condizioni che devono essere vere prima che un\u2019operazione venga eseguita. Il chiamante ha la responsabilit\u00e0 di assicurarsi che queste condizioni siano soddisfatte. Se le precondizioni non sono rispettate, il comportamento del metodo \u00e8 indefinito.</li> <li>Postcondizioni: sono le condizioni che il metodo garantisce al termine della sua esecuzione, a patto che le precondizioni fossero vere. Se il metodo ha completato correttamente, allora queste condizioni devono sempre risultare vere.</li> <li>Invarianti: sono condizioni che devono rimanere sempre vere durante l\u2019intera vita di un oggetto. Esse definiscono lo stato valido dell\u2019oggetto e aiutano a mantenere la coerenza interna indipendentemente dalle operazioni eseguite.</li> </ul> <p>TYPES E INTERFACE</p> <p>Sappiamo che cos\u2019\u00e8 un interfaccia nella OOP. Un particolarit\u00e0 di queste sottovalutata \u00e8 la possibilit\u00e0 di gestire il polimorfismo e anche l\u2019ereditariet\u00e0 multipla che in java non \u00e8 permessa.</p> <p>Nelle classi che progettiamo il fatto di mettere i metodi direttamente nella classe, causa il problema dell\u2019accoppiamento con la sua definizione. Un principio importante di progettazione \u00e8 il disaccoppiamento del comportamento dalla definizione della classe per rendere il tutto pi\u00f9 indipendente dal tipo di servizio che deve essere implementato. L\u2019interfaccia permette di definire un tipo, obv con la caratteristica che l\u2019interfaccia non si pu\u00f2 instanziare, ma le sue classi concrete s\u00ec. La relazione che si viene a creare fra l\u2019interfaccia e la sua classe concreta, \u00e8 una relazione polimorfica di sottotipo, quindi \u00e8 possibile assegnare ad una variabile definita come tipo interfaccia, una qualunque classe concreta che implementa l\u2019interfaccia.</p> <p>Il polimorfismo permette:</p> <ul> <li>l\u2019accoppiamento debole, perch\u00e9 il codice che utilizza un insieme di metodi vincolato ad una specifica implementazione, si definisce a runtime, quindi si possono chiamare solo i metodi in essa definiti</li> <li>l\u2019estensibilit\u00e0 perch\u00e9 possiamo facilmente aggiungere nuove implementazioni</li> </ul> <p>L\u2019interfaccia pu\u00f2 servire anche a definire un comportamento per le classi che le implementano. Tipo Comparable. Per rispettare il principio ISP le interfacce devono implementare pochi metodi, e in questo cosa per definire i comportamenti solo uno. <p>Se non usassimo una interfaccia dovremmo modificare in modo pesante il codice, questo antipattern \u00e8 noto come SWITCH STATEMENT. La soluzione \u00e8 quella di creare una classe che implementa l\u2019interfaccia e un certo comportamento. Queste sono dette anche function object che solo classi con solo funzioni. Tutto ci\u00f2 pu\u00f2 essere evitato con:</p> <ul> <li>nested class, si definisce la classe nello scope di un\u02bcaltra</li> <li>anonymous class, una classe senza nome che viene definita e istanziata direttamente nel punto in cui serve</li> <li>lambda expression, una forma compatta di scrivere funzioni anonime, usata per implementare interfacce funzionali, cio\u00e8 interfacce con un solo metodo astratto.</li> </ul> <p>Queste possono essere passate ad altre funzione, che oltre a prendere dati prendono funzioni, comportamenti diversi che vengono applicati sui dati, in modo che venga eseguita a un certo punto.</p> <p>Questo viola l\u2019incapsulamento perch\u00e9 usano il costruttore o gli altri modi mostriamo lo stato della classe. Un modo per rafforzarlo \u00e8 lo STATIC FACTORY METHOD che nasconde la logica di creazione. Consiste nell\u2019implementare un metodo statico che restituisce un\u2019istanza di quella classe.</p> <ul> <li>I metodi factory statici possono restituire lo stesso tipo che implementa il metodo, un sottotipo e anche primitive, offrendo una gamma pi\u00f9 flessibile di tipi restituiti</li> <li>I metodi factory statici possono essere metodi a istanziazione controllata, con il pattern Singleton, lo Strategy.</li> <li>Il factory method possono essre usati per creare oggetti immutabili, impedendo la modifica dello stato dopo la creazione. Questo rinforza ulteriormente l\u2019incapsulamento.</li> </ul> <p>STRATEGY PATTER</p> <p>Il fatto che alle objects function possiamo passare comportamenti simili, ma diversi, \u00e8 possibile grazie allo strategy pattern che permette di fornire una famiglia di algoritmi che implementa la stessa interfaccia, ma hanno un\u2019implementazione diversa. La scelta dell\u2019algoritmo dipende dal contesto che viene passato del client, quindi \u00e8 determinato a runtime.</p> <p></p> <p>ITERATOR PATTERN</p> <p>Un requisito di design per la progettazione delle strutture dati \u00e8 l\u2019accesso ai dati che contiene, ma senza violare il principio dell\u2019information hiding. Una soluzione migliore di ritornare una copia della collezione \u00e8 quella di fornire un metodo di accesso a questi dati, un iteratore che nasconde la struttura interna di come sono memorizzati i dati. Questo fortifica l\u2019incapsulamente, tranne nel caso ci siamo il metodo remove(). L\u2019iterator pattern fa proprio questo.</p> <p></p> <p>DEPENDENCY INJECTION</p> <p>Quando creiamo delle classi questi possono avere bisogno di oggetti di altre classi, quindi nel costruttore creiamo un\u2019istanza dell\u2019oggetto che ci server per completare la classe. SI viene a creare un dipendenza. (Pure le classi si drogano\u2026bha). Questo \u00e8 un problema perch\u00e9 lo leghiamo alla classe che viene iniettata e se questa cambia comportamento, definizione ecc, dobbiamo modificare ogni classe che ha una sua istanza. E pensa che palle.</p> <p>Una soluzione pu\u00f2 essere quella di usare le lambda, ma ci sono gli stessi problemi. Allora dobbiamo cercare di disaccoppiare le classi e lo si pu\u00f2 fare iniettando la dipendenza nella classe. (Ora la droghiamo noi). Lo si pu\u00f2 fare facendo stabile al client cosa usare. Ci sono anche altre soluzioni [VEDI DOPO]</p> <p>OBJECT STATE</p> <p>Si pu\u00f2 avere una visione duplice dello stato di un programma.</p> <p>statica, che avviene a compile-time, dove il codice viene analizzato e tradotto in un formato eseguibile. In questa fase, il compilatore conosce le dichiarazioni delle classi, i metodi disponibili, le gerarchie di ereditariet\u00e0 e i tipi associati alle variabili.</p> <p>dinamica, che avviene a run-time, in cui il comportamento effettivo del programma dipende da molti fattori che non sono visibili durante la compilazione, come i dati di input, le condizioni che si verificano nei vari rami del codice, lo stato interno degli oggetti e, soprattutto, il tipo reale degli oggetti creati in memoria.</p> <p>Queste due non \u00e8 detto che coincidano sempre. Questo \u00e8 dovuto al fatto al polimorfismo. Possiamo usare per rappresentare i possibili stati di un oggetto con i sequence, state e object diagrams.</p> <p>Importante \u00e8 definire l\u2019object state che si pu\u00f2 avere di un oggetto. Possiamo dire che un oggetto avr\u00e0 uno stato concreto, cio\u00e8 i valori che possono assumere le variabili che definiscono una classa. Bisogna considerare anche il suo state space, che rappresenta tutti i possibili valori che pu\u00f2 assumere. Ovviamente non sempre \u00e8 possibile rappresentarli tutti allora ci \u00e8 utile definire un sottoinsieme di queste, lo abstract space. Questo deve essere significato e deve cogliere gli aspetti importanti di come lo stato cambia e quali sono i suoi possibili passaggi di stato.</p> <p>Lo state diagram pu\u00f2 aiutare a fare questo e ci mostra il ciclo di vita di un oggetto.</p> <p>PRINCIPIO DI DESIGN evitare cicli di vita troppo complessi e minimizzare</p> <p>Lo spazio degli statti un oggetto</p> <p>Alcuni stati nello spazio degli stati potrebbero essere una conseguenza di come un oggetto \u00e8 progettato o implementato, senza che ci sia utilit\u00e0 per un oggetto in quello stato in un dato sistema software. In questi casi, eliminare alcuni stati dal ciclo di vita di un oggetto pu\u00f2 sembrare una buona idea, ma se se un giorno ne avessimo bisogno? Si cade nell\u2019antipattern della SPECULATIVE GENERALITY, cio\u00e8 ci preoccupiamo del futuro, ma non serve, se serviranno verranno aggiunte in seguito, mo pensa al presente.</p> <p>Sbagliato \u00e8 anche cachare informazioni nelle variabili di istanza, ma in realt\u00e0 dipende da situazione a situazione. Se usiamo un metodo per accedere a quello stato, ma si sa che quella informazione non verr\u00e0 mai modificato, allora la si pu\u00f2 storare nella classe. Se pu\u00f2 essere modificata nel corso del ciclo di vita dell\u2019oggetto allora teniamo il metodo per accedere a quello stato. \u00c8 un trade-off che dobbiamo tenere conto, se risparmiare un po' di tempo a costo di un po' di memoria extra, o viceversa. Il principio generale \u00e8 che le informazioni non dovrebbero essere memorizzate in un oggetto a meno che non contribuiscano in modo univoco al valore intrinseco rappresentato dall'oggetto, questo antipattern \u00e8 il TEMPORARY FIELD.</p> <p>I campi temporanei e tutto il codice che li gestisce possono essere inseriti in una classe separata tramite Extract Class. In altre parole, si crea una classe che ha quella informazione e si usa un metodo per poter accedere a quelle informazioni.</p> <p></p> <p>Questo metodo di refactoring contribuir\u00e0 a mantenere l'aderenza al principio di responsabilit\u00e0 unica.</p> <p>Introdurre NULL OBJECT e integrarlo al posto del codice condizionale utilizzato per verificare l'esistenza dei valori dei campi temporanei. Ma prima parliamo della nullability, la possibilit\u00e0 di assegnare valori null alle variabili per indicare l\u2019assenza di valore. Prima non si poteva, fu introdotto da Tony Hoare, con l\u2019obiettivo di rendere i riferimenti pi\u00f9 sicuro. Ma \u00e8 stata una idea del cazzo, perch\u00e9 ha introdotto altri problemi come, NullPointerException, SegmentationFault, difficolt\u00e0 nella verifica ecc\u2026</p> <p>Per evitare di ampliare lo spazio di stato di un oggetto con riferimenti nulli, una buona pratica consigliata \u00e8 progettare le classi in modo che i riferimenti nulli non vengano utilizzati. Ci sono vari modi per farlo.</p> <ul> <li>Assegnare i valori nel costruttore</li> <li>Verificare se i valori sono nulli e nel caso lanciare exception</li> <li>Design by contract</li> <li>modi migliori\u2026</li> </ul> <p>Gli optional type, sono delle classi wrapper che contengono un istanza del tipo che wrappiamo oppure non lo contengono. Come il gatto di Schr\u00f6dinger, non sai cosa contiene finch\u00e8 non unwrappi. Quindi il programmatore vedendo un costrutto del genere fa pi\u00f9 attenzione a fare controlli ecc.</p> <p>Un problema di questa soluzione e che perdiamo il tipo delle variabili, quindi dovremmo creare dei metodi per ottenere i tipi effettivi.</p> <p>Ritornando al NULL OBJECT, permette di risolvere questo problema e la nullability, prevedendo un oggetto che rappresenta il valore null per quella classe. Anche questo si basa sul polimorfismo.</p> <p>Consiste nell\u2019aggiungere un metodo per determinare su un oggetto \u00e8 nullo o meno e a secondo della condizione restituire o null o no. Oppure implementare una factory che nasconde tutto il funzionamento</p> <p>Per minimizzare ancora di pi\u00f9 lo spazio degli stati, possiamo oltre ad usare una classe Enumerate, stabilire anche un vincolo sul numero di volte che una variabile pu\u00f2 essere modificata. In java si pu\u00f2 usare final, per dire che il campo una volta assegnato non pu\u00f2 essere pi\u00f9 modificato e se si provasse a farlo avremmo un errore a compilation time. Da notare che la variabile final, contine un riferimento, ed \u00e8 questo che non pu\u00f2 essere modificato, ma lo stato dell\u2019oggetto riferito s\u00ec. I campi final per\u00f2 non rendono immutabili gli oggetti referenziati. A volte si usa la parola chiave final per chiarire che una variabile non deve essere modificata dopo la sua inizializzazione. Questo pu\u00f2 aiutare a rendere il codice pi\u00f9 leggibile, specialmente quando ci si trova in contesti pi\u00f9 lunghi o complessi dove il rischio di errore o confusione \u00e8 maggiore. Ma questo non dovrebbe essere mai fatto per via dell\u2019antipattern LONG METHOD che stabilisce che i metodi lunghi devono essere evitati.</p> <p>Tre concetti da tenere a mente quando si progettano i cicli di vita degli oggetti sono quelli di identit\u00e0, uguaglianza e unicit\u00e0.</p> <p>L'identit\u00e0 si riferisce al fatto che ci si riferisce a un oggetto specifico, anche se questo non si trova in una variabile, cio\u00e8 l'identit\u00e0 di un oggetto si riferisce solitamente alla sua posizione di memoria o riferimento/puntatore.</p> <p>L'uguaglianza tra due oggetti deve essere definita dal programmatore perch\u00e9 il significato dell'uguaglianza non pu\u00f2 sempre essere dedotto dalla progettazione della classe dell'oggetto</p> <p>L\u2019unicit\u00e0, il fatto di avere una solo istanziazione per quella classe. Se si pu\u00f2 garantire che gli oggetti di una classe siano unici, non \u00e8 pi\u00f9 necessario definire l'uguaglianza, perch\u00e9 in questo caso specifico, l'uguaglianza diventa equivalente all'identit\u00e0 e possiamo confrontare gli oggetti utilizzando l'operatore ==. Garanzie di unicit\u00e0 sono quasi impossibili da ottenere in Java a causa di meccanismi come la metaprogrammazione e la serializzazione.</p> <p>FLYWEIGHT PATTER</p> <p>Il Flyweight consiste nel condividere parti comuni dello stato tra oggetti, evitando di duplicare dati che possono essere riutilizzati. Gli oggetti flyweight sono spesso immutabili e leggeri, e servono a rappresentare solo lo stato intrinseco, mentre lo stato estrinseco viene passato dall\u2019esterno quando serve. Invece di creare milioni di oggetti simili, si condividono quelli uguali per risparmiare memoria.</p> <p>Per gestire la creazione di oggetti di una classe, si crea una classe flyweight. Le cui istanze sono chiamate oggetti flyweight. I tre componenti principali necessari per realizzare questo vincolo sono:</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-un-costruttore-privato-per-la-classe-flyweight-in-modo-che-i-client-non-possano-controllare-la-creazione-di-oggetti-della-classe","title":"1. Un costruttore privato per la classe flyweight, in modo che i client non possano controllare la creazione di oggetti della classe;","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-un-archivio-statico-di-oggetti-flyweight-che-conserva-una-collezione-di-oggetti-flyweight","title":"2. Un archivio statico di oggetti flyweight che conserva una collezione di oggetti flyweight;","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#3-un-metodo-di-accesso-statico-che-restituisce-loggetto-flyweight-univoco-corrispondente-a-una-chiave-di-identificazione-il-metodo-di-accesso-in-genere-verifica-se-loggetto-flyweight-richiesto-esiste-gia-nellarchivio-lo-crea-se-non-esiste-gia-e-restituisce-loggetto-univoco","title":"3. Un metodo di accesso statico che restituisce l'oggetto flyweight univoco corrispondente a una chiave di identificazione. Il metodo di accesso in genere verifica se l'oggetto flyweight richiesto esiste gi\u00e0 nell'archivio, lo crea se non esiste gi\u00e0 e restituisce l'oggetto univoco.","text":"<p>Quando lo spazio degli stati di una variabile \u00e8 limitato e ben definito, \u00e8 possibile inizializzare gli oggetti tramiteun blocco statico, che viene eseguito al primo caricamento della classe. In alternativa, si pu\u00f2 usare una struttura dati statica. Questo approccio \u00e8 statico perch\u00e9 l\u2019archivio dei flyweight \u00e8 condiviso a livello di classe, e non ha senso dover accedere a un oggetto tramite un'altra istanza dello stesso tipo. Questa combinazione di archivio statico e metodo di accesso viene spesso chiamata flyweight factory.</p> <p>Per facilitare l'accesso ai vari oggetti flyweight, si pu\u00f2 implementare un metodo factory che gestisce un pool di istanze esistenti. Il metodo accetta lo stato intrinseco richiesto, cerca un oggetto corrispondente nel pool e, se lo trova, lo restituisce; altrimenti, crea una nuova istanza, la aggiunge al pool e poi la restituisce.Questo metodo factory pu\u00f2 essere collocato in vari posti, a seconda del contesto:</p> <ul> <li>In un contenitore di flyweight dedicato</li> <li>In una classe factory separata</li> <li>Oppure come metodo statico all\u2019interno della stessa classe flyweight</li> </ul> <p>Un aspetto importante da considerare nell'implementazione del pattern FLYWEIGHT \u00e8 se pre-inizializzare l'archivio flyweight o se farlo in modo lazy, creando oggetti man mano che vengono richiesti tramite il metodo di accesso. Dipende dal contesto. Il pattern FLYWEIGHT \u00e8 utile quando si devono gestire oggetti flyweight immutabili, anche se ci possono essere errori se implementato in modo scorretto.</p> <p></p> <p>SINGLETON PATTERN</p> <p>Il Singleton viene utilizzato quando si desidera che una determinata classe abbia una sola istanza durante tutta l'esecuzione del programma, e che tale istanza sia facilmente accessibile da qualsiasi punto del codice.</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-un-costruttore-privato-per-la-classe-singleton-in-modo-che-i-client-non-possano-creare-piu-oggetti","title":"1. Un costruttore privato per la classe singleton, in modo che i client non possano creare pi\u00f9 oggetti;","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-una-variabile-globale-per-contenere-un-riferimento-alla-singola-istanza-delloggetto-singleton","title":"2. Una variabile globale per contenere un riferimento alla singola istanza dell'oggetto singleton.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#3-un-metodo-di-accesso-solitamente-chiamato-instance-che-restituisce-il-singleton-in-istanza-il-metodo-di-accesso-e-facoltativo-poiche-e-anche-possibile-implementare-il-pattern-dichiarando-listanza-globale-come-costante-pubblica","title":"3. Un metodo di accesso, solitamente chiamato instance(), che restituisce il singleton in istanza. Il metodo di accesso \u00e8 facoltativo, poich\u00e9 \u00e8 anche possibile implementare il pattern dichiarando l'istanza globale come costante pubblica.","text":"<p>Il pattern SINGLETON differisce da FLYWEIGHT in quanto cerca di garantire che esista una singola istanza di una classe, anzich\u00e9 istanze uniche di una classe. Gli oggetti Singleton sono tipicamente con stato e mutabili, mentre gli oggetti flyweight sono immutabili.</p> <p>Un errore tipico nell'implementazione del pattern SINGLETON \u00e8 quello di memorizzare un riferimento a un'istanza della classe in un campo statico chiamato INSTANCE o qualcosa di simile, senza prestare la dovuta attenzione a impedire al codice client di creare autonomamente nuovi oggetti. In questo caso, l'uso del nome Singleton \u00e8 pericolosamente fuorviante, poich\u00e9 gli utenti del codice potrebbero fare affidamento sul fatto che la classe produca una singola istanza quando in realt\u00e0 non \u00e8 cos\u00ec.</p> <p>Il modo classico per impedire l'istanziazione \u00e8 rendere privato il costruttore della classe.</p> <p>Bloch propone un trucco controverso, ovvero l'utilizzo di un tipo enumerato. Questo funziona perch\u00e9 il compilatore impedisce l'istanziazione di tipi enumerati. \u00c8 un po' confusionario, meglio attenersi a un costruttore privato per garantire il vincolo di singola istanza.</p> <p>Il SINGLETON, \u00e8 controverso, perch\u00e9 ci sono pi\u00f9 svantaggio che vantaggi.Un singleton \u00e8 un'istanza globale accessibile da qualsiasi punto del programma, ma questo lo rende facile da abusare, causando dipendenze nascoste e codice difficile da mantenere. Inoltre, essendo responsabile del proprio ciclo di vita, \u00e8 difficile da testare.</p> <p>Un\u2019alternativa migliore \u00e8 spesso l\u2019iniezione di dipendenza, che consente di passare un\u2019unica istanza ai componenti che ne hanno bisogno. Tuttavia, non impedisce la creazione di pi\u00f9 istanze: questo va garantito con attenzione progettuale e buona documentazione. L'iniezione, per\u00f2, aiuta a gestire e propagare in modo controllato la stessa istanza.</p> <p>Un problema particolare nella gestione dello stato \u00e8 dovuto dall'uso di classi annidate in Java. Le classi annidate possono essere suddivise in</p> <ul> <li>classi annidate statiche, una classe definita all\u2019interno di un\u2019altra classe con la parola chiave static. Non ha un riferimento implicito all\u2019istanza della classe esterna e pu\u00f2 essere usata senza creare un oggetto della classe esterna.</li> <li>classi interne, una classe definita all\u2019interno di un\u2019altra classe senza la parola chiave static e questo la lega ad ogni istanza della istanza della classe esterna potendo accedere direttamente alle sue variabili. A loro si suddividono in:</li> <li>classi anonime</li> <li>classi locali.</li> </ul> <p>Le classi locali sono classi che si definiscono all\u2019interno di un metodo di una classe esterna. La loro visibilit\u00e0 \u00e8 limitata proprio a quel metodo, quindi non possono essere usate al di fuori di esso. Un\u2019altra caratteristica importante \u00e8 che queste classi possono accedere ai parametri del metodo che le contiene, purch\u00e9 questi parametri siano dichiarati come final .</p> <p>Un caso particolare di classi locali sono le classi anonime. Queste sono classi locali senza un nome, definite direttamente all\u2019interno di un\u2019espressione. Vengono spesso usate quando si vuole creare rapidamente un\u2019implementazione di un\u2019interfaccia o di una classe astratta, senza dover scrivere una nuova classe con un nome specifico.</p> <p>Alernativa per implementare le function object \u00e8 usare questi costrutti. Spesso si vuole definire un comportamento che dipende da qualche valore locale al momento della sua creazione.</p> <p>\"Ma se il metodo finisce, quella variabile non dovrebbe sparire?\"</p> <p>Esiste un concetto chiamato closure una funzione che pu\u00f2 ricordare e usare le variabili del contesto in cui \u00e8 stata creata, anche dopo che quel contesto \u00e8 scomparso. In Java, quando usiamo classi anonime che fanno riferimento a variabili locali del metodo esterno, il compilatore salva automaticamente quelle variabili come campi interni nell\u2019oggetto che viene creato.</p> <p>COMPOSITION</p> <p>Nella OOP i vari costrutti possono relazionarsi fra loro o tramite composizione o tramite l\u2019ereditariet\u00e0. Queste due tecniche servono a stabilire come le parti di un software interagisco fra loro.</p> <p>La composizione si riferisce alla relazione parte di tra classi in cui il ciclo di vita degli oggetti contenuti \u00e8 strettamente associato al ciclo di vita dell'oggetto contenitore. La composizione \u00e8 un tipo di associazione in cui una classe contiene il riferimento ad un'altra. La composizione \u00e8 diversa dall\u2019aggregazione con cui si intende un insieme di oggetti (liste\u2026). La composizione \u00e8 utile per segmentare un classe che altrimenti sarebbe troppo complessa e ci\u00f2 violerebbe il principio della separazione delle responsabilit\u00e0. Si incorre in un anti pattern detto GOD CLASS, una classe che fa tutto, sa tutto degli altri oggetti ecc, ma questo \u00e8 sbagliato perch\u00e9 saremo constretti ad usare sempre questa classe per ogni cosa e ci\u00f2 incrementa le dipendeze che ci sono nel programma essendo che non la si pu\u00f2 estendere, creare un interfaccia ecc..</p> <p>Viola anche la</p> <p>Law of Demeter (LoD) \u2013 \"Principio del minimo contatto\"</p> <p>Violazione: Una God Class spesso accede direttamente a molte parti del sistema, diventando un nodo centrale che conosce troppo del resto dell'applicazione.</p> <p>Per evitare tutto ci\u00f2 si usa il meccanismo delle delega, cio\u00e8 si delegano ad altri oggetti le azioni che si devono fare, essendo loro specializzati ad operare su quell\u2019oggetto per quella azione. In questo modo si evita che un oggetto assuma troppe responsabilit\u00e0 ed \u00e8 possibile implementare strategie, comportamenti o operazioni intercambiabili.</p> <p>Una propriet\u00e0 della composizione \u00e8 la transitivit\u00e0, cio\u00e8 un oggetto composto da altri oggetti pu\u00f2, a sua volta, essere un componente o un delegato di un altro oggetto padre.</p> <p>Quando si lavora con queste gerarchie non \u00e8 importante sapere si si una la composizione come tale o come delega, perch\u00e9 essendo strutture ricorsive possono essere viste in entrambi i modi: come una relazione strutturale (composizione) oppure come una relazione comportamentale (delegazione). Ci\u00f2 che conta \u00e8 la responsabilit\u00e0 che ciascun oggetto si assume e il grado di accoppiamento che si instaura tra le varie componenti del sistema.</p> <p>COMPOSITE PATTERN</p> <p>Per poter creare una composizione esiste un design pattern, COMPOSITE PATTERN, che permette di trattare gruppi di oggetti come se fossero un oggetto singolo.</p> <p>Un modo per realizzarla \u00e8 quella di creare un interfaccia comune e di farla estendere da tutte le possibili implementazioni e di sfruttare le interfaccia e il polimorfismi, ma un problema \u00e8 che il numero di implementazioni pu\u00f2 esplodere e si dovrebbero avere gi\u00e0 tutte le implementazioni disponibili essendo definite staticamente e non a runtime. Una soluzione migliore \u00e8 stabilita dal COMPOSITE PATTERN.</p> <p>Il pattern presenta tre elementi/ruoli, componente, composito e foglia. L'elemento composito ha due caratteristiche:</p> <ul> <li>Aggrega diversi oggetti di tipo componente. L'utilizzo del tipo di interfaccia componente \u00e8 importante, poich\u00e9 consente composite per comporre qualsiasi altro tipo di elemento, inclusi altri compositi.</li> <li>Implementa l'interfaccia del componente. Questo \u00e8 ci\u00f2 che consente agli oggetti compositi di essere trattati dal resto del codice esattamente allo stesso modo degli elementi foglia.</li> </ul> <p>Il codice client dovrebbe dipendere principalmente dal tipo di componente e non manipolare direttamente i tipi concreti, per poter trattare tutti gli oggetti nello stesso modo.</p> <p></p> <p>L\u2019implementazione del metodo dell\u2019interfaccia permette di iterare, navigare attraverso l\u2019albero delle componenti e questo avviene perch\u00e9 i composite implementano anch\u2019essi l\u2019interfaccia Component e delegano il comportamento ai loro figli.</p> <p>Un problema di implementazione da considerare \u00e8 come aggiungere al composite le istanze del componente che compone, pu\u00f2 essere fatto in due modi principali.</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-avere-un-metodo-nel-composite-che-prenvede-laggiunto-del-figlio-eventualmente-anche-la-modifica-il-getchild-e-la-rimozione-ma-s-deve-includere-il-metodo-add-nel-componente-no-allora","title":"1. Avere un metodo nel composite che prenvede l\u2019aggiunto del figlio (eventualmente anche la modifica, il getChild e la rimozione), ma s deve includere il metodo add nel componente?. No allora","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-li-si-inserisce-nel-composite-tramite-il-costruttore-lista","title":"2. Li si inserisce nel composite tramite il costruttore (lista \u2026).","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#a-usiamo-il-costruttore-di-copia-per-evitare-la-perdita-di-un-riferimento-alla-struttura-della-collezione-privata","title":"a. Usiamo il costruttore di copia per evitare la perdita di un riferimento alla struttura della collezione privata.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#b-o-utilizzare-il-meccanismo-varargs-di-java-per-elencare-singolarmente-ogni-sorgente-di-carta","title":"b. O utilizzare il meccanismo varargs di Java per elencare singolarmente ogni sorgente di carta.","text":"<p>Si preferisce il metodo add perch\u00e9 pu\u00f2 essere necessario modificare lo stato del composite in fase di esecuzione.</p> <p>Questo aggiunge complessit\u00e0 al codice perch\u00e9 \u00e8 necessario gestire un ciclo di vita pi\u00f9 complesso per l'oggetto composite e la differenza tra l'interfaccia del componente (che non ha il metodo add) e quella del composito (che ce l'ha).</p> <p>Se la modifica del composito in fase di esecuzione non \u00e8 necessaria, \u00e8 probabilmente meglio inizializzarlo una volta e lasciarlo cos\u00ec com'\u00e8.</p> <p>Alcuni aspetti pratici relativi all'utilizzo del pattern sono indipendenti dalla struttura del pattern stesso, la soluzione dipender\u00e0 dal problema di progettazione specifico in questione. (sequence diagram).</p> <p>DECORATOR PATTER</p> <p>In certe situazioni \u00e8 necessario avere oggetti che svolto una stessa azione, ma in modo diverso o che hanno particolari caratteristiche. Quindi possiamo creare una classe specializzato per poter fare questo. Questo lo si pu\u00f2 fare tramite ereditariet\u00e0 estendo la classe, ma non darebbe flessibilit\u00e0 al codice perch\u00e9 crea un legame statico fra le classi, ed \u00e8 difficile poi cambiare comportamento a runtime. (Strategy)</p> <p>Una soluzione pu\u00f2 essere quella di avere una classe multimodale, che sulla base del \u201cenum\u201d assegnato svolge l\u2019azione in un determinato modo Anche questa soluzione non ci piace perch\u00e9 potremmo non prevedere tutti i comportamenti ed andremmo ad accrescere lo spazio degli stati. Inoltre cadremmo un\u2019altra volta nella GOD CLASS, Ah shit, here we go again, e anche nell\u2019antipatten SWITCH STATEMENT.</p> <p>Allora ci soccorre, per fortuna, il DECORATOR PATTERN che aggiungere dinamicamente funzionalit\u00e0 o comportamenti a un oggetto senza modificarne la struttura o creare tante sottoclassi.</p> <p></p> <p>Questo si basa sul COMPOSITE, tranne che per il fatte che il composite \u00e8 un decorator base. Ogni decoratore delegata l'esecuzione al componente interno e pu\u00f2 combinarsi con altri decoratori, rendendo semplice la composizione di funzionalit\u00e0.</p> <ul> <li>Le decorazioni devono essere indipendenti e additive, non devono rimuovere comportamenti per rispettare i principi della progettazione orientata agli oggetti.</li> <li>In Java, \u00e8 buona pratica rendere il riferimento all\u2019oggetto decorato final e inizializzarlo nel costruttore, poich\u00e9 si assume che non cambi durante la vita del decoratore.</li> <li>Un oggetto decorato non \u00e8 uguale al componente originale: ha una nuova identit\u00e0 dovuta alla decorazione.</li> </ul> <p>COPIA POLIMORFICA</p> <p>Un problema di lavorare con grafi di oggetti, oltre all\u2019identit\u00e0, \u00e8 la copia. Potremmo usare il costruttore della classe, ma questo \u00e8 statico e non va bene avendo una struttura che sfrutta il polimorfismo tramite le interfaccie, quindi non possiamo sapere che tipo abbiamo a runtime. E mo? La copia polimorfica risolve tutti nostri guai, perch\u00e9 permette di fare copie senza saper il tipo concreto dell\u2019oggetto. Questo concetto \u00e8 detto anche clonazione.Implementare il medo di copy() in strutture ricorsive \u00e8 complesso.</p> <p>Java d\u00e0 la possibilit\u00e0 di utilizzare il tipo di ritorno covariante cio\u00e8 permette a un metodo sovrascritto in una sottoclasse di restituire un tipo pi\u00f9 specifico rispetto a quello dichiarato nel metodo della superclasse o dell\u2019interfaccia. Si tratta di una funzionalit\u00e0 molto utile, perch\u00e9 consente di evitare il ricorso a downcast espliciti.</p> <p></p> <p>Questo meccanismo si rivela ancora pi\u00f9 importante nel contesto di strutture ricorsive, come ad esempio collezioni o oggetti che contengono al loro interno riferimenti ad altri oggetti dello stesso tipo. In questi casi, \u00e8 fondamentale che la copia effettuata sia profonda (deep copy), cio\u00e8 che non si limiti a copiare i riferimenti, ma replichi realmente anche le componenti interne.</p> <p>PROTOTYPE PATTERN</p> <p>COMMAND PATTERN</p> <p>In certe situazioni vogliamo svolgere delle azioni che possono essere svolte in modi diversi, o invocate in modo diverso. Potremmo usar l\u2019ereditariet\u00e0, ma per i classici motivi non ci va bene. Allora una soluzione, basata sul principio di separazione delle responsabilit\u00e0 \u00e8 di trasformare l\u2019azione, o meglio il metodo che in generale \u00e8 una propriet\u00e0 di una classe in un oggetto, in modo di applicargli delle propriet\u00e0 diverse. Per farlo esiste il COMMAND PATTERN che sfrutta sempre il polimorfismo tramite le interfacce, che in questo caso contengono il metodo per svolgere l\u2019azione.</p> <p>Il COMMAND separa l\u2019oggetto che invoca l\u2019operazione (Invoker) da quello che la esegue (Receiver), permettendo di trattare le richieste come oggetti riutilizzabili, componibili e serializzabili.</p> <p></p> <p>LAW OF DEMETER</p> <p>Nella progettazione di tutto ci\u00f2, possiamo andare a creare una lunga catena di delegazione fra gli oggetti. Questo ci va bene, ma fino ad un certo punto perch\u00e9 secondo la legge di Demeter si devono limitare le dipendenze tra le classi per rendere il codice pi\u00f9 modulare, facile da mantenere e meno fragile di fronte ai cambiamenti. Ci\u00f2 vuol direche un oggetto dovrebbe interagire solo con pochi amici stretti . Cadremmo nll\u2019antipattern del MESSAGE CHAIN che espone dettagli interni degli oggetti che dovrebbero invece rimanere nascosti, violando l\u2019information hiding.</p> <p></p> <p>Questa \"legge\" stabilisce che il codice di un metodo dovrebbe accedere solo a:</p> <ul> <li>le variabili di istanza del suo parametro implicito;</li> <li>gli argomenti passati al metodo;</li> <li>qualsiasi nuovo oggetto creato all'interno del metodo;</li> <li>oggetti disponibili globalmente.</li> </ul> <p>Per rispettare questa linea guida, diventa necessario fornire servizi aggiuntivi nelle classi che occupano una posizione intermedia in una catena di aggregazione/delega, in modo che i client non debbano manipolare gli oggetti interni incapsulati da questi oggetti.</p> <p>INVERSION OF DEPENDACY</p> <p>Il principio di inversione delle dipendenze afferma che i moduli di alto livello non dovrebbero dipendere da moduli di basso livello. Invece, entrambi dovrebbero dipendere dalle astrazioni, e le astrazioni non dovrebbero dipendere dai dettagli; I dettagli dovrebbero dipendere dalle astrazioni.</p> <p>Questo principio ha lo scopo di ridurre l\u2019accoppiamento tra moduli e aumentare la flessibilit\u00e0 del sistema, facilitando l\u2019estensione e la manutenzione.</p> <p>Un antipattern in cui si cade \u00e8 PAIRWISE DEPENDECIES cio\u00e8 si creano relazioni dirette fra due componenti o moduli in un sistema. Ogni dipendenza rappresenta un legame che pu\u00f2 introdurre accoppiamento e potenziali problemi di manutenzione.</p> <p>Quando molte dipendenze si accumulano fra moduli, si crea una rete complessa che rende il sistema rigido e difficile da modificare. Si decve cercare di ridurre il numero e la forza di queste dipendenze.</p> <p>Introducendo un livello di astrazione, invece di dipendere direttamente da una classe concreta (dipendenza forte), si dipende da un\u2019interfaccia, riducendo cos\u00ec il coupling. In questo modo:</p> <ul> <li>Le modifiche in una classe concreta hanno meno impatto sugli altri moduli.</li> <li>Il sistema diventa pi\u00f9 modulare, flessibile e testabile.</li> </ul> <p>Un pattern per risolvere questo \u00e8 il [[MVC]] MODEL-VIEW-CONTROLL un pattern architetturale che separa le responsabilit\u00e0 in tre componenti :</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-model-rappresenta-la-parte-che-gestisce-i-dati-la-logica-di-business-e-lo-stato-dellapplicazione-il-modello-non-si-preoccupa-di-come-i-dati-vengono-mostrati-allutente-ma-solo-di-gestirli-aggiornarli-e-fornirli","title":"1. Model: Rappresenta la parte che gestisce i dati, la logica di business e lo stato dell\u2019applicazione. Il modello non si preoccupa di come i dati vengono mostrati all\u2019utente, ma solo di gestirli, aggiornarli e fornirli.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-view-e-responsabile-della-presentazione-delle-informazioni-allutente-la-vista-prende-i-dati-dal-modello-e-li-mostra-in-modo-appropriato-ad-esempio-sotto-forma-di-pagine-web-finestre-grafiche-o-altro-non-contiene-logica-di-business-solo-logica-di-visualizzazione","title":"2. View: \u00c8 responsabile della presentazione delle informazioni all\u2019utente. La vista prende i dati dal modello e li mostra in modo appropriato, ad esempio sotto forma di pagine web, finestre grafiche, o altro. Non contiene logica di business, solo logica di visualizzazione.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#3-controller-fa-da-intermediario-tra-lutente-e-il-sistema-riceve-gli-input-dellutente-clic-comandi-dati-inseriti-li-interpreta-e-decide-come-modificare-il-modello-o-quale-vista-mostrare-in-pratica-coordina-il-flusso-dellapplicazione","title":"3. Controller: Fa da intermediario tra l\u2019utente e il sistema. Riceve gli input dell\u2019utente (clic, comandi, dati inseriti), li interpreta e decide come modificare il modello o quale vista mostrare. In pratica coordina il flusso dell\u2019applicazione.","text":"<p>Questo \u00e8 il concetto generale, ma ci sono molti modi di implementarlo, un esempio \u00e8</p> <p>OBSERVER PATTERN</p> <p>Il pattern OBSERVER consiste nell'archiviare i dati in un oggetto specializzato e consentire ad altri oggetti di osservarli. Questo oggetto, detto subject (MODEL), mantiene una lista di altri oggetti, detti observers, che vogliono essere informati quando qualcosa cambia nello stato del soggetto. Quindi deve avere i metodi per la registrazione e deregistrazione degli observer.</p> <p>Il soggetto notifica automaticamente tutti gli osservatori ogni volta che il suo stato cambia, senza che gli osservatori debbano controllare continuamente (polling).</p> <p></p> <p>DATA FLOW</p> <p>Come fanno gli osservatori a sapere che c'\u00e8 un cambiamento nello stato del modello di cui hanno bisogno? Sono spioni\u2026</p> <p>Ogni volta che si verifica un cambiamento nello stato del modello il modello lo comunica agli osservatori scorrendo l'elenco degli osservatori e chiamando il metodo notify(). Questo metodo \u00e8 una callback per il DIP perch\u00e9 per ottenere informazioni dal modello, gli osservatori non chiamano un metodo sul modello, ma aspettano che il modello li richiami. Poi ovviamente l\u2019observer ha bisogno di un metodo per poter aggiornare lo stato delle sue variabili.</p> <p>Per garantire che il modello notifichi gli osservatori ogni volta che si verifica un cambiamento di stato, e che ci sia consistenza fra i dati, sono possibili due strategie:</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-una-chiamata-al-metodo-di-notifica-deve-essere-inserita-in-ogni-metodo-che-modifica-lo-stato-in-questo-caso-il-metodo-puo-essere-dichiarato-privato","title":"1. una chiamata al metodo di notifica deve essere inserita in ogni metodo che modifica lo stato; in questo caso il metodo pu\u00f2 essere dichiarato privato;","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-e-necessario-fornire-una-documentazione-chiara-che-indichi-agli-utenti-della-classe-modello-di-chiamare-il-metodo-di-notifica-ogni-volta-che-il-modello-deve-informare-gli-osservatori-in-questo-caso-i-metodi-di-notifica-devono-essere-non-privati","title":"2. \u00c8 necessario fornire una documentazione chiara che indichi agli utenti della classe modello di chiamare il metodo di notifica ogni volta che il modello deve informare gli osservatori. In questo caso, i metodi di notifica devono essere non privati.","text":"<p>CONTROLL FLOW</p> <p>Come accedono gli osservatori alle informazioni che devono conoscere dal modello?</p> <p>Si possono rendere disponibili le informazioni di interesse tramite uno o pi\u00f9 parametri del callback. Questa strategia \u00e8 anche nota come strategia push data flow, poich\u00e9 il modello invia esplicitamente i dati di una struttura agli osservatori. Applicando questa strategia, potremmo definire il metodo di callback in modo che includa un parametro che rappresenti l\u2019informazione memorizzata pi\u00f9 di recente nel modello.</p> <p>Questa strategia parte dal presupposto che sappiamo in anticipo quale tipo di dati del modello richiederanno gli osservatori.</p> <p>Tuttavia, questo non \u00e8 il caso generale. Una strategia pi\u00f9 flessibile consiste nel consentire agli osservatori di estrarre i dati desiderati dal modello utilizzando i metodi di query definiti nel modello. Questo approccio \u00e8 noto come strategia pull data-flow. Per implementare la strategia di flusso di dati pull, gli osservatori devono avere un riferimento al modello, ma questo riferimento non deve essere necessariamente fornito come argomento al metodo di callback. Un'altra opzione \u00e8 inizializzare gli oggetti osservatori con un riferimento al modello (memorizzato come campo) e fare riferimento a tale campo se necessario.</p> <p>Pu\u00f2 sembrare che questa strategia introduca una dipendenza circolare tra un modello e i suoi osservatori, dato che entrambi dipendono l'uno dall'altro, ma non \u00e8 cos\u00ec perch\u00e9 il modello non conosce il tipo concreto dei suoi osservatori. Attraverso la segregazione delle interfacce, l'unica porzione di comportamento che il modello richiede dagli osservatori viene specificata tramite il loro metodo di callback. Anche se per\u00f2, aumenta l'accoppiamento tra osservatori e modello.</p> <p>ADAPTER PATTERN</p> <p>L'ADAPTER PATTER \u00e8 un modello di progettazione strutturale che consente la collaborazione di oggetti con interfacce incompatibili. Si tratta di un oggetto speciale che converte l'interfaccia di un oggetto in modo che un altro oggetto possa comprenderlo.</p> <p>Un adattatore esegue il wrapping di uno degli oggetti per nascondere la complessit\u00e0 della conversione che avviene dietro le quinte. L'oggetto avvolto non \u00e8 nemmeno a conoscenza dell'adattatore.</p> <p>Gli adattatori non solo possono convertire i dati in vari formati, ma possono anche aiutare gli oggetti con interfacce diverse a collaborare. Ecco come funziona:</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-ladattatore-ottiene-uninterfaccia-compatibile-con-uno-degli-oggetti-esistenti","title":"1. L'adattatore ottiene un'interfaccia compatibile con uno degli oggetti esistenti.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-utilizzando-questa-interfaccia-loggetto-esistente-puo-chiamare-in-modo-sicuro-i-metodi-delladapter","title":"2. Utilizzando questa interfaccia, l'oggetto esistente pu\u00f2 chiamare in modo sicuro i metodi dell'adapter.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#3-alla-ricezione-di-una-chiamata-ladapter-passa-la-richiesta-al-secondo-oggetto-ma-nel-formato-e-nellordine-previsti-dal-secondo-oggetto","title":"3. Alla ricezione di una chiamata, l'adapter passa la richiesta al secondo oggetto, ma nel formato e nell'ordine previsti dal secondo oggetto.","text":"<p>A volte \u00e8 anche possibile creare un adattatore bidirezionale in grado di convertire le chiamate in entrambe le direzioni.</p> <p></p>"},{"location":"50_Project_Journal/2026_Learning_Log/","title":"2026 Learning Log","text":"<p>Stato: #seed</p>"},{"location":"50_Project_Journal/2026_Learning_Log/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"99_Meta/Templates/Technical_Note_Template/","title":"Technical Note Template","text":"<p>Stato: #seed</p>"},{"location":"99_Meta/Templates/Technical_Note_Template/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"}]}