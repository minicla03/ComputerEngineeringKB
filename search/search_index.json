{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83c\udf10 Engineering KB: Master MOC","text":"<p>Stato: #active \"L'organizzazione della conoscenza \u00e8 l'inizio della saggezza ingegneristica.\"</p> <p>Benvenuto nel punto di ingresso centrale del tuo secondo cervello tecnico. Questa mappa collega tutte le macro-aree della tua conoscenza.</p>","tags":["hub","directory"]},{"location":"#aree-principali","title":"\ud83c\udfd7\ufe0f Aree Principali","text":"","tags":["hub","directory"]},{"location":"#1-theory_moc","title":"1. Theory_MOC","text":"<p>Fondamenta scientifiche e teoriche.</p>","tags":["hub","directory"]},{"location":"#2-languages_moc","title":"2. Languages_MOC","text":"<p>Linguaggi di programmazione e sintassi core.</p>","tags":["hub","directory"]},{"location":"#3-frameworks_tools_moc","title":"3. Frameworks_Tools_MOC","text":"<p>Ecosistemi di sviluppo e strumenti specifici.</p>","tags":["hub","directory"]},{"location":"#4-software_engineering_moc","title":"4. Software_Engineering_MOC","text":"<p>Architettura del software e qualit\u00e0 del codice.</p>","tags":["hub","directory"]},{"location":"#5-artificial_intelligence_moc","title":"5. Artificial_Intelligence_MOC","text":"<p>Machine Learning, Deep Learning e AI .</p>","tags":["hub","directory"]},{"location":"#operativita-quotidiana","title":"\ud83d\udcdd Operativit\u00e0 Quotidiana","text":"<ul> <li>[[00_Inbox]]: Note rapide e bozze da elaborare.</li> <li>[[98_Project_Journal]]: Log delle decisioni tecniche e post-mortem dei progetti.</li> </ul>","tags":["hub","directory"]},{"location":"#sistema-meta","title":"\ud83d\udee0\ufe0f Sistema (Meta)","text":"<ul> <li>[[99_Meta_MOC]]: Gestione di template e configurazioni della KB.</li> </ul>","tags":["hub","directory"]},{"location":"00_Inbox/","title":"README","text":"<p>Stato: #seed</p>"},{"location":"00_Inbox/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"00_Inbox/draft_BLE/BLE/","title":"BLE","text":"<p>Il Bluetooth SIG ha introdotto il Bluetooth Low Energy con la versione 4.0 delle specifiche Bluetooth Core. Il Bluetooth Low Energy (BLE) \u00e8 stato progettato per fornire una connettivit\u00e0 wireless a basso consumo energetico per dispositivi che richiedono una lunga durata della batteria, come sensori, dispositivi indossabili e dispositivi IoT. BLE consente ai dispositivi di comunicare tra loro utilizzando meno energia rispetto al Bluetooth classico, rendendolo ideale per applicazioni che richiedono una connessione continua o frequente.</p> <p>La specifica Bluetooth copre sia il Bluetooth classico (il noto standard wireless che \u00e8 ormai diffuso in molti dispositivi di consumo da diversi anni) sia il Bluetooth Low Energy (il nuovo standard wireless altamente ottimizzato introdotto nella versione 4.0). Questi due standard di comunicazione wireless non sono direttamente compatibili e i dispositivi Bluetooth qualificati su qualsiasi versione di specifica precedente alla 4.0 non possono comunicare in alcun modo con un dispositivo BLE. Il protocollo on-air, i livelli di protocollo superiori e le applicazioni sono diversi e incompatibili tra le due tecnologie.</p> <p>La specifica Bluetooth (versione 4.0 e successive) definisce due tecnologie wireless:</p> <ul> <li>BR/EDR (Bluetooth classico): Lo standard wireless che si \u00e8 evoluto con la specifica Bluetooth a partire dalla versione 1.0.</li> <li>BLE (Bluetooth Low Energy): Lo standard wireless a basso consumo introdotto con la versione 4.0 della specifica.</li> </ul> <p>E questi sono i due tipi di dispositivi che possono essere utilizzati con queste configurazioni:</p> <ul> <li>Dispositivo monomodale (BLE, Bluetooth Smart): Un dispositivo che implementa BLE, in grado di comunicare con dispositivi monomodali e bimodali, ma non con dispositivi che supportano solo BR/EDR.</li> <li>Dispositivo bimodale (BR/EDR/LE, Bluetooth Smart Ready): Un dispositivo che implementa sia BR/EDR che BLE, in grado di comunicare con qualsiasi dispositivo Bluetooth</li> </ul> <p></p> <p>i tre elementi costitutivi principali di ogni dispositivo Bluetooth:</p> <ol> <li>Applicazione: L'applicazione utente che si interfaccia con lo stack di protocolli Bluetooth per coprire un particolare caso d'uso.</li> <li>Host: I livelli superiori dello stack di protocolli Bluetooth.</li> <li>Controller: I livelli inferiori dello stack di protocolli Bluetooth, inclusa la radio.</li> </ol> <p>Inoltre, la specifica fornisce un protocollo di comunicazione standard tra l'host e il controller, l'Host Controller Interface (HCI), per consentire l'interoperabilit\u00e0 tra host e controller prodotti da aziende diverse. Questi livelli possono essere implementati in un singolo circuito integrato (IC) o chip, oppure possono essere suddivisi in diversi IC collegati tramite un livello di comunicazione (UART, USB, SPI o altro). Queste sono le tre configurazioni pi\u00f9 comuni presenti nei prodotti attualmente disponibili in commercio:</p> <ol> <li>SoC (system on chip) Un singolo IC esegue l'applicazione, l'host e il controller.</li> <li>Doppio circuito integrato su HCI Un circuito integrato esegue l'applicazione e l'host e comunica tramite HCI con un secondo circuito integrato che gestisce il controller. Il vantaggio di questo approccio \u00e8 che, poich\u00e9 l'HCI \u00e8 definito dalle specifiche Bluetooth, qualsiasi host pu\u00f2 essere combinato con qualsiasi controller, indipendentemente dal produttore.</li> <li>Doppio circuito integrato con dispositivo di connettivit\u00e0 Un circuito integrato esegue l'applicazione e comunica tramite un protocollo proprietario con un secondo circuito integrato che gestisce sia l'host che il controller. Poich\u00e9 le specifiche non includono tale protocollo, l'applicazione deve essere adattata al protocollo specifico del fornitore scelto.</li> </ol> <p></p>"},{"location":"00_Inbox/draft_BLE/BLE/#limiti-di-ble","title":"Limiti di BLE","text":"<ul> <li> <p>Data Throughput La velocit\u00e0 di modulazione della radio Bluetooth Low Energy \u00e8 impostata dalle specifiche a 1 Mbps costante. Questo stabilisce il limite superiore teorico per la velocit\u00e0 di trasmissione che BLE pu\u00f2 fornire, ma in termini reali, questo limite viene in genere abbassato in modo significativo da una variet\u00e0 di fattori, inclusi ma non limitati al traffico bidirezionale, sovraccarico del protocollo, limitazioni della CPU e della radio e restrizioni software artificiali</p> </li> <li> <p>Range il Bluetooth Low Energy si concentra sulle comunicazioni a corto raggio.   La potenza di trasmissione (tipicamente misurata in dBm) \u00e8 solitamente configurabile su un certo intervallo (solitamente tra -30 e 0 dBm), ma maggiore \u00e8 la potenza di trasmissione (migliore portata), maggiore \u00e8 il carico sulla batteria, riducendone la durata utile.   \u00c8 possibile creare e configurare un dispositivo BLE in grado di trasmettere dati in modo affidabile a 30 metri o pi\u00f9 di distanza in linea d'aria, ma una portata operativa tipica \u00e8 probabilmente pi\u00f9 vicina ai 2-5 metri, con uno sforzo consapevole per ridurre la portata e risparmiare la durata della batteria senza che la distanza di trasmissione diventi un fastidio per l'utente finale.</p> </li> </ul>"},{"location":"00_Inbox/draft_BLE/BLE/#topologia-di-rete","title":"Topologia di rete","text":"<p>Un dispositivo Bluetooth Low Energy pu\u00f2 comunicare con il mondo esterno in due modi: broadcasting o connessioni. Ogni meccanismo presenta vantaggi e limitazioni, ed entrambi sono soggetti alle linee guida stabilite dal Generic Access Profile (GAP)</p>"},{"location":"00_Inbox/draft_BLE/BLE/#broadcasting-e-osservazione","title":"Broadcasting e osservazione","text":"<p>Utilizzando il broadcasting senza connessione, \u00e8 possibile inviare dati a qualsiasi dispositivo di scansione o ricevitore nel raggio di ascolto inviariando dati in un'unica direzione a chiunque o qualsiasi cosa sia in grado di captare i dati trasmessi.</p> <p></p> <p>Il broadcasting definisce due ruoli distinti:</p> <ol> <li>Broadcaster Invia periodicamente nonconnectable advertising package a chiunque sia disposto a riceverli.</li> <li>Osservatore Esegue ripetutamente la scansione delle frequenze preimpostate per ricevere eventuali nonconnectable advertising package attualmente trasmessi.</li> </ol> <p>L'advertising standar package contiene un payload di 31 byte utilizzato per includere dati che descrivono il broadcaster e le sue capacit\u00e0, ma pu\u00f2 anche includere qualsiasi informazione personalizzata che si desidera trasmettere ad altri dispositivi. Se questo payload standard di 31 byte non \u00e8 sufficientemente grande da contenere tutti i dati richiesti, BLE supporta anche un payload pubblicitario secondario opzionale (chiamato Scan Response), che consente ai dispositivi che rilevano un dispositivo broadcaster di richiedere un secondo frame pubblicitario con un altro payload di 31 byte, per un massimo di 62 byte totali.</p> <p>Una delle principali limitazioni del broadcasting, rispetto a una connessione tradizionale, \u00e8 l'assenza di misure di sicurezza o privacy (qualsiasi dispositivo osservatore \u00e8 in grado di ricevere i dati trasmessi), quindi potrebbe non essere adatto per i dati sensibili.</p>"},{"location":"00_Inbox/draft_BLE/BLE/#connessioni","title":"Connessioni","text":"<p>Se \u00e8 necessario trasmettere dati in entrambe le direzioni, o se si dispone di pi\u00f9 dati di quanti i due advertising package possano gestire, \u00e8 necessario utilizzare una connessione. Una connessione \u00e8 uno scambio di dati permanente e periodico di pacchetti tra due dispositivi. \u00c8 quindi intrinsecamente privata (i dati vengono inviati e ricevuti solo dai due peer coinvolti nella connessione e da nessun altro dispositivo, a meno che non stia effettuando uno sniffing indiscriminato).</p> <p>Le connessioni implicano due ruoli distinti:</p> <ol> <li>Centrale (master) Esegue ripetutamente la scansione delle frequenze preimpostate alla ricerca di pacchetti pubblicitari collegabili e, se necessario, avvia una connessione. Una volta stabilita la connessione, la centrale gestisce la temporizzazione e avvia gli scambi di dati periodici.</li> <li>Periferica (slave) Un dispositivo che invia periodicamente pacchetti pubblicitari collegabili e accetta connessioni in entrata. Una volta stabilita una connessione attiva, la periferica segue i tempi della centrale e scambia dati regolarmente con essa.</li> </ol> <p>Per avviare una connessione, un dispositivo centrale preleva i pacchetti di advertising collegabili da una periferica e invia quindi una richiesta alla periferica per stabilire una connessione esclusiva tra i due dispositivi. Una volta stabilita la connessione, la periferica interrompe l'advertising e i due dispositivi possono iniziare a scambiare dati in entrambe le direzioni. La connessione rimane attiva finch\u00e9 uno dei due dispositivi non decide di disconnettersi, a quel punto la periferica riprende l'advertising e la centrale torna alla scansione alla ricerca di altri dispositivi a cui connettersi.</p> <p>A partire dalla versione 4.1 della specifica, tutte le restrizioni sulle combinazioni di ruoli sono state rimosse e sono possibili le seguenti funzioni:</p> <ul> <li>Un dispositivo pu\u00f2 fungere contemporaneamente da centrale e periferica.</li> <li>Una centrale pu\u00f2 essere collegata a pi\u00f9 periferiche.</li> <li>Una periferica pu\u00f2 essere collegata a pi\u00f9 centrali.</li> </ul> <p>organizzare i dati con un controllo molto pi\u00f9 dettagliato su ciascun campo o propriet\u00e0 attraverso l'uso di livelli di protocollo aggiuntivi e, pi\u00f9 specificamente, del Generic Attribute Profile (GATT). I dati sono organizzati in unit\u00e0 chiamate servizi e caratteristiche. I servizi possono contenere pi\u00f9 caratteristiche, ciascuna con i propri diritti di accesso e metadati descrittivi. Ulteriori vantaggi includono una maggiore produttivit\u00e0, la possibilit\u00e0 di stabilire un collegamento crittografato sicuro e la negoziazione dei parametri di connessione per adattarli al modello di dati.</p> <p>Le connessioni consentono un modello di dati molto pi\u00f9 ricco e stratificato. Hanno anche il potenziale di consumare molta meno energia rispetto alla modalit\u00e0 broadcast perch\u00e9 possono estendere ulteriormente il ritardo tra gli eventi di connessione o inviare grandi quantit\u00e0 di dati solo quando sono disponibili nuovi valori, anzich\u00e9 dover annunciare continuamente l'intero payload a una velocit\u00e0 specifica senza sapere chi sta ascoltando o con quale frequenza. Non solo, ma il fatto che entrambi i peer sappiano quando si verificheranno gli eventi di connessione in futuro consente di spegnere la radio pi\u00f9 a lungo, risparmiando potenzialmente la batteria rispetto alla trasmissione. Infine, queste topologie possono essere combinate liberamente in una rete BLE pi\u00f9 ampia. Un dispositivo compatibile con BR/EDR/LE pu\u00f2 collegare connessioni BLE e BR/EDR, e il numero di combinazioni e partecipanti sulla rete \u00e8 limitato solo dalle limitazioni delle radio e degli stack di protocollo di ciascun dispositivo che vi partecipa.</p> <p></p>"},{"location":"00_Inbox/draft_BLE/BLE/#protocolli-e-profili","title":"Protocolli e profili","text":"<p>Il Bluetooth Low Energy \u00e8 progettato per essere un protocollo di comunicazione wireless generico, ma le specifiche Bluetooth forniscono anche una serie di profili e protocolli standardizzati che definiscono casi d'uso specifici e modelli di dati per applicazioni comuni. Questi profili e protocolli standardizzati consentono l'interoperabilit\u00e0 tra dispositivi di diversi produttori e semplificano lo sviluppo di applicazioni Bluetooth Low Energy.</p> <p>Protocolli Elementi costitutivi utilizzati da tutti i dispositivi conformi alle specifiche Bluetooth, i protocolli sono i livelli che implementano i diversi formati di pacchetto, routing, multiplexing, codifica e decodifica che consentono l'invio efficace dei dati tra peer. Profili funzionalit\u00e0 che coprono sia le modalit\u00e0 operative di base richieste da tutti i dispositivi (Profilo di accesso generico, Profilo di attributi generico) sia casi d'uso specifici (Profilo di prossimit\u00e0, Profilo del glucosio), i profili definiscono essenzialmente come i protocolli dovrebbero essere utilizzati per raggiungere un obiettivo particolare, generico o specifico.</p>"},{"location":"00_Inbox/draft_BLE/BLE/#protocollo-base","title":"Protocollo Base","text":"<p>Single mode BLE: Controller, host e applicazione.</p> <ol> <li>Applicazione    L'applicazione, come in tutti gli altri tipi di sistemi, \u00e8 il livello pi\u00f9 elevato ed \u00e8 responsabile della logica, dell'interfaccia utente e della gestione dei dati di tutto ci\u00f2 che riguarda il caso d'uso effettivo implementato dall'applicazione. L'architettura di un'applicazione dipende fortemente da ogni specifica implementazione.</li> <li>Host    Include i seguenti livelli:    \u2022 Generic Access Profile (GAP) \u2022 Generic Attribute Profile (GATT) \u2022 Logical Link Control and Adaptation Protocol (L2CAP) \u2022 Attribute Protocol (ATT)    \u2022 Security Manager (SM) \u2022 Host Controller Interface (HCI), lato host</li> <li>Controller    Include i seguenti livelli    Interfaccia Host Controller (HCI), lato controller \u2022 Livello di collegamento (LL)    \u2022 Livello fisico (PHY)</li> </ol>"},{"location":"00_Inbox/draft_BLE/BLE/#physical-layer-phy","title":"Physical Layer (PHY)","text":"<p>Lo strato fisico (PHY) \u00e8 la parte che contiene i circuiti di comunicazione analogici, in grado di modulare e demodulare i segnali analogici e trasformarli in simboli digitali. La radio utilizza la banda ISM (Industrial, Scientific and Medical) a 2,4 GHz per comunicare e la divide in 40 canali da 2,4000 GHz a 2,4835 GHz. 37 di questi canali sono utilizzati per i dati di connessione e gli ultimi tre canali (37, 38 e 39) sono utilizzati come canali advertising per stabilire connessioni e inviare dati di trasmissione.</p> <p>Lo standard utilizza una tecnica chiamata frequency hopping spread spectrum, in cui la radio salta tra i canali a ogni evento di connessione utilizzando la seguente formula:</p> <p>canale = (canale_corrente + salto) mod 37</p> <p>Il valore del salto viene comunicato al momento dello stabilimento della connessione ed \u00e8 quindi diverso per ogni nuova connessione stabilita. Questa tecnica riduce al minimo l'effetto di qualsiasi interferenza radio potenzialmente presente nella banda dei 2,4 GHz su qualsiasi singolo canale, soprattutto perch\u00e9 il WiFi e il Bluetooth classico sono prevalenti in questa banda e i dispositivi potrebbero subire forti interferenze in prossimit\u00e0 di dispositivi con un'elevata potenza di trasmissione. La modulazione scelta per codificare il flusso di bit via etere \u00e8 la Gaussian Frequency Shift Keying (GFSK), la stessa modulazione utilizzata dal Bluetooth classico e da molti altri protocolli wireless proprietari a basso consumo. La velocit\u00e0 di modulazione per Bluetooth Low Energy \u00e8 fissata a 1 Mbit/s, che rappresenta quindi il limite fisico massimo di throughput per la tecnologia.</p> <p>Nota: A partire dalle specifiche del Bluetooth 5.0, il Physical Layer \u00e8 stato espanso introducendo il LE 2M PHY (che raddoppia la velocit\u00e0 di modulazione a 2 Mbit/s per un throughput maggiore) e il LE Coded PHY (che riduce la velocit\u00e0 a 500 o 125 kbps inserendo codici di correzione d'errore per aumentare drasticamente il range di trasmissione senza aumentare la potenza radio).</p>"},{"location":"00_Inbox/draft_BLE/BLE/#link-layer-ll","title":"Link Layer (LL)","text":"<p>Il Link Layer \u00e8 la parte che si interfaccia direttamente con il PHY e solitamente \u00e8 implementato come una combinazione di hardware e software personalizzati. \u00c8 anche l'unico livello con vincoli rigidi in tempo reale dell'intero stack protocollare, poich\u00e9 \u00e8 responsabile del rispetto di tutti i requisiti di temporizzazione definiti dalle specifiche. \u00e8 solitamente mantenuto isolato dai livelli superiori dello stack protocollare tramite un'interfaccia standard che nasconde la complessit\u00e0 del Link Layer e consente a qualsiasi implementazione di essere utilizzata con qualsiasi host, a condizione che entrambi supportino l'interfaccia standard (HCI).</p> <p>Implementate nell'hardware dai fornitori di silicio per evitare di sovraccaricare l'unit\u00e0 di elaborazione centrale che gestisce tutti i livelli software dello stack. Questa funzionalit\u00e0 solitamente include: \u2022 Framing di preambolo, indirizzo di accesso e protocollo aereo \u2022 Generazione e verifica CRC \u2022 Whitening dei dati \u2022 Generazione di numeri casuali \u2022 Crittografia AES</p> <p>La met\u00e0 software del Link Layer gestisce lo stato del collegamento radio, ovvero il modo in cui il dispositivo si connette ad altri dispositivi. Un dispositivo BLE pu\u00f2 essere master, slave o entrambi, a seconda del caso d'uso e dei requisiti.</p> <p>Un master pu\u00f2 connettersi a pi\u00f9 slave e uno slave pu\u00f2 essere connesso a pi\u00f9 master.</p> <p>Il Bluetooth Low Energy presenta un'asimmetria intrinseca nei suoi livelli inferiori tra dispositivi master e slave, poich\u00e9 richiede pi\u00f9 risorse per fungere da master.</p> <p>Il Link Layer definisce i seguenti ruoli:</p> <ol> <li>Advertiser Un dispositivo che invia gli advertising package per stabilire connessioni o inviare dati di trasmissione.</li> <li> <p>Scanner Un dispositivo che esegue la scansione degli advertising package.</p> </li> <li> <p>Master Un dispositivo che avvia una connessione e la gestisce in seguito.</p> </li> <li>Slave Un dispositivo che accetta una richiesta di connessione e segue le tempistiche del master.</li> </ol>"},{"location":"00_Inbox/draft_BLE/BLE/#fase-di-discovery","title":"Fase di Discovery","text":"<p>BLE ha un solo formato di pacchetto e due tipi di pacchetti (pacchetti pubblicitari e pacchetti dati), il che semplifica l'implementazione dello stack di protocollo. Gli advertising package servono a due scopi:</p> <ol> <li>trasmettere dati per applicazioni che non necessitano del sovraccarico di una connessione completa</li> <li>Individuare gli slave e connettersi a essi</li> </ol> <p>Ogni pacchetto pubblicitario pu\u00f2 trasportare fino a 31 byte di payload di dati pubblicitari, insieme alle informazioni di base dell'intestazione (incluso l'indirizzo del dispositivo Bluetooth). Tali pacchetti vengono semplicemente trasmessi in modalit\u00e0 cieca dall'advertiser, senza la previa conoscenza della presenza di alcun dispositivo di scansione. Vengono inviati a una velocit\u00e0 fissa definita dall'intervallo pubblicitario, che varia da 20 ms a 10,24 s. Pi\u00f9 breve \u00e8 l'intervallo, maggiore \u00e8 la frequenza di trasmissione dei pacchetti pubblicitari, con conseguente maggiore probabilit\u00e0 che tali pacchetti vengano ricevuti da uno scanner, ma maggiori quantit\u00e0 di pacchetti trasmessi si traducono anche in un maggiore consumo energetico.</p> <p>Poich\u00e9 l'advertising utilizza un massimo di tre canali di frequenza e l'advertiser e lo scanner non sono sincronizzati in alcun modo, un pacchetto pubblicitario verr\u00e0 ricevuto correttamente dallo scanner solo quando si sovrappongono casualmente.</p> <p></p> <p>I parametri intervallo di scansione e finestra di scansione definiscono la frequenza e la durata di ascolto di un dispositivo scanner per potenziali advertising pakage.</p> <p>Come per l'intervallo di pubblicit\u00e0, questi valori hanno un impatto significativo sul consumo energetico, poich\u00e9 sono direttamente correlati al tempo di accensione della radio. La specifica definisce due tipi fondamentali di procedure di scansione:</p> <ol> <li>Scansione passiva Lo scanner si limita ad ascoltare i pacchetti pubblicitari e l'advertiser non si accorge mai che uno o pi\u00f9 pacchetti sono stati effettivamente ricevuti da uno scanner.</li> <li>Scansione attiva Lo scanner emette un pacchetto di richiesta di scansione dopo aver ricevuto un advertising package. L'advertiser lo riceve e risponde con un pacchetto di risposta alla scansione. Questo pacchetto aggiuntivo raddoppia il carico utile effettivo che l'advertiser \u00e8 in grado di inviare allo scanner, ma \u00e8 importante notare che ci\u00f2 non fornisce allo scanner alcun mezzo per inviare dati utente all'advertiser.</li> </ol> <p>Modificando questi tre parametri (Advertising Interval, Scan Interval e Scan Window), puoi decidere se vuoi che il tuo dispositivo consumi pochissima batteria (intervalli lunghi, finestre corte) al costo di metterci molto tempo a farsi trovare, oppure se vuoi che si colleghi istantaneamente (intervalli brevissimi, finestre lunghe) sacrificando per\u00f2 la batteria.</p> <p>I tipi di pacchetti pubblicitari possono essere classificati in base a tre diverse propriet\u00e0. La prima \u00e8 la connettibilit\u00e0: Connettibile Uno scanner pu\u00f2 avviare una connessione alla ricezione di tale pacchetto pubblicitario. Non connettibile Uno scanner non pu\u00f2 avviare una connessione (questo pacchetto \u00e8 destinato esclusivamente alla trasmissione). La \u200b\u200bseconda propriet\u00e0 \u00e8 la scansionabilit\u00e0: Scansionabile Uno scanner pu\u00f2 emettere una richiesta di scansione alla ricezione di tale pacchetto pubblicitario. Non scansionabile Uno scanner non pu\u00f2 emettere una richiesta di scansione alla ricezione di tale pacchetto pubblicitario. La terza \u00e8 la direzionalit\u00e0: Diretto Un pacchetto di questo tipo contiene solo gli indirizzi Bluetooth dell'inserzionista e dello scanner di destinazione nel suo payload. Non sono ammessi dati utente. Tutti i pacchetti pubblicitari diretti sono quindi connettibili. Non diretto Un pacchetto di questo tipo non \u00e8 destinato a nessuno scanner in particolare e pu\u00f2 contenere dati utente nel suo payload.</p>"},{"location":"00_Inbox/draft_BLE/BLE/#fase-di-connessione","title":"Fase di connessione","text":"<p>Una volta che lo Scanner (il dispositivo Centrale) ha \"visto\" l'Advertiser (la Periferica) durante la fase di Discovery e decide che vuole stabilire una comunicazione bidirezionale e privata, la procedura passa dal Broadcasting alla vera e propria Connessione.</p> <p>Subito dopo aver ricevuto un pacchetto di advertising sul canale 37, 38 o 39, lo Scanner non aspetta il ciclo successivo, ma risponde immediatamente (entro pochi microsecondi) con un pacchetto speciale chiamato Connection Request (o CONNECT_IND) che contiene:</p> <ul> <li>Intervallo di connessione Tempo tra l'inizio di due eventi di connessione consecutivi. Questo valore varia da 7,5 ms (throughput elevato) a 4 s (throughput minimo possibile ma anche minimo consumo energetico).</li> <li>Latenza slave Numero di eventi di connessione che uno slave pu\u00f2 scegliere di saltare senza rischiare una disconnessione.</li> <li>Timeout di supervisione della connessione Tempo massimo tra due pacchetti di dati validi ricevuti prima che una connessione venga considerata persa.</li> </ul> <p>Il pacchetto di richiesta di connessione include l'incremento di frequenza del salto, che determina la sequenza di salto che sia il master che lo slave seguiranno durante la durata della connessione. ntrambi i dispositivi smettono immediatamente di usare i 3 canali di advertising. Si spostano sui restanti 37 canali dati della banda a 2.4 GHz. Per evitare interferenze con il Wi-Fi e altri dispositivi Bluetooth, usano una tecnica chiamata Adaptive Frequency Hopping (AFH): ad ogni Connection Interval, i due dispositivi saltano insieme in modo sincronizzato su un canale diverso, seguendo un algoritmo pseudocasuale.</p> <p>Ora i dispositivi sono connessi a livello radio (Link Layer). Non tengono per\u00f2 la radio sempre accesa. Si danno semplicemente \"appuntamento\" ad ogni Connection Interval. Durante questo brevissimo istante (chiamato Connection Event), il Centrale invia un pacchetto, la Periferica risponde, ed entrambi spengono immediatamente le radio fino all'appuntamento successivo. Questo \u00e8 il vero segreto del \"Low Energy\" del BLE.</p> <p></p> <p>Liste bianche Una funzionalit\u00e0 importante disponibile nei controller BLE, le liste bianche consentono agli host di filtrare i dispositivi durante l'annuncio, la scansione e la creazione di connessioni su entrambi i lati. Le liste bianche sono semplicemente array di indirizzi di dispositivi Bluetooth che vengono compilati dall'host e memorizzati e utilizzati nel controller. Un dispositivo che esegue la scansione o avvia una connessione pu\u00f2 utilizzare una lista bianca per limitare il numero di dispositivi che verranno rilevati o con cui pu\u00f2 connettersi, e il dispositivo che annuncia pu\u00f2 utilizzare una lista bianca per specificare da quali peer accetter\u00e0 una connessione in ingresso. L'impostazione che definisce se utilizzare o meno una lista bianca \u00e8 chiamata politica di filtro. Questa funge essenzialmente da interruttore per attivare e disattivare il filtro della lista bianca.</p> <p>I pacchetti di dati hanno un payload di dati utilizzabile di 27 byte, ma protocolli aggiuntivi pi\u00f9 in alto nello stack in genere limitano la quantit\u00e0 effettiva di dati utente a 20 byte per pacchetto, sebbene ci\u00f2 dipenda logicamente dal protocollo utilizzato. \u00c8 importante notare che il livello di collegamento funge da portatore di dati affidabile. Tutti i pacchetti ricevuti vengono controllati con un CRC a 24 bit e vengono richieste ritrasmissioni quando il controllo degli errori rileva un errore di trasmissione. Non esiste un limite massimo per le ritrasmissioni; il livello di collegamento reinvier\u00e0 il pacchetto finch\u00e9 non verr\u00e0 finalmente riconosciuto dal ricevitore.</p> <p>Il Link Layer \u00e8 anche responsabile di diverse procedure di controllo, inclusi questi due processi critici:</p> <ul> <li>Modifica dei parametri di connessione   Ogni connessione viene stabilita con un set di parametri di connessione impostato dal master, ma condizioni e requisiti potrebbero cambiare durante il ciclo di vita della connessione. Uno slave potrebbe improvvisamente richiedere un throughput maggiore per un breve burst di dati o, al contrario, potrebbe rilevare che nel prossimo futuro un intervallo di connessione pi\u00f9 lungo sar\u00e0 sufficiente a mantenere attiva la connessione. Il Link Layer consente al master e allo slave di richiedere nuovi parametri di connessione e, nel caso del master, di impostarli unilateralmente in qualsiasi momento. In questo modo, ogni connessione pu\u00f2 essere ottimizzata per fornire il miglior equilibrio tra throughput e consumo energetico.</li> <li>Crittografia   La sicurezza \u00e8 fondamentale in BLE e il Link Layer fornisce i mezzi per scambiare dati in modo sicuro su un collegamento crittografato. Le chiavi vengono generate e gestite dall'host, ma il Link Layer esegue la crittografia e la decrittografia dei dati in modo trasparente per i livelli superiori.</li> </ul>"},{"location":"00_Inbox/draft_BLE/BLE/#host-controller-interface-hci","title":"Host Controller Interface (HCI)","text":"<p>L'Host Controller Interface (HCI) \u00e8 il livello di demarcazione cruciale all'interno dello stack Bluetooth. Poich\u00e9 le specifiche consentono diverse configurazioni hardware, l'HCI funge da protocollo di comunicazione standard che permette l'interoperabilit\u00e0 tra un Host (i livelli superiori dello stack e l'applicazione) e un Controller (i livelli inferiori, come Link Layer e PHY) prodotti anche da aziende diverse (ad esempio, uno stack Host di Microsoft o Apple che comunica con un chip radio Controller di Broadcom o Qualcomm).</p> <p>Esempi tipici di questa configurazione (definita a \"doppio circuito integrato\") includono la maggior parte degli smartphone, tablet e personal computer. In questi dispositivi la divisione dei compiti \u00e8 netta:</p> <ul> <li> <p>Host e Applicazione: Vengono eseguiti dal processore principale (CPU) del dispositivo, dove c'\u00e8 abbondanza di memoria e potenza di calcolo.</p> </li> <li> <p>Controller: Si trova in un chip hardware dedicato e separato (il modulo radio Bluetooth).</p> </li> </ul> <p>Per far dialogare queste due entit\u00e0, la specifica Bluetooth definisce l'HCI attraverso tre elementi fondamentali:</p> <ul> <li> <p>Comandi ed Eventi: Un set standardizzato di istruzioni. L'Host invia Comandi al Controller (es. \"Inizia la scansione\", \"Connettiti a questo MAC address\"), e il Controller risponde con Eventi verso l'Host (es. \"Scansione terminata\", \"Dispositivo connesso\", \"Connessione persa\").</p> </li> <li> <p>Pacchetti Dati: Un formato rigoroso per incapsulare i dati utente (payload) da trasmettere o appena ricevuti via etere. L'HCI include anche un insieme di regole per il controllo di flusso, evitando che l'Host invii dati pi\u00f9 velocemente di quanto il Controller (che ha buffer pi\u00f9 piccoli) possa trasmetterli.</p> </li> <li> <p>Trasporti (Transports): La specifica definisce diversi livelli di trasporto fisico che veicolano e potenziano il protocollo HCI a livello hardware. I trasporti pi\u00f9 comuni utilizzati per collegare fisicamente la CPU al chip radio sono interfacce seriali standard come UART, USB, SPI o SDIO.</p> </li> </ul>"},{"location":"00_Inbox/draft_BLE/BLE/#logical-link-control-and-adaptation-protocol-l2cap","title":"Logical Link Control and Adaptation Protocol (L2CAP)","text":"<p>Il protocollo L2CAP (Logical Link Control and Adaptation Protocol), fornisce due funzionalit\u00e0 principali.</p> <p>Funge da multiplexer di protocollo che riceve pi\u00f9 protocolli dai livelli superiori, assegnando a ciascun pacchetto un Channel Identifier (CID), un numero identificativo del canale, li incapsula nel formato standard del pacchetto BLE e li incanala nell'unica connessione HCI verso il controller. Sul percorso di ricezione, riceve pacchetti HCI dal controller, estrae il CID e li inoltra al protocollo appropriato nei livelli superiori dell'host.</p> <p>In BLE, L2CAP utilizza principalmente canali fissi predefiniti:</p> <ul> <li>CID 0x0004: Canale riservato all'Attribute Protocol (ATT), ovvero lo scambio dei dati utente.</li> <li>CID 0x0005: Canale di segnalazione L2CAP (per gestire i parametri di connessione).</li> <li>CID 0x0006: Canale riservato al Security Manager Protocol (SMP), per la crittografia e il pairing.</li> </ul> <p>Oltre a ci\u00f2, e a partire dalla versione 4.1 della specifica, L2CAP pu\u00f2 creare canali personalizzati orientati alla connessione (LE Data Channels). Questi utilizzano un sistema \"a crediti\": il ricevitore comunica al trasmettitore quanti pacchetti \u00e8 in grado di immagazzinare nel suo buffer. Il trasmettitore invia dati solo se possiede \"crediti\" sufficienti, evitando cos\u00ec di sovraccaricare la memoria di dispositivi con risorse molto limitate, perdendo pacchetti.</p> <p>Esegue anche la frammentazione e la ricombinazione, un processo mediante il quale preleva pacchetti di grandi dimensioni dai livelli superiori e li suddivide in blocchi che rientrano nella dimensione massima del payload di 27 byte, o fino a 251 byte con le estensioni pi\u00f9 recenti, dei pacchetti BLE sul lato trasmissione.</p> <p>L2CAP si occupa di prendere i grossi blocchi di dati provenienti dai livelli superiori, \"tagliarli\" in frammenti pi\u00f9 piccoli compatibili con la massima unit\u00e0 di trasmissione (MTU) del controller radio, e aggiungere un'intestazione (header) per indicarne la lunghezza e il canale. Sul dispositivo ricevente, L2CAP esegue l'operazione inversa, riassemblando i frammenti nell'esatto ordine prima di consegnarli al livello superiore.</p> <p>L'intestazione del pacchetto L2CAP occupa quattro byte, il che significa che la lunghezza effettiva del payload utente \u00e8 27 - 4 = 23 byte (dove 27 byte \u00e8 la dimensione del payload del LL, o 251 byte con le estensioni pi\u00f9 recenti).</p> <p>L2CAP garantisce un instradamento affidabile dei dati, ma sui canali fissi predefiniti (come l'ATT) non fornisce alcun meccanismo intrinseco di controllo del flusso o ritrasmissione in caso di errore (questi compiti sono demandati al Link Layer sottostante o al protocollo di livello superiore). Al contrario, per i canali personalizzati (LE Data Channels), il controllo di flusso \u00e8 attivamente gestito tramite il sopracitato sistema a crediti</p>"},{"location":"00_Inbox/draft_BLE/BLE/#attribute-protocol-att","title":"Attribute Protocol (ATT)","text":"<p>L'Attribute Protocol (ATT) \u00e8 il protocollo di livello superiore che definisce il modo in cui i dati vengono rappresentati, archiviati e scambiati all'interno di un dispositivo BLE. Viaggia sul canale L2CAP dedicato fisso (CID 0x0004) ed \u00e8 la base su cui si costruisce l'intera applicazione utente.</p> <p>L'ATT si basa su una rigorosa architettura Client/Server, che \u00e8 indipendente dai ruoli GAP (Centrale e Periferica).</p> <ul> <li>ATT Server: \u00c8 il dispositivo che possiede e memorizza fisicamente i dati (gli \"attributi\"). Accetta le richieste dal Client. (Esempio: un sensore di temperatura).</li> <li>ATT Client: \u00c8 il dispositivo che desidera accedere ai dati. Invia richieste al Server per leggere, scrivere o essere avvisato dei cambiamenti. (Esempio: lo smartphone che legge la temperatura).</li> </ul> <p>Il protocollo \u00e8 rigoroso in termini di sequenziamento: se una richiesta \u00e8 ancora in sospeso (non \u00e8 stata ancora ricevuta alcuna risposta), non \u00e8 possibile inviare ulteriori richieste finch\u00e9 la risposta non viene ricevuta ed elaborata. Questo vale in entrambe le direzioni in modo indipendente nel caso in cui due peer agiscano sia come client che come server.</p> <p>Ogni server contiene dati organizzati sotto forma di attributi, composto da quattro elementi:</p> <ol> <li>Attribute Handle (Gestore): \u00c8 l'indirizzo a 16 bit dell'attributo (es. 0x001A). Funge da indice nel database. Il Client usa questo numero per dire al Server: \"Voglio leggere il dato all'indirizzo 0x001A\".</li> <li>Attribute Type (UUID): \u00c8 un identificatore univoco universale (UUID) che spiega al Client cosa rappresenta quel dato. Il Bluetooth SIG definisce UUID standard a 16 bit per i dati comuni (es. 0x2A37 significa sempre \"Heart Rate Measurement\"), ma gli sviluppatori possono creare UUID personalizzati a 128 bit per i propri dati proprietari.</li> <li>Attribute Value (Valore): \u00c8 il payload effettivo, ovvero il dato vero e proprio. Pu\u00f2 essere un singolo numero a 8 bit, una stringa di caratteri o un array di byte (fino a 512 byte massimi in base alla frammentazione).</li> <li>Attribute Permissions (Permessi): Definiscono chi pu\u00f2 fare cosa con questo attributo. I permessi non possono essere letti dal Client, ma sono applicati dal Server. Stabiliscono se un attributo \u00e8 di sola lettura, di lettura/scrittura, e se richiede una connessione crittografata (tramite il livello SMP) per essere accessibile.</li> </ol> <p>Quando un client desidera leggere o scrivere valori di attributo da o verso un server, invia una richiesta di lettura o scrittura al server con l'handle. Il server risponder\u00e0 con il valore dell'attributo o una conferma. Nel caso di un'operazione di lettura, spetta al client analizzare il valore e comprendere il tipo di dati in base all'UUID dell'attributo. D'altra parte, durante un'operazione di scrittura, ci si aspetta che il client fornisca dati coerenti con il tipo di attributo e il server \u00e8 libero di rifiutare l'operazione in caso contrario.</p>"},{"location":"00_Inbox/draft_BLE/BLE/#operazioni-att","title":"Operazioni ATT","text":"<p>L'Attribute Protocol definisce anche i metodi (o comandi) con cui il Client e il Server interagiscono tra loro per manipolare questi attributi. Le operazioni principali sono:</p> <ul> <li>Read Request / Response: Il Client chiede di leggere il Valore di un attributo tramite il suo Handle. Il Server risponde con il dato.</li> <li>Write Request / Response: Il Client invia un dato al Server per scriverlo in un attributo specifico e attende una conferma (Response) dell'avvenuta scrittura.</li> <li>Write Command: Come la Write Request, ma il Client non attende alcuna conferma dal Server (utile per inviare flussi di dati molto veloci).</li> <li>Notification (Notifica): Inviata dal Server al Client in modo asincrono quando un dato cambia (es. il battito cardiaco aumenta). Non richiede conferma da parte del Client. \u00c8 il metodo pi\u00f9 utilizzato in BLE per risparmiare energia.</li> <li>Indication (Indicazione): Simile alla Notifica, ma il Server richiede che il Client risponda con una conferma di ricezione (pi\u00f9 affidabile, ma pi\u00f9 lenta).</li> </ul>"},{"location":"00_Inbox/draft_BLE/BLE/#security-manager-protocol-smp","title":"Security Manager Protocol (SMP)","text":"<p>Il Security Manager Protocol (SMP) \u00e8 il livello dello stack Bluetooth Low Energy responsabile della sicurezza della connessione. Definisce i metodi e i protocolli necessari per accoppiare due dispositivi in modo sicuro, autenticarsi reciprocamente, crittografare il collegamento radio e scambiarsi le chiavi di sicurezza. L'SMP viaggia sul canale dedicato L2CAP (CID 0x0006).</p> <p>Il Security Manager definisce due ruoli:</p> <ol> <li>Initiator Corrisponde sempre al Link Layer master e quindi alla centrale GAP.</li> <li>Responder Corrisponde sempre allo Link Layer slave e quindi alla periferica GAP.</li> </ol> <p>Sebbene spetti sempre all'iniziatore attivare l'inizio di una procedura, il risponditore pu\u00f2 richiedere in modo asincrono l'avvio di una qualsiasi delle procedure sicurezza. Non vi \u00e8 alcuna garanzia per il risponditore che l'iniziatore ascolter\u00e0 effettivamente la richiesta, fungendo pi\u00f9 da suggerimento che da vera e propria richiesta vincolante. Questa richiesta di sicurezza pu\u00f2 logicamente essere emessa solo dallo slave o dalla periferica della connessione.</p> <p>Accoppiamento Procedura mediante la quale viene generata una chiave di crittografia di sicurezza comune temporanea per poter passare a una connessione sicura e crittografata. Questa chiave temporanea non viene memorizzata e pertanto non \u00e8 riutilizzabile nelle connessioni successive. Bonding Sequenza di accoppiamento seguita dalla generazione e dallo scambio di chiavi di sicurezza permanenti, destinate a essere memorizzate nella memoria non volatile e quindi a creare un collegamento permanente tra due dispositivi, che consentir\u00e0 loro di impostare rapidamente una connessione sicura nelle connessioni successive senza dover eseguire nuovamente una procedura di collegamento. Ripristino della crittografia Al termine di una procedura di collegamento, le chiavi potrebbero essere state memorizzate su entrambi i lati della connessione. Se le chiavi di crittografia sono state memorizzate, questa procedura definisce come utilizzare tali chiavi nelle connessioni successive per ristabilire una connessione sicura e crittografata senza dover ripetere la procedura di accoppiamento (o collegamento).</p>"},{"location":"00_Inbox/draft_BLE/BLE/#le-fasi-del-pairing","title":"Le fasi del Pairing","text":"<p>Il processo di sicurezza in BLE si divide tipicamente in tre fasi sequenziali:</p> <p>Fase 1: Negoziazione delle funzionalit\u00e0 (Feature Exchange) I due dispositivi si scambiano informazioni sulle proprie capacit\u00e0 di input/output (I/O capabilities). Ad esempio, un dispositivo dichiara se possiede un display (per mostrare un PIN), una tastiera (per inserirlo) o solo un pulsante \"S\u00ec/No\". Questa negoziazione determina quale metodo di accoppiamento verr\u00e0 utilizzato nella Fase 2.</p> <p>Fase 2: Generazione della chiave (Key Generation) In base alle capacit\u00e0 di I/O negoziate, i dispositivi utilizzano uno dei seguenti metodi per autenticarsi e generare la chiave di crittografia (Short Term Key in BLE Legacy, o Long Term Key in LE Secure Connections):</p> <ul> <li> <p>Just Works: Usato quando i dispositivi non hanno display o tastiere (es. auricolari wireless). La connessione viene crittografata, ma non offre protezione contro gli attacchi Man-In-The-Middle (MITM).</p> </li> <li> <p>Passkey Entry: Un dispositivo mostra un PIN a 6 cifre sul display e l'utente lo digita sulla tastierina dell'altro dispositivo. Offre protezione MITM.</p> </li> <li> <p>Numeric Comparison: Introdotto con LE Secure Connections (BLE 4.2+), entrambi i dispositivi mostrano un codice a 6 cifre. L'utente deve solo confermare (tramite un pulsante \"S\u00ec\") che i due codici corrispondono. Offre altissima sicurezza e protezione MITM.</p> </li> <li> <p>Out of Band (OOB): Le chiavi di sicurezza vengono scambiate utilizzando una tecnologia wireless completamente diversa, come l'NFC (Near Field Communication). \u00c8 estremamente sicuro.</p> </li> </ul> <p>Fase 3: Distribuzione delle chiavi (Key Distribution) Una volta che il canale \u00e8 crittografato, i dispositivi possono scambiarsi chiavi aggiuntive per funzionalit\u00e0 specifiche. Le pi\u00f9 importanti sono:</p> <ul> <li> <p>Informazioni di crittografia (chiave a lungo termine o LTK) e identificazione master (EDIV, Rand)   Si tratta di una chiave di crittografia a 128 bit condivisa da entrambe le parti (LTK) insieme a due valori (EDIV, Rand) che fungono da identificativo, poich\u00e9 un dispositivo pu\u00f2 essere associato a pi\u00f9 peer.</p> </li> <li> <p>Identity Resolving Key (IRK): Fondamentale per la privacy. Consente a un dispositivo di cambiare continuamente il proprio indirizzo MAC pubblico (MAC Randomization) per non essere tracciato da scanner malevoli, permettendo per\u00f2 al dispositivo \"bondato\" (che possiede la IRK) di riconoscerlo ugualmente.</p> </li> <li> <p>Connection Signature Resolving Key (CSRK): Permette di firmare i dati e verificarne l'autenticit\u00e0 senza dover necessariamente crittografare l'intera connessione (utile per risparmiare energia in scenari specifici).</p> </li> </ul> <p>Ognuna di queste chiavi o set di chiavi \u00e8 asimmetrica e unidirezionale: pu\u00f2 essere utilizzata solo nella stessa configurazione di ruolo in cui \u00e8 stata originariamente generata. Se i dispositivi desiderano scambiare i ruoli del Link Layer (master e slave) nelle connessioni successive, ciascuna parte deve distribuire il proprio set di chiavi per ciascun tipo di chiave. I dispositivi negoziano il numero di chiavi distribuite in ciascuna direzione, che pu\u00f2 variare da zero a tutti e tre i tipi di chiave in ciascuna direzione, per un totale di sei chiavi distribuite tra i peer (tre dallo slave al master e tre dal master allo slave).</p> <p>L'SM specifica i seguenti tre tipi di meccanismi di sicurezza che possono essere utilizzati per applicare vari livelli di sicurezza durante una connessione o durante la procedura pubblicitaria.</p> <p>Crittografia Questo meccanismo consiste nella crittografia completa di tutti i pacchetti trasmessi su una connessione stabilita. Privacy La funzione di privacy consente a un inserzionista di nascondere il proprio indirizzo Bluetooth pubblico utilizzando indirizzi temporanei, generati casualmente, che possono essere riconosciuti da uno scanner associato al dispositivo pubblicitario. Firma Con questo meccanismo, un dispositivo pu\u00f2 inviare un pacchetto non crittografato su una connessione stabilita, firmato digitalmente (ovvero, la cui origine pu\u00f2 essere verificata)</p>"},{"location":"00_Inbox/draft_BLE/BLE/#profili","title":"Profili","text":"<p>I profili definiscono come i protocolli sottostanti debbano essere utilizzati per garantire l'interoperabilit\u00e0 tra dispositivi sviluppati da fornitori diversi. Nello stack Bluetooth Low Energy, due profili generici sono obbligatori e fondamentali per qualsiasi applicazione:</p> <ul> <li> <p>Generic Access Profile (GAP): \u00c8 il livello di controllo pi\u00f9 elevato del BLE. Gestisce la topologia della rete, definendo i ruoli dei dispositivi (Broadcaster/Observer, Central/Peripheral) e le procedure per la scoperta (discovery), l'advertising, l'instaurazione delle connessioni e la gestione della sicurezza.</p> </li> <li> <p>Generic Attribute Profile (GATT): \u00c8 il livello dei dati pi\u00f9 elevato del BLE. Basato sul protocollo ATT, stabilisce un modello gerarchico per formattare e scambiare i dati tra dispositivi connessi, definendo le regole standard per rilevare, leggere, scrivere e notificare le informazioni utente.</p> </li> </ul>"},{"location":"00_Inbox/draft_BLE/BLE/#generic-access-profile-gap","title":"Generic Access Profile (GAP)","text":"<p>Il Generic Access Profile (GAP) \u00e8 il framework fondamentale che garantisce l'interoperabilit\u00e0 tra i dispositivi BLE. Definisce le regole universali con cui i dispositivi si scoprono a vicenda, trasmettono dati in broadcast e stabiliscono connessioni sicure. Poich\u00e9 gestisce queste operazioni di base, il GAP rappresenta quasi sempre il punto di ingresso principale (API) per gli sviluppatori di applicazioni.</p> <p>Il GAP governa le interazioni definendo due concetti chiave: i Ruoli e le Modalit\u00e0.</p>"},{"location":"00_Inbox/draft_BLE/BLE/#ruoli","title":"Ruoli","text":"<p>Un dispositivo pu\u00f2 operare in uno o pi\u00f9 ruoli contemporaneamente. I ruoli definiscono il comportamento di base del dispositivo e, solitamente, sono strettamente legati al suo scopo hardware (e quindi raramente cambiano).</p> <ul> <li>Broadcaster: Trasmette pacchetti pubblicitari (advertising) ma non accetta connessioni.</li> <li>Observer: Ascolta i pacchetti pubblicitari (scanning) ma non avvia connessioni.</li> <li>Peripheral (Periferica): Trasmette pacchetti pubblicitari e accetta connessioni in ingresso. Una volta connesso, assume il ruolo di Slave nel Link Layer.</li> <li>Central (Centrale): Ascolta i pacchetti pubblicitari e avvia connessioni verso le periferiche. Una volta connesso, assume il ruolo di Master nel Link Layer.</li> </ul>"},{"location":"00_Inbox/draft_BLE/BLE/#modalita","title":"Modalit\u00e0","text":"<p>A differenza dei ruoli, che sono spesso statici, le modalit\u00e0 sono stati temporanei. Un dispositivo entra in una specifica modalit\u00e0 solo per un certo periodo di tempo, al fine di permettere a un altro dispositivo di interagire con esso. Il cambio di modalit\u00e0 avviene frequentemente e pu\u00f2 essere attivato automaticamente dal sistema o da un'azione dell'utente (es. la pressione di un tasto per avviare il pairing).</p> <p>Le modalit\u00e0 pi\u00f9 comuni nel GAP sono:</p> <ul> <li>Discoverable Mode (Modalit\u00e0 Scopribile): Il dispositivo trasmette advertising package, permettendo ad altri dispositivi di scoprirlo durante la scansione.</li> <li>Connectable Mode (Modalit\u00e0 Connettibile): Il dispositivo accetta richieste di connessione in ingresso da altri dispositivi.</li> <li>Bondable Mode (Modalit\u00e0 Associabile): Il dispositivo consente il pairing e il bonding con altri dispositivi, memorizzando le chiavi di sicurezza per connessioni future.</li> </ul> <pre><code>stateDiagram-v2\n    direction LR\n\n    state \"Standby (Idle)\" as Standby\n    state \"Advertising\" as Adv\n    state \"Connected\" as Conn\n\n    [*] --&gt; Standby : Accensione dispositivo\n\n    Standby --&gt; Adv : Azione utente (es. pressione tasto)\n\n    Adv --&gt; Standby : Timeout (es. 60s senza richieste)\n    Adv --&gt; Conn : Ricezione CONNECT_REQ (da uno Scanner)\n\n    Conn --&gt; Standby : Disconnessione / Timeout Link Layer\n</code></pre>"},{"location":"00_Inbox/draft_BLE/BLE/#generic-attribute-profile-gatt","title":"Generic Attribute Profile (GATT)","text":"<p>Il Generic Attribute Profile (GATT) stabilisce in dettaglio come scambiare i dati utente su una connessione BLE. Utilizza l'Attribute Protocol (ATT) come protocollo di trasporto sottostante, organizzando i dati grezzi (gli attributi) in una struttura gerarchica ben precisa.</p> <p>Il GATT entra in gioco esclusivamente dopo che \u00e8 stata stabilita una connessione (quando il dispositivo \u00e8 nello stato Connected del GAP).</p> <p>GATT fornisce inoltre il quadro di riferimento per tutti i profili basati su GATT, che coprono casi d'uso precisi e garantiscono l'interoperabilit\u00e0 tra dispositivi di diversi fornitori. Tutti i profili BLE standard sono quindi basati su GATT e devono essere conformi ad esso per funzionare correttamente.</p> <p>Il GATT definisce due ruoli per l'interazione dei dati, che sono completamente indipendenti dai ruoli GAP (Centrale/Periferica):</p> <ul> <li>GATT Server: \u00c8 il dispositivo che possiede il \"database\" dei dati e accetta le richieste. Esempio: Un sensore di temperatura (Periferica GAP) che memorizza il valore misurato. Riceve richieste da un client e invia risposte. Invia anche aggiornamenti avviati dal server quando configurato per farlo, ed \u00e8 il ruolo responsabile dell'archiviazione e della messa a disposizione dei dati utente al client, organizzati in attributi. Ogni dispositivo BLE venduto deve includere almeno un server GATT di base in grado di rispondere alle richieste del client, anche solo per restituire una risposta di errore.</li> <li>GATT Client: \u00c8 il dispositivo che invia richieste al Server per leggere, scrivere o essere notificato sui dati. Esempio: Uno smartphone (Centrale GAP) che legge il valore dal sensore. Il client GATT non sa nulla in anticipo sugli attributi del server, quindi deve prima informarsi sulla presenza e la natura di tali attributi eseguendo la scoperta del servizio (Service Discovery) prima di poter interagire con i dati.</li> </ul> <p>Il GATT organizza i dati come una matrioska, strutturandoli in tre livelli principali: Profili, Servizi e Caratteristiche.</p> <ol> <li>Profile (Profilo): Non esiste fisicamente sul dispositivo, ma \u00e8 un documento concettuale (una specifica) definito dal Bluetooth SIG o dallo sviluppatore. Un Profilo \u00e8 una raccolta di Servizi predefiniti che descrivono un caso d'uso specifico. Esempio: Il \"Heart Rate Profile\" stabilisce che il dispositivo deve obbligatoriamente contenere il Servizio Heart Rate e il Servizio Device Information.</li> <li>Service (Servizio): \u00c8 un raggruppamento logico di dati correlati tra loro per compiere una specifica funzione. Ogni servizio \u00e8 identificato in modo univoco da un UUID (Universally Unique Identifier).</li> <li>UUID a 16-bit: Riservati ai servizi standard definiti dal Bluetooth SIG (es. 0x180D per l'Heart Rate Service).</li> <li>UUID a 128-bit: Utilizzati per servizi proprietari/personalizzati creati dallo sviluppatore (es. 12345678-1234-5678-1234-56789abcdef0).</li> </ol> <p>Servizio Primario (Primary Service): Rappresenta la funzionalit\u00e0 principale del dispositivo (es. il servizio Heart Rate in un cardiofrequenzimetro). Pu\u00f2 essere scoperto direttamente dal Client.</p> <p>Servizio Secondario (Secondary Service): Contiene funzionalit\u00e0 ausiliarie e ha senso solo se referenziato (incluso) da un altro servizio primario. Non pu\u00f2 essere scoperto direttamente dal Client per scopi principali.</p> <ol> <li>Characteristic (Caratteristica): \u00c8 il contenitore effettivo del dato utente e il concetto pi\u00f9 importante del GATT. Un Servizio pu\u00f2 contenere una o pi\u00f9 Caratteristiche. Ogni Caratteristica \u00e8 composta a sua volta da tre elementi:</li> <li>Declaration (Dichiarazione): I metadati. Definisce le propriet\u00e0 della caratteristica (sola lettura, scrittura, notifica), il suo UUID e il suo indirizzo (Handle).</li> <li>Value (Valore): Il dato vero e proprio (es. il numero 60 che rappresenta i battiti al minuto, o una stringa di testo).</li> <li>Descriptor (Descrittore - opzionale): Fornisce informazioni aggiuntive sulla caratteristica. Il pi\u00f9 importante \u00e8 il CCCD (Client Characteristic Configuration Descriptor), che agisce come un interruttore: il Client deve scriverci dentro un \"1\" per abilitare la ricezione delle Notifiche da parte del Server.</li> </ol> <p> </p> <p>Tramite l'architettura Client/Server, il GATT espone i metodi dell'ATT per interagire con le Caratteristiche. Le operazioni fondamentali che un programmatore utilizzer\u00e0 sono:</p> <ul> <li>Read: Il Client chiede di leggere il Valore di una Caratteristica.</li> <li>Write: Il Client invia un dato per sovrascrivere il Valore di una Caratteristica.</li> <li>Write (Request): Il Client invia un dato e attende un pacchetto di conferma (ACK) dal Server. \u00c8 un'operazione affidabile ma pi\u00f9 lenta.</li> <li> <p>Write Without Response (Command): Il Client \"spara\" il dato al Server senza attendere conferme (Fire-and-forget). \u00c8 meno affidabile, ma indispensabile per trasmettere flussi continui e veloci di dati (es. streaming audio compresso o aggiornamenti firmware OTA).</p> </li> <li> <p>Notify (Notifica): Il Server invia automaticamente il Valore al Client non appena questo cambia. \u00c8 il meccanismo pi\u00f9 efficiente e usato in BLE perch\u00e9 evita al Client di dover richiedere continuamente il dato (polling), risparmiando moltissima batteria.</p> </li> <li>Indicate (Indicazione): Come la notifica, ma richiede una conferma di ricezione (ACK) da parte del Client.</li> </ul>"},{"location":"00_Inbox/draft_BLE/BLE/#mtu-exchange-e-throughput","title":"MTU Exchange e Throughput","text":"<p>L'ATT MTU definisce la dimensione massima (in byte) di un pacchetto Attribute Protocol che pu\u00f2 essere scambiato tra un Client e un Server GATT. Secondo le specifiche Bluetooth, ogni connessione BLE si avvia sempre con un MTU predefinito di 23 byte, per garantire l'assoluta retrocompatibilit\u00e0 con i primissimi dispositivi BLE 4.0.</p> <p>Tuttavia, ogni operazione GATT (come inviare una Write o ricevere una Notify) richiede obbligatoriamente un'intestazione (header) ATT di 3 byte:</p> <ul> <li>1 byte per l'Opcode (il tipo di operazione).</li> <li>2 byte per l'Attribute Handle (l'indirizzo del dato).</li> </ul> <p>Sottraendo questi 3 byte di overhead ai 23 byte di MTU, otteniamo esattamente 20 byte di payload utile. Se un'applicazione tenta di inviare una stringa di 25 byte senza aver prima negoziato l'MTU, i 5 byte in eccesso verranno inesorabilmente troncati.</p> <p>Per superare questo limite, il GATT Client pu\u00f2 avviare la procedura di MTU Exchange. Questa operazione pu\u00f2 essere eseguita una sola volta per connessione e funziona secondo la rigorosa \"regola del minimo\":</p> <ol> <li>Il Client invia un pacchetto Exchange MTU Request al Server, dichiarando la dimensione massima del proprio buffer di ricezione (ad esempio, 512 byte).</li> <li>Il Server risponde con un pacchetto Exchange MTU Response, dichiarando a sua volta la propria capacit\u00e0 massima (ad esempio, 256 byte).</li> <li>L'MTU effettivo per l'intera durata della connessione sar\u00e0 impostato sul valore minimo tra i due dichiarati (in questo esempio, 256 byte).</li> </ol> <p>Con un MTU negoziato a 256 byte, il payload utente per singolo pacchetto sale a 253 byte (256 - 3). Il limite massimo teorico consentito dalle specifiche per l'MTU \u00e8 di 512 byte (509 byte di payload utile).</p> <p>\u00c8 fondamentale non confondere l'MTU (che \u00e8 una restrizione logica a livello Host/L2CAP) con le dimensioni del pacchetto radio a livello Link Layer (Controller).</p> <p>Se negozi un MTU di 512 byte su un vecchio hardware BLE 4.0 (che a livello radio supporta solo pacchetti da 27 byte), il livello L2CAP sar\u00e0 costretto a compiere una massiccia frammentazione, spezzettando il tuo grosso pacchetto GATT in decine di minuscoli pacchetti Link Layer per trasmetterli via etere. Per ottenere un reale aumento del throughput, un MTU elevato deve essere accompagnato dalla Data Length Extension (DLE), una funzionalit\u00e0 introdotta con il BLE 4.2 che espande il payload fisico del Link Layer da 27 fino a 251 byte. Quando DLE e un grande MTU lavorano in sinergia, il dispositivo pu\u00f2 trasmettere enormi quantit\u00e0 di dati con un overhead minimo, aprendo la strada ad applicazioni come l'aggiornamento firmware over-the-air (OTA) o lo streaming di audio compresso.</p>"},{"location":"10_Theory/Algorithms/Complexity_Basics/","title":"Complexity Basics","text":"<p>Stato: #seed</p>"},{"location":"10_Theory/Algorithms/Complexity_Basics/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"10_Theory/Data_Structures/Trees_and_Graphs/","title":"Trees and Graphs","text":"<p>Stato: #seed</p>"},{"location":"10_Theory/Data_Structures/Trees_and_Graphs/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"10_Theory/Reti/Reti_MOC/","title":"\ud83d\uddfa\ufe0f Reti (MOC)","text":"<p>Area: [[10_Theory]]</p>"},{"location":"10_Theory/Reti/Reti_MOC/#indice","title":"\ud83d\udccc Indice","text":""},{"location":"10_Theory/Sicurezza/Sicurezza_MOC/","title":"\ud83d\uddfa\ufe0f Sicurezza (MOC)","text":"<p>Area: [[10_Theory]]</p>"},{"location":"10_Theory/Sicurezza/Sicurezza_MOC/#indice","title":"\ud83d\udccc Indice","text":""},{"location":"20_Languages/Java/Java_MOC/","title":"\ud83d\uddfa\ufe0f Java (MOC)","text":"<p>Stato: #seed | Collegamenti: index</p>"},{"location":"20_Languages/Java/Java_MOC/#indice-argomenti","title":"\ud83d\udccc Indice Argomenti","text":""},{"location":"20_Languages/Python/Python_MOC/","title":"Python MOC","text":"<p>Stato: #seed</p>"},{"location":"20_Languages/Python/Python_MOC/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"30_Frameworks_Tools/Android/0_Android_MOC/","title":"Android MOC","text":"<p>Stato: #growing MOC Genitore: [[30_Frameworks_Tools_MOC]]</p>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/0_Android_MOC/#fondamentali-del-sistema","title":"\ud83c\udfd7\ufe0f Fondamentali del Sistema","text":"<p>Concetti di base sull'architettura e il funzionamento del sistema operativo.</p> <ul> <li>1_Android_OS \u2013 Note sull'architettura del kernel e del runtime.</li> <li>2_Compilazione_app \u2013 Panoramica generale sulla compilazione app android.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/0_Android_MOC/#componenti-core","title":"\ud83e\uddf1 Componenti Core","text":"<p>Le fondamenta di ogni app Android.</p> <ul> <li>3_Activity_e_Fragment \u2013 Gestione dell'interfaccia utente.</li> <li>4_Service \u2013 Operazioni in background.</li> <li>5_Broadcast_Receiver \u2013 Comunicazione tra app e sistema.</li> <li>6_Content_Provider \u2013 Gestione e condivisione dei dati.</li> <li>7_Intent - Comunicazione tra componenti.</li> <li>8_Notifiche - Comunicazione con l'utente.</li> <li>9_Setting - Gestione delle impostazioni dell'app.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/0_Android_MOC/#fondamenti-di-ui","title":"\ud83c\udfa8 Fondamenti di UI","text":"<ul> <li>10_Gestione_UI_Android - Principi di progettazione e gestione dell'interfaccia utente.</li> <li>11_Layout - Struttura e organizzazione degli elementi UI.</li> <li>12_Modelli_navigazionali - Best practice per la navigazione tra schermate.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/0_Android_MOC/#ui-user-experience","title":"\ud83c\udfa8 UI &amp; User Experience","text":"<ul> <li>[[Jetpack Compose]] \u2013 Il nuovo standard per la UI dichiarativa.</li> <li>[[Material Design]] \u2013 Linee guida estetiche e funzionali.</li> <li>[[Gestione delle Risorse]] \u2013 Layout, stringhe e file in <code>/assets</code>.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/0_Android_MOC/#dati-e-networking","title":"\ud83d\udcbe Dati e Networking","text":"<ul> <li>[[Room Persistence Library]] \u2013 Astrazione su SQLite.</li> <li>[[Retrofit &amp; OkHttp]] \u2013 Consumo di API REST.</li> <li>[[Coroutines &amp; Flow]] \u2013 Gestione della concorrenza in Kotlin.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/0_Android_MOC/#testing-e-qualita","title":"\ud83e\uddea Testing e Qualit\u00e0","text":"<ul> <li>Unit Testing (JUnit)</li> <li>UI Testing (Espresso)</li> <li>[[Android Profiler]] \u2013 Monitoraggio di CPU, Memoria e Network.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/0_Android_MOC/#risorse-di-riferimento","title":"\ud83d\udd17 Risorse di Riferimento","text":"<ul> <li>Android Developers Documentation</li> <li>[[50_Project_Journal]] \u2013 Vedi i log dei progetti Android in corso.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/10_Gestione_UI_Android/","title":"INTERFACCIA UTENTE","text":"<p>Quando sviluppiamo un\u2019app Android, dobbiamo pensare all\u2019interfaccia grafica, ovvero a come gli elementi vengono organizzati sullo schermo.</p> <p>L'interfaccia utente (UI) di un'applicazione \u00e8 costruita attraverso una gerarchia di oggetti chiamati view. Ogni elemento visibile sullo schermo \u00e8 una view.</p> <p>Tutti i componenti visivi in Android discendono dalla classe Viewe vengono indicati genericamente come Views.</p> <p>La classe ViewGroup \u00e8 un'estensione di View che supporta l'aggiunta di visualizzazioni innestate che hanno la responsabilit\u00e0 di decidere le dimensioni della view di ogni figlio e di determinare la loroposizione.</p> <p>I ViewGroup che si concentrano principalmente sulla disposizione delle viste contenute sono indicati come layout. I ViewGroup sono visti quindi possono anche disegnare la propria interfaccia utente personalizzata e gestire le interazioni degli utenti.</p> <p>Layouts \u2192 definiscono la struttura e la disposizione degli elementi sulla schermata</p> <p>Views \u2192 Sono gli elementi base dell\u2019interfaccia utente</p> <p>Widgets \u2192 Sono particolari tipi di View con funzionalit\u00e0 specifiche</p> <p>Per creare e disporre le viste all'interno della UI si possono utilizzare risorse di layout XML per creare e costruire lo scheletro statico della UI di un Actvity da fare evolvere dinamicamente in modo programmatico.</p> <p>Questo approccio consente di specificare diversi layout ottimizzati per diverse configurazioni hardware, in particolare variazioni delle dimensioni dello schermo, potenzialmente anche modificandoli in fase di esecuzione in base a modifiche hardware (come i cambiamenti di orientamento).</p> <p>L\u2019interfaccia utente \u00e8 organizzata in una struttura ad albero gerarchico, chiamata albero delle View</p> <ul> <li>i nodi interni sono le ViewGroup</li> <li>le foglie sono le View effettive</li> </ul> <p>Quando apriamo un\u2019applicazione Android, una delle prime cose che il sistema fa \u00e8 costruire l\u2019interfaccia grafica dell\u2019Activity in base alla struttura definita nel file XML del layout. Questo processo avviene all\u2019interno del metodo onCreate(), dove viene caricato l\u2019albero delle View.</p> <p>Quando il metodo onCreate() viene eseguito, l\u2019Activity richiama setContentView(R.layout.activity_main), che ha il compito di leggere il file XML e tradurlo in un insieme di oggetti View e ViewGroup in memoria.</p> <p>Android calcola la disposizione degli elementi, assegna loro le dimensioni e infine li disegna sullo schermo.</p> <p>Android d\u00e0 la possibilit\u00e0 di modificare l\u2019albero delle View in tempo reale, aggiungendo, rimuovendo o modificando elementi dell\u2019interfaccia mentre l\u2019utente sta interagendo con l\u2019app, senza dover ricaricare l\u2019intera Activity</p>"},{"location":"30_Frameworks_Tools/Android/10_Gestione_UI_Android/#eventi","title":"EVENTI","text":"<p>Le view permettono di acquisire gli eventi dalla l'oggetto con cui interagisce l'utente. Per un'app Android, l'interazione in genere consiste nel toccare, premere, digitare o parlare e ascoltare.</p> <p>La View che ha il focus sar\u00e0 la componente che riceve l'input dell'utente.</p> <p>Il focus pu\u00f2 essere avviato dall'utente toccando una View. \u00c8 possibile definire un ordine di focus in cui l'utente viene guidato da un controllo UI a un altro controllo UI. Il focus pu\u00f2 anche essere controllato a livello di programmazione; un programmatore pu\u00f2 richiedereFocus() su qualsiasi View che \u00e8 focalizzabile.</p> <p>Un altro attributo di un controllo di input \u00e8 cliccabile. Se questo attributo \u00e8 true, allora la View pu\u00f2 reagire agli eventi di clic. Come per il focus, cliccabile pu\u00f2 essere controllato a livello di programmazione.</p> <p>La differenza tra cliccabile e focalizzabile \u00e8 che cliccabile significa che la view pu\u00f2 essere cliccata o toccata, mentre focalizzabile significa che alla view \u00e8 consentito ottenere il focus da un dispositivo di input come una tastiera. I dispositivi di input come le tastiere non possono determinare a quale view inviare i loro eventi di input, quindi li inviano alla view che ha il focus.</p> <p>per intercettarlo, devi estendere la classe e sostituire il metodo. Tuttavia, l'estensione di ogni oggetto View per gestire un evento del genere non sarebbe pratica. Per questo motivo la classe View contiene anche una raccolta di interfacce nidificate con callback che puoi definire molto pi\u00f9 facilmente. Un listener di eventi \u00e8 un'interfaccia della classe View che contiene un singolo di callback. Questi metodi verranno chiamati dal framework Android quando la view a cui il listener ha registrato viene attivato dall'interazione dell'utente con l'elemento nell'interfaccia utente.</p> <p>Le interfacce del listener di eventi includono i seguenti metodi di callback:</p> <p>onClick()da\u00a0View.OnClickListener. Questo viene chiamato quando l'utente tocca l'elemento. (in modalit\u00e0 touch) o si concentra sull'elemento con i tasti di navigazione o la trackball e preme il tasto \"Invio\" adatto o premi la trackball.</p> <p>onLongClick()da\u00a0View.OnLongClickListener. Questo viene chiamato quando l'utente tocca e tiene premuto l'elemento (in modalit\u00e0 tocco) o si concentra sull'elemento con i tasti di navigazione o la trackball e tiene premuto il pulsante \"Invio\" o tenere premuto sulla trackball (per un secondo).</p> <p>onFocusChange()Da\u00a0View.OnFocusChangeListener. Questo viene chiamato quando l'utente si avvicina o si allontana dall'elemento utilizzando i tasti di navigazione o la trackball.</p> <p>onKey()da\u00a0View.OnKeyListener. Viene chiamato quando l'utente si concentra sull'elemento e preme o rilascia un tasto hardware sul dispositivo.</p> <p>onTouch()da\u00a0View.OnTouchListener. Questo nome viene chiamato quando l'utente esegue un'azione qualificata come evento touch, ad esempio una stampa, un comunicato stampa o qualsiasi gesto di movimento sullo schermo (entro i limiti dell'elemento).</p> <p>onCreateContextMenu() da\u00a0View.OnCreateContextMenuListener. Questa operazione viene chiamata quando viene creato un menu contestuale (in seguito a un \"clic lungo\") prolungato.</p> <p>Un\u00a0gesto di tocco\u00a0si verifica quando un utente posiziona una o pi\u00f9 dita sul il touchscreen e l\u2019app interpreta questa sequenza di tocchi come un gesto. Il rilevamento dei gesti prevede due fasi:</p> <ol> <li>la raccolta di dati sugli eventi touch</li> <li>l\u2019interpretazione dei dati per determinare se soddisfano i gesti supportati dall\u2019app.</li> </ol> <p>Quando un utente posiziona una o pi\u00f9 dita sullo schermo, viene attivata la callbackonTouchEvent()sulla visualizzazione che riceve gli eventi touch. e per ogni sequenza di tocco viene memorizzata la posizione, pressione, dimensione, il numero di dita usate e altre info utili. Queste info vengono memorizzate nell\u2019oggetto MotionEvent. Il gesto inizia quando l'utente tocca per la prima volta lo schermo, poi continua mentre il sistema tiene traccia della posizione del dito o delle dita dell'utente e termina acquisire l'evento finale dell'ultimo dito dell'utente che lascia lo schermo.</p> <p>Gli eventi, in particolare gli eventi di input come i tocchi, possono essere propagati attraverso la gerarchia delle view. Una View pu\u00f2 consumare un evento o passarlo al suo parent ViewGroup per la gestione. Il sistema Android distribuisce (dispatch) questi eventi ai componenti appropriati per la gestione.</p> <p>Quando si verifica un evento di interazione, si propaga dall'activity andando fino alla view.</p> <p>Quindi a tutti i componenti della gerarchia viene data la possibilit\u00e0 di gestire l'evento, iniziando con la vista in alto e tornando all'attivit\u00e0. Quindi l'activity \u00e8 la prima a ricevere l'evento e l'ultima a cui viene data la possibilit\u00e0 di gestirlo.</p> <p>Se qualche ViewGroup vuole gestire immediatamente l'evento touch, pu\u00f2 restituire true nel suo onInterceptTouchEvent().</p> <p>Una Activity non ha onInterceptTouchEvent() ma pu\u00f2 sovrascrivere dispatchTouchEvent() per fare la stessa cosa.</p> <p>Se una vista (o un gruppo di viste) ha un OnTouchListener, l'evento tocco viene gestito da OnTouchListener.onTouch()</p> <p>Altrimenti \u00e8 gestito da onTouchEvent(). Se onTouchEvent () restituisce true per qualsiasi evento di tocco, la gestione si interrompe. Nessun altro ne ha la possibilit\u00e0.</p> <p>La classe GestureDetector pu\u00f2 essere utilizzata per interpretare sequenze di MotionEvent e dispatchare eventi di gesto specifici (come tap, swipe, fling) a un listener OnGestureListener</p>"},{"location":"30_Frameworks_Tools/Android/10_Gestione_UI_Android/#view-personalizzate","title":"VIEW PERSONALIZZATE","text":"<p>La creazione di nuove visualizzazioni d\u00e0 la possibilit\u00e0 di modellare l'aspetto e il funzionamento delle applicazioni. Creando i propri controlli, si pu\u00f2 creare una interfacce utente che si adatta in modo perfetto ai requisiti.</p> <p>Per creare nuovi controlli da un'area di disegno vuota, si usa la classe base View o SurfaceView.</p> <p>La classe View fornisce un oggetto Canvas con una serie di metodi di disegno e classi Paint. Servono per creare un'interfaccia visiva con bitmap e grafica raster. \u00c8 possibile catturare e sovrascrivere gli eventi utente, inclusi i tocchi dello schermo o la pressione dei tasti per fornire l'interattivit\u00e0.</p> <p>La classe SurfaceView fornisce un oggetto Surface che supporta il disegno da un thread in background e, facoltativamente, l'uso di OpenGL per implementare la grafica.</p> <p>Per creare una view custom dobbiamo fornire la classe:</p> <ol> <li>Costruttori    a. Uno a cui passiamo solo il contesto    b. Contesto e attributi    c. Contesto attributi e stile</li> <li>onMeasure() che viene chiamato quando la view deve essere disegnata. L\u2019incarico di disegnare la view spetta al genitore che chiede al figlio le sue dimensioni: altezza e larghezza, chiamando i metodi della classe del figlio.    a. Questa funzione viene chiamata ogni volta che la view viene invalidata.</li> <li>onDraw() che serve per fare effettivamente il disegno della view. Questa funzione viene chiamata frequentemente e o in modo sincrono in base alla frequenza di refresh impostata dal dispositivo. Se la frequenza di refresh \u00e8 minore del tempo con cui questa funzione viene chiamata si hanno dei problemi nel rendering.</li> </ol>"},{"location":"30_Frameworks_Tools/Android/10_Gestione_UI_Android/#rendering-pipeline","title":"RENDERING PIPELINE","text":"<p>Il processo di rendering \u00e8 sincronizzato con il segnale VSync (vertical synchronization) generato dall'hardware del display scandendo il ritmo del rendering, sincronizzando ogni frame con il refresh dello schermo. Android sfrutta questo segnale per organizzare il lavoro su tre livelli principali:</p> <ol> <li>UI Thread</li> <li>RenderThread</li> <li>Graphics Pipeline.</li> </ol> <p>Il UI Thread, \u00e8 responsabile della gestione degli eventi di input, dell\u2019aggiornamento dell\u2019interfaccia e delle animazioni. Quando il sistema riceve un segnale di VSync, il Choreographer, un componente di Android che orchestra il rendering, sveglia il UI Thread, che esegue una serie di operazioni:</p> <ol> <li>Input Handling \u2192 Il primo compito \u00e8 elaborare gli input dell\u2019utente, come tocchi, scroll o gesti. Se premiamo un pulsante, il sistema deve registrare l\u2019evento e prepararsi a cambiare la UI.</li> <li>Animations \u2192 Se ci sono animazioni in corso (ad esempio, un pulsante che si ingrandisce quando viene premuto), vengono aggiornate e interpolate. Android calcola la nuova posizione, opacit\u00e0 o dimensione dell\u2019elemento animato.</li> <li>Measure e Layout \u2192 Ora il sistema deve capire quanto spazio occupano le View e dove devono essere posizionate. Questo processo avviene in due fasi:    Measure \u2192 Ogni View calcola la propria dimensione basandosi sui suoi genitori e sul contenuto.    Layout \u2192 Una volta note le dimensioni, le View vengono posizionate nella finestra dell\u2019app.</li> <li>Draw \u2192 Dopo aver determinato le posizioni e le dimensioni delle View, il sistema esegue il disegno vero e proprio. Questo avviene nel metodo onDraw(Canvas canvas), che dipinge gli elementi grafici sullo schermo.</li> <li>Sync \u2192 Infine, il UI Thread invia i dati al RenderThread, il quale si occuper\u00e0 di trasformarli in qualcosa che la GPU pu\u00f2 elaborare.</li> </ol> <p>Se una propriet\u00e0 di una view cambia in modo da influire sul suo aspetto viene chiamato il metodo invalidate() sulla vista. Questa chiamata non causa un redraw immediato, ma marca la vista come \"sporca\" e segnala che deve essere ridisegnata. Una volta chiamato invalidate() su una vista, questa chiamata si propaga verso l'alto nella gerarchia delle viste, chiamando una serie di metodi, come invalidateChild(), sui suoi parent.</p> <p>Questo processo continua fino a raggiungere la radice della gerarchia delle viste, in particolare la ViewRootImpl.</p> <p>Quando la dimensione o la posizione di una vista deve cambiare viene chiamato requestLayout(). Questo \u00e8 simile all'invalidazione, ma innesca un processo di misurazione e layout per determinare le nuove dimensioni e posizioni delle viste coinvolte.</p> <p>Quando la chiamata invalidateChild() raggiunge il ViewRootImpl, quest'ultimo non esegue immediatamente il ridisegno ma chiama il metodo scheduleTraversals() con cui pianifica l'esecuzione del processo di traversal (misurazione, layout e disegno) in un momento successivo, tipicamente in sincronia con il prossimo segnale VSync gestito dal Coreoghaph.</p> <p>Per ottimizzare questo processo, Android utilizza un meccanismo chiamato Display List. Quando viene chiamato draw(), la vista (o i suoi antenati) ottiene (o rigenera) una display list tramite il metodo getDisplayList(). Una display list \u00e8 una registrazione di tutte le operazioni di disegno (ad esempio, drawBackground(), drawText()) che la vista deve eseguire per rendersi. L'intera gerarchia delle viste \u00e8 rappresentata da una gerarchia di display list.</p> <p>Dopo che l'UI thread ha completato il traversal (misura, layout e disegno) e ha generato la gerarchia delle Display List, queste informazioni vengono sincronizzate con il Render Thread.</p> <p>Per evitare di sovraccaricare il UI Thread, Android introduce il RenderThread, un thread separato che gestisce il disegno e l\u2019invio dei comandi alla GPU.</p> <p>Una volta che il UI Thread ha terminato il suo lavoro, il RenderThread prende in carico il frame e segue questi passaggi:</p> <ol> <li>Sync \u2192 Riceve i dati dal UI Thread e li sincronizza con lo stato attuale della grafica.</li> <li>Execute \u2192 Processa i comandi di rendering, preparando la scena da inviare alla GPU.</li> <li>Get Buffer \u2192 Recupera un buffer di rendering, ovvero un\u2019area di memoria in cui verr\u00e0 disegnato il frame.</li> <li>Issue \u2192 Converte i comandi in istruzioni per la GPU.</li> <li>Swap Buffer \u2192 Una volta che tutto \u00e8 pronto, il RenderThread invia il frame alla GPU e chiede il prossimo buffer per il frame successivo.</li> </ol> <p>Il Render Thread prende queste Display List, che sono una rappresentazione delle operazioni di disegno a livello Java, e le trasforma in qualcosa che pu\u00f2 effettivamente elaborare per la GPU. Queste rappresentazioni native delle operazioni di disegno sono chiamate Display List Operations (DL ops).</p> <p>Le DL ops sono quindi la forma in cui le intenzioni di disegno dell'applicazione, espresse tramite le API Canvas a livello Java, vengono tradotte in operazioni concrete che il Render Thread pu\u00f2 ottimizzare e inviare alla GPU.</p> <p>Un esempio di DL op \u00e8 una fill operation che corrisponde all'operazione di riempire una determinata area con un colore. Altre DL ops rappresenterebbero il disegno di testo, linee, bitmap, ecc..</p> <p>In sostanza, le DL ops sono un intermediario tra la rappresentazione astratta del disegno (Display List) e i comandi concreti inviati alla GPU.</p> <p>Le DL ops vengono ottimizzate tramite riordinamento (reordering) delle operazioni di disegno.</p> <p>L'obiettivo del riordinamento \u00e8 di raggruppare operazioni di disegno simili che non si sovrappongono per minimizzare i cambi di stato della GPU, che sono operazioni molto costose in termini di prestazioni.</p> <p>Attraverso il riordinamento, il Render Thread analizza le DL ops e, se possibile, le raggruppa. Quindi, tutte le operazioni di disegno dei rettangoli verrebbero eseguite insieme, seguite da tutte le operazioni di disegno del testo. In alcuni casi, operazioni simili possono anche essere batching (raggruppate) ulteriormente in una singola chiamata alla GPU per maggiore efficienza.</p> <p>Questa ottimizzazione pu\u00f2 portare a miglioramenti significativi nelle prestazioni del rendering, specialmente in scenari con molte operazioni di disegno simili, come ad esempio nel rendering di liste complesse.</p> <p>Il riordinamento non pu\u00f2 essere applicato se le operazioni di disegno si sovrappongono, poich\u00e9 in tal caso l'ordine \u00e8 cruciale per rispettare il blending e l'alpha blending.</p> <p>A questo punto, entra in gioco la Graphics Pipeline, ovvero la parte hardware responsabile del rendering finale. Il suo compito \u00e8 prendere i comandi ricevuti dal RenderThread e trasformarli in pixel sullo schermo.</p> <ol> <li>Get Buffer \u2192 La GPU recupera il buffer con i dati da disegnare.</li> <li>Swap Buffer \u2192 Il buffer contenente il nuovo frame viene inviato allo schermo.</li> <li>Composite \u2192 Infine, la GPU compone il frame con altri layer grafici e lo mostra all\u2019utente.</li> </ol> <p>A questo punto interviene il SurfaceFlinger \u00e8 un servizio di sistema responsabile della composizione di tutti i window (finestre) visibili sullo schermo.</p> <p>Ogni finestra ha associata una BufferQueue, una coda di buffer grafici dove risiedono i dati pixel prodotti dall'applicazione (o da altri servizi di sistema). La BufferQueue ha due estremit\u00e0: un produttore, il Window Manager che inserisce i buffer nella coda e un consumatore, l\u2019Activity Manager che li preleva.</p> <p>Quando il render thread chiama swapBuffers, accodando nel queue buffer il buffer renderizzato nella BufferQueue. SurfaceFlinger acquisisce questi buffer pronti per essere composti.</p> <p>SurfaceFlinger comunica con l'Hardware Composer (HWC), che \u00e8 un'astrazione hardware specifica del dispositivo in grado di comporre pi\u00f9 layer (bitmap) in modo molto efficiente, spesso senza utilizzare la GPU, per risparmiare energia. L'HWC decide come gestire ciascun layer:</p> <ul> <li>Se l'HWC supporta il formato pixel del layer e non ci sono troppe trasformazioni complesse, pu\u00f2 gestirlo come un overlay, componendolo direttamente sull'hardware.</li> <li>In alcuni casi, l'HWC potrebbe non essere in grado di gestire un layer come overlay, allora il SurfaceFlinger deve utilizzare la GPU per comporre questi layer in un frame buffer (un buffer di rendering temporaneo) tramite comandi OpenGL, un'API utilizzata in Android per il rendering 2D e 3D.</li> </ul> <p>Indipendentemente dal fatto che la composizione avvenga tramite HWC o GPU, SurfaceFlinger combina tutti i layer visibili (le finestre di tutte le applicazioni, la barra di stato, la barra di navigazione) e invia il risultato all'hardware del display per essere visualizzato.</p>"},{"location":"30_Frameworks_Tools/Android/11_Layout/","title":"11 Layout","text":""},{"location":"30_Frameworks_Tools/Android/11_Layout/#layout","title":"LAYOUT","text":"<p>Alcuni ViewGroup sono designati come layout perch\u00e9 organizzano le View figlie in un modo specifico e sono tipicamente usati come ViewGroup radice.</p> <p>I ViewGroup sono definiti nei file di layout XML, che si trovano nella cartella layout all'interno della cartella res del progetto Android. La gerarchia delle View, con un ViewGroup alla radice, pu\u00f2 diventare complessa in app con molte View sullo schermo. Comprendere questa gerarchia \u00e8 importante per l'efficienza del rendering e la visibilit\u00e0 delle View. \u00c8 possibile esplorare la gerarchia delle View di un'app utilizzando l'Hierarchy Viewer.</p> <p>1. LinearLayout</p> <p>Il LinearLayout organizza le sue View figlie in una singola direzione: verticale o orizzontale. Ogni elemento viene disposto uno dopo l'altro, rispettando l'ordine di dichiarazione. \u00c8 utile quando si desidera una disposizione semplice e sequenziale degli elementi.</p> <p>2. RelativeLayout</p> <p>Il RelativeLayout permette di posizionare le View figlie in relazione tra loro o rispetto al contenitore padre. Ad esempio, un elemento pu\u00f2 essere posizionato alla destra di un altro o allineato al bordo superiore del layout. Questo offre una maggiore flessibilit\u00e0 nella disposizione degli elementi rispetto al LinearLayout.</p> <p>3. FrameLayout</p> <p>Il FrameLayout \u00e8 progettato per contenere una singola View, ma pu\u00f2 gestire anche pi\u00f9 elementi sovrapposti. Le View aggiunte successivamente si posizionano sopra le precedenti, creando un effetto di stratificazione. \u00c8 spesso utilizzato per visualizzare una View principale con elementi sovrapposti, come pulsanti flottanti o indicatori di stato.</p> <p>4. ConstraintLayout</p> <p>Il ConstraintLayout offre un alto grado di flessibilit\u00e0, permettendo di definire vincoli tra le View per determinare la loro posizione e dimensione. Questo layout \u00e8 stato introdotto per semplificare la creazione di interfacce complesse senza nidificare pi\u00f9 layout, migliorando le prestazioni dell'applicazione.</p> <p>6. GridLayout</p> <p>Un GridLayout (o GridLayoutManager per le liste) organizza gli elementi in righe e colonne, creando una struttura a griglia. \u00c8 utile quando si devono mostrare pi\u00f9 elementi con lo stesso peso visivo, come immagini o pulsanti.</p> <p>7. StaggeredGridLayout</p> <p>Uno StaggeredGridLayout \u00e8 simile a un GridLayout, ma con colonne o righe di altezze/larghezze diverse. Questo lo rende perfetto per layout pi\u00f9 dinamici e visivamente accattivanti.</p> <p></p> <p>Il ConstraintLayout \u00e8 un ViewGroup in Android che offre un modo flessibile per disporre e allineare le View figlie all'interno di un layout. Utilizza un sistema di vincoli (constraints) per determinare la posizione e le dimensioni delle sue View figlie.</p> <p>Il ConstraintLayout organizza le View figlie utilizzando punti di ancoraggio, bordi e linee guida per controllare come le View sono posizionate rispetto ad altri elementi nel layout. Un vincolo \u00e8 una connessione o un allineamento a un'altra View, al layout genitore o a una linea guida invisibile.</p> <p>Ciascun vincolo definisce la posizione della vista lungo l'asse verticale o orizzontale; quindi ogni vista deve avere almeno un vincolo per ogni asse, ma spesso ne sono necessari di pi\u00f9.</p> <p>Fissa: specifica una dimensione specifica nella casella di testo seguente o ridimensionando la vista nell'editor.</p> <p>A capo: la visualizzazione si espande solo per adattarsi ai contenuti.</p> <p>Vincoli di corrispondenza: la vista si espande il pi\u00f9 possibile per soddisfare i vincoli su ogni lato, dopo aver tenuto conto dei margini della vista.</p>"},{"location":"30_Frameworks_Tools/Android/12_Modelli_navigazionali/","title":"12 Modelli navigazionali","text":""},{"location":"30_Frameworks_Tools/Android/12_Modelli_navigazionali/#modelli-navigazionali","title":"MODELLI NAVIGAZIONALI","text":"<p>Quando progettiamo l'interfaccia grafica e dobbiamo pensare all\u2019UX perch\u00e9 svolto in azioni troppo complesse tutte in una schermata pu\u00f2 portare l'utente a compiere errori.</p> <p>Pu\u00f2 essere utile dividere una task complessa in pi\u00f9 task semplici e per questo \u00e8 possibile raggruppare task simili in N schermate diverse in modo che l\u2019utente si focalizzi meglio di una singola parte.</p> <p>\u00c8 necessario progettare come l'utente nave di chi e promuovere il way finding cio\u00e8 dare alle persone la possibilit\u00e0 di orientarsi e di muoversi all'interno delle schermate.</p> <p>La navigazione si era voluta anche a capire le informazioni, cosa pu\u00f2 fare, dov'\u00e8 ora, dove pu\u00f2 andare e come tornare indietro.</p> <p>Per aiutare gli utenti a navigare necessario usare elementi di segnaletica per aiutare l'utente a orientarsi.</p> <ul> <li>Indicatori di avanzamento</li> <li>Barre di stato</li> <li>Breadsceumbs</li> </ul> <p>La navigazione \u00e8 un overhead perch\u00e9 richiede tempo e risorse per realizzarle in quanto si potrebbe realizzare tutto in una singola schermata ma il motivo per cui si venne a realizzare \u00e8 di ridurre il carico cognitivo, lo sforzo mentale \u00e8 caduta anni fa per elaborare le informazioni. Dobbiamo raggruppare task simili perch\u00e9 troppe task che svolgono operazioni diverse ma anche troppe che ne svolgono simili portano all'utente a compiere errori e lapsus perch\u00e9 secondo le scienze cognitive l'uomo non riesce a concentrarsi pi\u00f9 su pi\u00f9 di sette oggetti alla volta.</p> <p>Fully Connected Navigation Ogni sezione dell\u2019interfaccia pu\u00f2 portare direttamente a qualsiasi altra. Questo tipo di navigazione \u00e8 utile quando si vuole offrire massima libert\u00e0 all\u2019utente. Tuttavia, c\u2019\u00e8 un rischio che se tutto \u00e8 collegato a tutto, pu\u00f2 diventare difficile capire dove si \u00e8 e dove si sta andando. Serve dunque una forte coerenza visiva, una buona architettura dell\u2019informazione e magari qualche aiuto visivo come breadcrumb o menu ben organizzati.</p> <p>Multilevel NavigationSi basa su una struttura gerarchica dei contenuti, dividendolo in categorie</p> <p>Aiuta l\u2019utente a orientarsi e a trovare ci\u00f2 che cerca seguendo un percorso logico per\u00f2 troppi livelli possono diventare dispersivi, quindi \u00e8 bene non esagerare con la profondit\u00e0 della struttura.</p> <p>Step-by-Step Flows Utilizzati per guidare l\u2019utente in un processo lineare, come una registrazione, un acquisto online, o la configurazione di un profilo. Semplifica l\u2019interazione perch\u00e9 ogni passo \u00e8 chiaro, focalizzato, e l\u2019utente sa sempre cosa deve fare. L'importante \u00e8 rendere visibile il progresso, con indicatori e consentire di tornare indietro senza perdere i dati inseriti.</p> <p></p> <p>Pyramidal Model SI parte da un\u2019informazione generale e consente all\u2019utente di esplorare via via contenuti sempre pi\u00f9 specifici. Funziona bene quando si vuole gestire l\u2019attenzione dell\u2019utente e accompagnarlo in una lettura a livelli, senza sommergerlo subito di dettagli.</p> <p>Deep Link A volte non si parte dalla cima ma ci si ritrova direttamente \u201call\u2019interno\u201d dell\u2019app, grazie a un deep link, cio\u00e8 un collegamento diretto a una pagina interna. Devono essere progettati con cura, perch\u00e9 l\u2019utente che ci arriva potrebbe non avere il contesto: \u00e8 quindi importante che la pagina sia autonoma, comprensibile da sola.</p> <p>Clear Entry Point Cio\u00e8 una porta d\u2019ingresso ben visibile e comprensibile per l\u2019utente. Appena apre l\u2019app o il sito, l\u2019utente deve capire cosa pu\u00f2 fare, dove pu\u00f2 andare e quali sono le opzioni principali.Questo vale soprattutto per esperienze nuove o complesse, dove una schermata iniziale troppo carica o confusa rischia di scoraggiare. Meglio semplificare, dare una direzione e lasciare che il resto venga scoperto poco alla volta.</p> <p>Hub and Spoke L\u2019utente parte da un hub e da l\u00ec pu\u00f2 accedere a diverse spoke, sezioni o attivit\u00e0 isolate. Una volta completata un\u2019attivit\u00e0, torna all\u2019hub per decidere cosa fare dopo.</p> <p>Questo approccio \u00e8 utile quando si vuole mantenere un senso di controllo e di orientamento.</p>"},{"location":"30_Frameworks_Tools/Android/1_Android_OS/","title":"Android","text":"<p>Android \u00e8 un sistema operativo sviluppato da Google basato su Linux e progettato per dispositivi mobile \u00e8 un sistema operativo open source . Quindi il suo codice sorgente \u00e8 pubblico e pu\u00f2 essere modificato da sviluppatori e produttori di hardware per creare la propria versione di Android e adattarlo a loro dispositivo, Il problema di questo \u00e8 che ci\u00f2 porta a una frammentazione eccessiva delle versioni e questo causa problemi quando dobbiamo sviluppare delle applicazioni, perch\u00e9 dobbiamo individuare il numero di dispositivi compatibili con la versione che dovremo sviluppare. Android cerca di risolvere il problema di compatibilit\u00e0 creando degli appositi librerie che si possono utilizzare con andiamo a sviluppare il codice</p> <p>Google gestisce il rilascio delle nuove versioni di Android sia per i propri dispositivi, la cui distribuzione avviene in maniera abbastanza rapida sia per gli altri dispositivi di altri produttori. Il sistema operativo di questi seguire. Deve seguire un processo di qualifica da parte di Google. Questo vuol dire che ogni qualvolta che Google rilascia un aggiornamento ogni produttore deve adattarlo al proprio hardware del dispositivo e questo richiede molto tempo perch\u00e9 modificano anche l\u2019interfaccia. Una volta che hanno effettuato queste modifiche la versione deve essere approvata da Google per garantire che soddisfi standard di qualit\u00e0 compatibilit\u00e0 e sicurezza se si superano questi test al loro i produttori potranno rilasciare il loro aggiornamento per i loro dispositivi.</p>"},{"location":"30_Frameworks_Tools/Android/1_Android_OS/#android-os","title":"Android OS","text":"<p>Il sistema Android \u00e8 interamente sviluppato sopra al kernel Linux. Il motivo di questa scelta \u00e8 dovuto al fatto che non sarebbero mai stati in grado di sviluppare un sistema completamente funzionante in tempi rapidi per poter entrare nel mercato. Linux era gi\u00e0 un sistema operativo pienamente funzionante sotto ogni aspetto e che funzionava in modo molto efficiente e quindi l\u2019idea di Google fu quello di estendere il sistema operativo Linux per adattarlo ai dispositivi mobile.</p>"},{"location":"30_Frameworks_Tools/Android/1_Android_OS/#linux-kernel","title":"Linux Kernel","text":"<p>Questo livello fornisce i servizi di gestione dell'hardware. A questo livello, viene applicato uno schema di protezione per limitare l'accesso ai dati e alle risorse e consentirlo solo ai processi che posseggono l'adeguato livello di autorizzazione. Vi sono i moduli per la gestione della memoria, dei processi, del sistema di archiviazione e della comunicazione sulla rete. Vi sono i driver per la gestione dell'hardware in dotazione al dispositivo, ad esempio la memoria ausiliaria, la radio, la fotocamera. Oltre ai servizi offerti dal nucleo del sistema operativo, il kernel di Android include alcuni componenti particolari, quali ad esempio il sistema di risparmio energetico, il sistema di gestione e condivisione della memoria, un meccanismo di comunicazione tra processi chiamato binder, che permette ai processi di condividere dati e servizi.</p> <p></p>"},{"location":"30_Frameworks_Tools/Android/1_Android_OS/#hardware-abstraction-level","title":"Hardware Abstraction Level","text":"<p>Sopra al kernel troviamo HAL che fornisce interfacce standard per esporre le funzionalit\u00e0 hardware del dispositivo al framework API di livello superiore. HAL \u00e8 formato da pi\u00f9 moduli, ognuno dei quali implementa un\u2019interfaccia per un tipo di componente hardware Linux . quando il framework fa una chiamata per accedere all\u2019hardware del dispositivo Android carica il modulo di libreria di quella componente. I moduli sono scritti dal produttore.</p>"},{"location":"30_Frameworks_Tools/Android/1_Android_OS/#android-runtime","title":"Android RunTime","text":"<p>L\u2019Android Runtime \u00e8 composto dalla macchina virtuale ART (che ha sostituito Dalvik) e dalle librerie principali del sistema. ART \u00e8 un ambiente di esecuzione in cui ogni app viene eseguita nel proprio processo, con una propria istanza di ART.</p> <p>ART traduce il codice scritto in Java o Kotlin in bytecode, che viene poi convertito in codice nativo comprensibile dal processore del dispositivo. Utilizza principalmente un approccio di compilazione Ahead-of-Time (AOT): quando si installa una nuova app, questa viene compilata in codice nativo gi\u00e0 durante la fase di installazione, migliorando cos\u00ec le performance in fase di esecuzione.</p> <p>Inoltre, ART pu\u00f2 usare la modalit\u00e0 Just-In-Time (JIT) per compilare dinamicamente solo alcune parti del codice durante l\u2019esecuzione dell\u2019app, migliorando la reattivit\u00e0 e riducendo i tempi di compilazione iniziale.</p>"},{"location":"30_Frameworks_Tools/Android/1_Android_OS/#native-cc-library-ndk","title":"Native C/C++ Library NDK","text":"<p>Sempre sopra ad HAL troviamo le NDK strumenti per sviluppare app in C/C++. Sono utili per implementare funzionalit\u00e0 che richiedono altre performance o se dobbiamo implementare parte di codice che devono comunicare direttamente con l\u2019hardware.</p>"},{"location":"30_Frameworks_Tools/Android/1_Android_OS/#java-api-framework","title":"Java API Framework","text":"<p>Sopra ai livelli di Android Runtime e HAL troviamo il Java API Framework, un insieme di librerie, classi e interfacce scritte in Java/Kotlin che permettono di interagire facilmente con le funzionalit\u00e0 hardware e software del dispositivo.</p> <p>Questo livello \u00e8 progettato per semplificare lo sviluppo delle app, fornendo un accesso ad alto livello alle componenti del sistema operativo Android</p> <p>Le API mettono a disposizione implementazioni predefinite delle componenti fondamentali del sistema, che possono essere estese e personalizzate dagli sviluppatori per costruire le funzionalit\u00e0 specifiche dell'app.</p>"},{"location":"30_Frameworks_Tools/Android/1_Android_OS/#applicazioni","title":"Applicazioni","text":"<p>Sopra questo livello troviamo le applicazioni dell\u2019utente.</p>"},{"location":"30_Frameworks_Tools/Android/1_Android_OS/#android-sdk","title":"Android SDK","text":"<p>L\u2019android software development kit ASDK \u00e8 un set di librerie e strumenti per sviluppare un app android. I tool si dividono in;</p> <ul> <li>SDK platform, tools platform dependent. Una nuova versione di queste \u00e8 rilasciata ad ogni versione di android e include librerie, codici sorgenti ecc</li> <li>SDK tools che sono platform indipendent. Sono strumenti usati per sviluppare , farete bugno a disposizione un emulatore per simulate un dispositivo mobile. Ha un android Debug Brigde che permette di comunicare con il dispositivo per eseguire operazioni varie per fare testing e debug.</li> </ul>"},{"location":"30_Frameworks_Tools/Android/2_Compilazione_app/","title":"Compilazione app Android","text":"<p>Per quanto riguarda la compilazione di un app android prima di generare il bytecode, le risorse usate nel processo vengono analizzate indicizzate e compilate in bytecode, ottimizzato per la piattaforma punto la componente. La componente che si occupa di fare questo \u00e8 AAPT2 che opera il modo incrementale cio\u00e8 compila le risorse e linka tutti i file intermedi generati dalla compilazione. Produce la classe R.java che contiene tutte le risorse compilate a cui sono associate un ID con il quale si pu\u00f2 far riferimento alla risorsa.</p> <p>Viene generato il bytecode del codice Java/Kotlin.</p> <p>La componente AIDL definisce l\u2019interfaccia di programmazione concordata dal client e server per comunicare fra loro usando IPC. Il motivo di ci\u00f2 \u00e8 che ogni app, anche se viene eseguita sullo stesso dispositivo, e un processo separato e quindi pu\u00f2 accedere solo alle zone di memoria che le sono state riservate.</p> <p>Android usa un meccanismo nativo chiamato Binder per gestire la comunicazione tra processi. \u00c8 una tecnologia di basso livello, integrata nel kernel di Linux, che permette a un processo di:</p> <ul> <li>Fare richieste a un altro processo</li> <li>Ricevere risposte come se fossero normali chiamate di funzione</li> </ul> <p>Con tutte queste parti si viene a creare il .class cio\u00e8 il file bytecode Java che per\u00f2 non pu\u00f2 essere ancora utilizzato ma deve essere ottimizzato dalla componente DEX/ART creando un file .dex eseguibile su ART VM.</p> <p>Una volta pronti i file .dex e le risorse, lo strumento apkbuilder li unisce per creare il file .apk, cio\u00e8 il pacchetto installabile dell\u2019app Android. Dentro questo .apk troviamo:</p> <ul> <li>I file .dex</li> <li>Le risorse compilate (.arsc)</li> <li>I file non compilati (come asset, immagini, XML di layout)</li> <li>Il file AndroidManifest.xml</li> </ul> <p>Prima che un'app venga installata su un dispositivo, deve essere firmata digitalmente. Questo garantisce due cose fondamentali:</p> <ul> <li>Autenticit\u00e0: conferma che l\u2019app \u00e8 stata creata da chi dice di averla creata.</li> <li>Integrit\u00e0: assicura che il file non sia stato modificato dopo la firma.</li> </ul> <p>a) Firma con jarsigner</p> <p>La firma avviene usando uno keystore, ovvero un contenitore sicuro di chiavi crittografiche. Con jarsigner, il pacchetto .apk viene firmato utilizzando una chiave privata.</p> <ul> <li>Si calcola un hash del contenuto dell\u2019app.</li> <li>Questo hash viene poi cifrato con la chiave privata \u2192 questo \u00e8 ci\u00f2 che chiamiamo firma digitale.</li> <li>La firma viene allegata all\u2019app.</li> </ul> <p>b) Allineamento con zipalign</p> <p>Dopo la firma, si utilizza lo strumento zipalign per ottimizzare l\u2019accesso alle risorse del pacchetto. Questo \u00e8 un passo importante, soprattutto per app in produzione, perch\u00e9 migliora le prestazioni e riduce il consumo di memoria.</p> <p>Quando un dispositivo Android riceve un\u2019app firmata, esegue la verifica della firma:</p> <ul> <li>Estrae l\u2019hash dal file firmato.</li> <li>Ricalcola l\u2019hash con il contenuto dell\u2019app.</li> <li>Usa la chiave pubblica per verificare che la firma corrisponda all\u2019hash originale.</li> </ul> <p>Se i due hash corrispondono, l\u2019app \u00e8 autentica e non \u00e8 stata manomessa \u2192 viene installata. Se non combaciano, il sistema rifiuta l\u2019installazione.</p> <ul> <li>Durante lo sviluppo, Android Studio firma automaticamente l\u2019app con una chiave debug.</li> <li>Per pubblicare l\u2019app sul Play Store, devi firmarla con una chiave di release generata da te. \u00c8 fondamentale non perdere questa chiave, perch\u00e9 ti servir\u00e0 per aggiornare l\u2019app in futuro.</li> </ul> <p></p>"},{"location":"30_Frameworks_Tools/Android/2_Compilazione_app/#avvio-di-unapplicazione-android","title":"Avvio di un'applicazione Android","text":"<p>Il processo di avvio di un'applicazione Android inizia quando l'utente o un altro componente di sistema richiede l'esecuzione di un componente dell\u2019app. Se l'applicazione non \u00e8 gi\u00e0 in esecuzione, il sistema Android avvia un nuovo processo per essa.</p> <p>Ogni app Android viene eseguita nel proprio processo Android, che \u00e8 un processo Linux con un thread di esecuzione iniziale.</p> <p>Il processo di avvio del sistema include l'avvio dell'init process, che a sua volta genera processi Linux di basso livello chiamati daemon. L'init process avvia un processo chiamato Zygote che inizializza la prima istanza della Dalvik Virtual Machine e precarica tutte le classi comuni utilizzate dal framework Android e dalle varie app installate. In questo modo, si prepara a essere replicato e inizia ad ascoltare su un'interfaccia socket per richieste future di generare nuove macchine virtuali per i processi delle nuove applicazioni. Quando riceve una nuova richiesta, Zygote effettua un fork di se stesso per creare un nuovo processo che ottiene un'istanza VM pre-inizializzata. Dopo Zygote, l'init avvia il runtime process, e Zygote esegue un fork per avviare un processo ben gestito chiamato system server. Il system server avvia tutti i servizi principali della piattaforma, come l'Activity Manager Service e i servizi hardware, nel proprio contesto.</p> <p>A questo punto, lo stack completo \u00e8 pronto per avviare il primo processo dell'app: l'app Home, nota anche come Launcher.</p> <p>Quando un utente fa clic sull'icona di un'app nel Launcher, l'evento di clic viene tradotto in startActivity(intent) e viene indirizzato all'ActivityManagerService tramite Binder IPC. L'ActivityManagerService esegue diverse operazioni:</p> <ol> <li>Raccoglie informazioni sul target dell'oggetto intent utilizzando il metodo resolveIntent() sull'oggetto PackageManager, con i flag PackageManager.MATCH_DEFAULT_ONLY e PackageManager.GET_SHARED_LIBRARY_FILES utilizzati per impostazione predefinita.</li> <li>Salva le informazioni sul target nell'oggetto intent per evitare di ripetere questo passaggio.</li> <li>Verifica se l'utente ha privilegi sufficienti per richiamare il componente target dell'intent chiamando il metodo grantUriPermissionLocked().</li> <li>Se l'utente ha le autorizzazioni necessarie, l'ActivityManagerService verifica se l'attivit\u00e0 target richiede di essere avviata in un nuovo task, in base ai flag dell'Intent come FLAG_ACTIVITY_NEW_TASK e FLAG_ACTIVITY_CLEAR_TOP.</li> <li>Verifica se esiste gi\u00e0 un ProcessRecord per il processo. Se il ProcessRecord \u00e8 null, l'ActivityManager deve creare un nuovo processo per istanziare il componente target.</li> </ol> <p>L\u2019ASM crea un nuovo processo invocando il metodo startProcessLocked(), che invia argomenti al processo Zygote tramite la connessione socket. Zygote esegue un fork di se stesso e chiama ZygoteInit.main(), che a sua volta istanzia un oggetto ActivityThread e restituisce l'ID del processo appena creato. Ogni processo ottiene un thread per impostazione predefinita. Il thread principale ha un'istanza Looper per gestire i messaggi da una coda di messaggi e chiama Looper.loop() in ogni iterazione del suo metodo run(). Il Looper estrae i messaggi dalla coda e richiama i metodi corrispondenti per gestirli. ActivityThread avvia quindi il message loop chiamando Looper.prepareLoop() e successivamente Looper.loop().</p> <p>Il passo successivo consiste nell'associare questo processo appena creato a un'applicazione specifica. Ci\u00f2 avviene chiamando bindApplication() sull'oggetto thread. Questo metodo invia un messaggio BIND_APPLICATION alla coda dei messaggi. Questo messaggio viene recuperato dall'oggetto Handler, che quindi invoca il metodo handleMessage() per attivare l'azione specifica del messaggio: handleBindApplication(). Questo metodo invoca makeApplication(), che carica le classi specifiche dell'app in memoria.</p> <p></p> <p>Dopo il binding, il sistema contiene il processo responsabile dell'applicazione con le classi dell'applicazione caricate nella memoria privata del processo. Il processo effettivo di avvio inizia nel metodo realStartActivity(), che chiama scheduleLaunchActivity() sull'oggetto thread dell'applicazione. Questo metodo invia un messaggio LAUNCH_ACTIVITY alla coda dei messaggi. Il messaggio viene gestito dal metodo handleLaunchActivity(). L'Activity inizia il suo ciclo di vita .</p> <p></p>"},{"location":"30_Frameworks_Tools/Android/3_Activity_e_Fragment/","title":"Activity","text":"<p>Un'Activity \u00e8 una componente visibile di un'applicazione Android che permette agli utenti di interagire con essa. Un'app pu\u00f2 essere composta da pi\u00f9 Activity, ciascuna delle quali svolge un compito specifico ed \u00e8 indipendente dalle altre. Ogni Activity \u00e8 formata da una serie di View, ovvero gli elementi dell'interfaccia utente</p>"},{"location":"30_Frameworks_Tools/Android/3_Activity_e_Fragment/#ciclo-di-vita-di-unactivity","title":"Ciclo di vita di un'Activity","text":"<p>Il sistema operativo Android gestisce il ciclo di vita di un'Activity, determinando quando questa viene creata, avviata, arrestata o distrutta. La classe Activity fornisce diversi metodi di callback che permettono agli sviluppatori di definire il comportamento dell'applicazione nei vari stati dell'Activity.</p> <p></p> <p>L\u2019activity pu\u00f2 essere avviata dall\u2019utente che preme sull\u2019icona dell\u2019applicazione, oppure da un\u2019altra activity tramite un intent.</p> <p>Quando un'app viene avviata Zygote clona se stesso per creare un nuovo processo, riducendo il tempo di avvio. Questo nuovo processo eredita le classi e le librerie gi\u00e0 caricate, ottimizzando l'esecuzione.</p> <p>L'ActivityManagerService (AMS) \u00e8 il componente principale che gestisce il ciclo di vita delle Activity e coordina le transizioni tra di esse.</p> <ul> <li>Riceve la richiesta di avvio dell'app.</li> <li>Controlla se il processo dell\u2019app \u00e8 gi\u00e0 in esecuzione o se deve essere creato.</li> <li>Comunica con il Zygote per avviare un nuovo processo se necessario.</li> </ul> <p>Dopo l\u2019avvio dell\u2019app, vengono chiamate tre metodi per creare un activity.</p> <ol> <li>onCreate() in questo momento l\u2019activity viene effetivamente creata e in questa fase si inizializzano tutte le risorse necessarie. Viene carocato in memoria l\u2019albero delle views che formano l\u2019activity.    La onCreate() di un'Activity non deve essere bloccante perch\u00e9 viene eseguita nel Main Thread, lo UI Thread. Questo thread \u00e8 responsabile della gestione dell\u2019interfaccia utente e dell\u2019interazione con l\u2019utente. Se il codice in onCreate() \u00e8 troppo pesante Android termina forzatamente le app che bloccano il Main Thread.</li> <li>Subito dopo, Android chiama il metodo onStart() che permette all\u2019Activity di essere visibile all\u2019utente, ma non \u00e8 ancora interattiva. L\u2019interfaccia viene renderizzata visualizzando le componenti che formano l\u2019activity.</li> <li>Con l\u2019invocazione di onResume() l\u2019Activity diventa pienamente attiva e interattiva e l\u2019utente pu\u00f2 effetti interagire con le componenti dell\u2019appliczione. Gli event generati vengono catturati dal looper e fa cambiare stato all\u2019activity. Durante questa fase, l\u2019Activity \u00e8 in primo piano e qualsiasi altra Activity aperta in precedenza \u00e8 stata messa in pausa o nascosta.</li> </ol> <p>Dopo queste tre operazioni l\u2019applicazione si trova nello stato di running e l\u2019utente pu\u00f2 interagire. Se l'utente non interagisce l\u2019activity passa in uno stato di onPause(), che indica che l\u2019activity non \u00e8 pi\u00f9 in primo piano, ma questo non vuol dire che debba essere distrutta.</p> <p>Quando la tua attivit\u00e0 non \u00e8 pi\u00f9 visibile all'utente, ma \u00e8 ancora in memoria viene invocata la chiamata onStop() e da qui inizia il ciclo di distruzione e rilascio delle risorse dell\u2019activity.</p> <p>La differenza tra onStop() e onPause() \u00e8 che nella onPause() il lavoro relativo all'interfaccia utente continua anche se l'utente sta visualizzando la tua attivit\u00e0 in modalit\u00e0 multi-finestra.</p> <p>Con la onRestart() tato transitorio si verifica solo se un'Activity fermata viene riavviata. onRestart() viene chiamato tra onStop() e onStart(). onDestroy() viene chiamato prima che l'Activity venga distrutta. Questo pu\u00f2 avvenire perch\u00e9 l'Activity sta terminando, perch\u00e9 il sistema sta distruggendo l'Activity per risparmiare risorse, o a causa di un cambiamento di configurazione. \u00c8 importante eseguire qui la pulizia finale delle risorse. Tuttavia, non si dovrebbe fare affidamento su onDestroy() per salvare dati importanti, in quanto potrebbe non essere sempre chiamato.</p>"},{"location":"30_Frameworks_Tools/Android/3_Activity_e_Fragment/#back-stack-e-navigazioene-fra-le-app","title":"Back stack e navigazioene fra le app","text":"<p>In Android, le Activity sono gestite attraverso uno stack di Activity, il back stack, gestito in modo FIFO.</p> <p>Il back stack \u00e8 un insieme di Activity che l'utente ha visitato e a cui pu\u00f2 tornare premendo il pulsante Indietro del dispositivo. Una task \u00e8 un insieme di Activity correlate all'applicazione o ad una specifica interazione dell'utente e ha il suo back stack e che possiamo gestire insieme.</p> <p>Quando si avvia una nuova Activity, essa viene inserita in cima al back stack e prende il focus dell'utente. L'Activity precedente viene fermata ma rimane disponibile nel back stack, conservando il suo stato attuale. Quando l'utente preme il pulsante Indietro, l'Activity in cima allo stack viene rimossa (e distrutta), e l'Activity precedente riprende.</p> <p>Alla base dello stack sta il launcher e da questo si iniziano ad impilare le activity. Android non rimuover\u00e0 mai le activity tranne se si trova in situazioni critiche del sistema e allora rimuove prima le activity che si trovano in fondo allo stack, evitando di rimuove l\u2019activity attiva.</p> <p>Il back stack non \u00e8 specifico di una singola applicazione; pu\u00f2 contenere Activity di diverse applicazioni lanciate dall'utente in ordine cronologico inverso. Ci\u00f2 significa che premendo il pulsante Indietro, l'utente potrebbe ritrovarsi in un'Activity di un'altra app se l'ha avviata precedentemente.</p> <p></p> <p>Un\u2019activity pu\u00f2 spostarsi\u00a0inbackground\u00a0quando un utente avvia una nuova attivit\u00e0 o passa alla schermata Home. In background, tutte le attivit\u00e0 dell'attivit\u00e0 vengono arrestate, ma lo stack precedente dell'attivit\u00e0 rimane intatto, perde l'attenzione mentre \u00e8 in corso un'altra attivit\u00e0. R l'attivit\u00e0 pu\u00f2 tornare in primo piano per consentire agli utenti di riprendere da dove hanno interrotto disattivata.</p> <p>Le activity nel back-stack non vengono mai riorganizzate, ma \u00e8 possibili modificare questo andamento lineare dello stack perch\u00e9 in certe situazioni questa gestione non va bene. Esistono cinque modalit\u00e0 di lancio che si possono assegnare all'attributo\u00a0launchMode:</p> <ol> <li>Standard La modalit\u00e0 predefinita. Il sistema crea una nuova istanza dell'attivit\u00e0 nell'attivit\u00e0 da cui \u00e8 stato avviato e instrada l'intent a quest'ultimo. L'attivit\u00e0 pu\u00f2 essere creata pi\u00f9 volte, ogni istanza pu\u00f2 appartenere ad attivit\u00e0 diverse un'attivit\u00e0 pu\u00f2 avere pi\u00f9 istanze.</li> <li>SingleTopSe nella parte superiore dell'attivit\u00e0 corrente esiste gi\u00e0 un'istanza dell'attivit\u00e0, il sistema instrada l'intent a quell'istanza tramite una chiamata alla sua\u00a0onNewIntent()\u00a0anzich\u00e9 creare una nuova istanza dell'attivit\u00e0. L'attivit\u00e0 \u00e8 creata pi\u00f9 volte, ogni istanza pu\u00f2 appartenere ad attivit\u00e0 diverse e un'attivit\u00e0 pu\u00f2 avere pi\u00f9 istanze (ma solo se l'attivit\u00e0 in alto dello stack posteriore\u00a0non\u00a0\u00e8 un'istanza esistente dell'attivit\u00e0).</li> <li>singleTask Il sistema crea l'attivit\u00e0 alla base di una nuova attivit\u00e0 o individua la su un'attivit\u00e0 esistente con la stessa affinit\u00e0. Se un'istanza del componente esiste gi\u00e0 un'attivit\u00e0, il sistema instrada all'istanza esistente tramite una chiamata alla sua onNewIntent() anzich\u00e9 creare una nuova istanza. Nel frattempo, tutti gli altri vengono distrutte.</li> <li>singleInstance Il comportamento \u00e8 lo stesso di\u00a0\"singleTask\", ad eccezione del fatto che il sistema non avvia nessun altro delle attivit\u00e0 nell'attivit\u00e0 che contiene l'istanza. L'attivit\u00e0 \u00e8 sempre l'unico e unico membro della sua attivit\u00e0. Tutte le attivit\u00e0 iniziate da questa si aprono tra per un'attivit\u00e0 a parte.</li> <li>singleInstancePerTask L'attivit\u00e0 pu\u00f2 essere eseguita solo come attivit\u00e0 principale dell'attivit\u00e0, la prima all'attivit\u00e0 che ha creato l'attivit\u00e0, perci\u00f2 pu\u00f2 esserci una sola istanza di questa attivit\u00e0 in un'attivit\u00e0. A differenza della modalit\u00e0 di avvio di\u00a0singleTask, questa l'attivit\u00e0 pu\u00f2 essere avviata in pi\u00f9 istanze in diverse attivit\u00e0 se\u00a0FLAG_ACTIVITY_MULTIPLE_TASK\u00a0o\u00a0FLAG_ACTIVITY_NEW_DOCUMENT\u00a0\u00e8 stato impostato.</li> </ol> <p>SingleTask e SingleInstancePerTask\u00a0rimuovono tutte le attivit\u00e0 superiori all'attivit\u00e0 iniziale dell'attivit\u00e0.</p> <p>I cambiamenti di configurazione, come la rotazione dello schermo, comportano la distruzione dell'Activity corrente e la creazione di una nuova Activity per adattarsi alla nuova configurazione. Per evitare la perdita di dati durante questi cambiamenti, \u00e8 possibile salvare lo stato dell'istanza dell'Activity.</p> <ol> <li>sovrascrivendo il metodo onSaveInstanceState(Bundle). Lo stato viene salvato come una serie di coppie chiave/valore in un oggetto Bundle che viene passato a onCreate() quando l'Activity viene ricreata. \u00c8 anche possibile utilizzare il callback onRestoreInstanceState() per ripristinare lo stato.</li> <li>Oppure con il model-view-controller</li> </ol>"},{"location":"30_Frameworks_Tools/Android/3_Activity_e_Fragment/#fragment","title":"Fragment","text":"<p>Un Fragment \u00e8 un componente utilizzato per dividere l'interfaccia utente in parti pi\u00f9 piccole. Un Fragment rappresenta una porzione di UI o di comportamento che vive all\u2019interno di un\u2019Activity, e pu\u00f2 essere riutilizzato o sostituito dinamicamente. Un Fragment riceve i propri eventi di input e ha una propria vista che viene composta da un file di layout apposito. I Fragment possono esistere solo all'interno di un'Activity. Un'attivit\u00e0 pu\u00f2 delegare a un fragment l'esecuzione di compiti.</p> <p>Le Activity fungono da host per i Fragment queste devono conoscere i dettagli di come ospitare i loro Fragment, ma i Fragment non devono conoscere i dettagli delle Activity che le ospitano (loosely couple). Come le attivit\u00e0, i fragment sono \"attivi\" quando appartengono ad una activity focalizzata e in primo piano.</p> <p>Quando un'attivit\u00e0 viene messa in pausa o interrotta, anche i frammenti che contiene vengono messi in pausa e arrestati e anche i frammenti contenuti in un'attivit\u00e0 inattiva sono inattivi.</p> <p>Quando un'attivit\u00e0 viene finalmente distrutta, ogni Fragment che contiene viene ugualmente distrutto. Poich\u00e9 il gestore della memoria Android chiude regolarmente le applicazioni per liberare risorse, anche i frammenti all'interno di tali attivit\u00e0 vengono distrutti.</p> <p>Non dovrebbe esserci alcuna differenza nel passaggio di un frammento da uno stato scollegato, in pausa, interrotto o inattivo allo stato attivo, quindi \u00e8 importante salvare tutto lo stato dell'interfaccia utente e conservare tutti i dati</p> <p>quando un frammento viene sospeso o interrotto. Come un'activity, quando un frammento diventa di nuovo attivo, dovrebbe ripristinare lo stato salvato.</p> <p></p> <p>Always Use Fragments (AUF): una regola informale che suggerisce di preferire i Fragment alle Activity quando possibile.</p> <p>I Fragment hanno anche un proprio ciclo di vita che \u00e8 simile a quello di un'attivit\u00e0. Questo \u00e8 importante perch\u00e9, visto che un fragment lavora per conto di un'attivit\u00e0, il suo stato dovrebbe riflettere lo stato dell'attivit\u00e0. Pertanto, ha bisogno di metodi del ciclo di vita corrispondenti per gestire il lavoro dell'attivit\u00e0.</p> <p>I callback del ciclo di vita di un Fragment includono</p> <ul> <li>onCreateView(): il valore restituito di questo metodo deve essere un'istanza di View affinch\u00e9 il Fragment abbia un'interfaccia utente visibile</li> <li>onDestroyView(): Ci sono anche callback per onActivityCreated e callback che vengono attivati quando un Fragment viene aggiunto (onAttached) a o rimosso (onDetached) dall'UI utilizzando i metodi di FragmentTransaction.</li> <li>I metodi onAttach(Activity), onCreate(Bundle) e onCreateView(...) vengono chiamati quando si aggiunge il fragment al FragmentManager.</li> <li>Il metodo onActivityCreated(...) viene chiamato dopo che il metodo onCreate(...) dell'attivit\u00e0 ospitante \u00e8 stato eseguito.</li> <li>Il FragmentManager di un'attivit\u00e0 \u00e8 responsabile della chiamata dei metodi del ciclo di vita dei fragment nella sua lista.</li> </ul> <p>La vista di un fragment viene generalmente inflata nel metodo onCreateView().</p> <p>Per aggiungere un fragment a un'attivit\u00e0 nel codice, si effettuano chiamate esplicite al FragmentManager dell'attivit\u00e0 che \u00e8 responsabile della gestione dei fragment e dell'aggiunta delle loro viste alla gerarchia delle viste dell'attivit\u00e0.</p> <p>Il FragmentManager gestisce due cose:</p> <ul> <li>un elenco di fragment</li> <li>stack di back delle transazioni di fragment.</li> </ul> <p>Per ottenere il FragmentManager, si usa</p> <ul> <li>getSupportFragmentManager(), se si estende AppCompatActivity o FragmentActivity;</li> <li>getFragmentManager(), se si estende Activity e il fragment estende android.app.Fragment o PreferenceFragment).</li> </ul> <p>Le FragmentTransaction vengono utilizzate per aggiungere, rimuovere, allegare, staccare o sostituire i fragment nell'elenco dei fragment in fase di runtime. Il FragmentManager mantiene uno stack di back delle transazioni di fragment su cui \u00e8 possibile navigare.</p> <p>Il metodo FragmentManager.beginTransaction() crea e restituisce un'istanza di FragmentTransaction. La classe FragmentTransaction utilizza una fluent interface: i metodi che configurano FragmentTransaction restituiscono un FragmentTransaction invece di void, il che consente di concatenarli.</p> <ul> <li>Il metodo add() della FragmentTransaction ha due parametri: un ID del container view e il newFragment. L'ID del container view \u00e8 l'ID risorsa del FrameLayout definito nel layout dell'attivit\u00e0. Un ID del container view ha indica al FragmentManager dove nella vista dell'attivit\u00e0 dovrebbe apparire la vista del fragment e viene utilizzato come identificatore univoco per un fragment nell'elenco del FragmentManager.</li> </ul> <p>Quando \u00e8 necessario recuperare il Fragment dal FragmentManager, lo si richiede tramite l'ID del container view utilizzando fm.findFragmentById(R.id.fragment_container).</p> <p>\u00c8 prassi comune aggiungere un metodo statico newInstance() alla classe Fragment. Questo metodo crea l'istanza del fragment, raggruppa e imposta i suoi argomenti.</p>"},{"location":"30_Frameworks_Tools/Android/3_Activity_e_Fragment/#stato-di-un-fragment","title":"Stato di un Fragment","text":"<p>Ogni istanza di fragment pu\u00f2 avere un oggetto Bundle allegato. Questo bundle contiene coppie chiave-valore,</p> <p>Per creare gli argomenti di un fragment, si crea prima un oggetto Bundle. Quindi, si utilizzano i metodi \"put\" specifici del tipo di Bundle (simili a quelli di Intent) per aggiungere argomenti al bundle.</p> <p>Per allegare il bundle degli argomenti a un fragment, si chiama Fragment.setArguments(Bundle). L'allegamento degli argomenti a un fragment deve essere fatto dopo che il fragment \u00e8 stato creato ma prima che venga aggiunto a un'attivit\u00e0.</p> <p>Quando un fragment deve accedere ai suoi argomenti, chiama il metodo getArguments() del Fragment e quindi uno dei metodi \"get\" specifici del tipo di Bundle.</p>"},{"location":"30_Frameworks_Tools/Android/3_Activity_e_Fragment/#comunicazione-tra-activity-e-fragment","title":"Comunicazione tra Activity e Fragment","text":"<p>Per delegare funzionalit\u00e0 all'attivit\u00e0 ospitante, un fragment definisce in genere un'interfaccia di callback denominata Callbacks. Questa interfaccia definisce il lavoro che il fragment deve far svolgere all'attivit\u00e0 ospitante. Qualsiasi attivit\u00e0 che ospiter\u00e0 il fragment deve implementare questa interfaccia.</p> <p>Con un'interfaccia di callback, un fragment \u00e8 in grado di chiamare metodi sulla sua attivit\u00e0 ospitante senza dover sapere nulla di quale attivit\u00e0 lo stia ospitando.</p> <p>L'attivit\u00e0 viene assegnata nel metodo del ciclo di vita del Fragment: onAttach(Activity activity). Questo metodo viene chiamato quando un fragment viene collegato a un'attivit\u00e0, sia che sia stato conservato o meno.</p> <p>Allo stesso modo, la variabile viene impostata su null nel corrispondente metodo del ciclo di vita in diminuzione: onDetach(). La variabile viene impostata su null qui perch\u00e9 in seguito non \u00e8 possibile accedere all'attivit\u00e0 o contare sulla sua continua esistenza.</p>"},{"location":"30_Frameworks_Tools/Android/3_Activity_e_Fragment/#conservazione-dei-fragment","title":"Conservazione dei Fragment","text":"<p>Per impostazione predefinita, la propriet\u00e0 retainInstance di un fragment \u00e8 false. Ci\u00f2 significa che non viene conservato e viene distrutto e ricreato alla rotazione insieme all'attivit\u00e0 che lo ospita. La chiamata a setRetainInstance(true) conserva il fragment. Quando un fragment viene conservato, il fragment non viene distrutto con l'attivit\u00e0. Invece, viene preservato e passato intatto alla nuova attivit\u00e0.</p> <p>Quando si conserva un fragment, si pu\u00f2 contare sul fatto che tutte le sue variabili d'istanza mantengano gli stessi valori.</p> <p>Un fragment conservato non viene distrutto, ma viene staccato dall'attivit\u00e0 morente. Questo mette il fragment in uno stato di conservazione. Il fragment esiste ancora, ma non \u00e8 ospitato da alcuna attivit\u00e0. Lo stato di conservazione viene raggiunto solo quando si verificano due condizioni:</p> <ol> <li>setRetainInstance(true) \u00e8 stato chiamato sul fragment</li> <li>l'attivit\u00e0 ospitante viene distrutta per un cambio di configurazione</li> </ol> <p>Ricever\u00e0 l'evento onDetach quando l'attivit\u00e0 padre viene distrutta, seguito dagli eventi onAttach, onCreateView e onActivityCreated quando viene creata un'istanza della nuova attivit\u00e0 padre.</p>"},{"location":"30_Frameworks_Tools/Android/4_Service/","title":"SERVICE","text":"<p>Un service in Android \u00e8 un componente applicativo che esegue operazioni a lunga esecuzione, solitamente in background, senza fornire un'interfaccia utente (UI). Un'applicazione pu\u00f2 avviare un service anche se non \u00e8 in primo piano e un service pu\u00f2 continuare a essere eseguito anche dopo che l'attivit\u00e0 che lo ha avviato \u00e8 stata distrutta.</p> <p>Un service pu\u00f2 essere avviato, collegato (bound), o entrambi.</p> <ul> <li>Un service avviato \u00e8 quello che un componente applicativo (come un'activity) avvia chiamando startService(). I service avviati vengono utilizzati per eseguire task in background che possono durare a lungo o per eseguire lavoro per processi remoti. Una volta avviato, un service pu\u00f2 continuare a funzionare indefinitamente, anche se il componente che lo ha avviato viene distrutto. Solitamente, un service avviato esegue una singola operazione e non restituisce un risultato al chiamante. Quando l'operazione \u00e8 completata, il service dovrebbe fermarsi da solo chiamando stopSelf(), oppure un altro componente pu\u00f2 fermarlo chiamando stopService().</li> <li>Un service collegato (bound) \u00e8 un service a cui un componente applicativo si connette chiamando bindService(). I service collegati forniscono un'interfaccia client-server che permette ai componenti di interagire con il service, inviare richieste e ottenere risultati, a volte utilizzando la comunicazione interprocesso (IPC). Un service collegato \u00e8 in esecuzione solo finch\u00e9 un altro componente applicativo \u00e8 collegato ad esso. Pi\u00f9 componenti possono collegarsi allo stesso service contemporaneamente, ma quando tutti si disconnettono, il service viene distrutto. Un service collegato generalmente non consente ai componenti di avviarlo chiamando startService().</li> </ul>"},{"location":"30_Frameworks_Tools/Android/4_Service/#ciclo-di-vita-di-un-service","title":"CICLO DI VITA DI UN SERVICE","text":"<p>Il ciclo di vita di un service \u00e8 pi\u00f9 semplice di quello di un'activity. Tuttavia, \u00e8 fondamentale prestare attenzione a come un service viene creato e distrutto, poich\u00e9 un service senza UI pu\u00f2 continuare a funzionare in background senza che l'utente ne sia a conoscenza, consumando risorse e batteria.</p> <p>Come un'activity, un service ha dei metodi di callback del ciclo di vita che \u00e8 possibile implementare per monitorare i cambiamenti nello stato del service ed eseguire operazioni nei momenti appropriati.</p> <p>onCreate(): Questo metodo viene chiamato quando il service viene creato per la prima volta. Viene chiamato una sola volta per la durata del service. Qui \u00e8 dove si dovrebbero eseguire le inizializzazioni di base, come la creazione di thread o la registrazione di listener.</p> <p>onStartCommand(Intent intent, int flags, int startId): Questo metodo viene chiamato ogni volta che un componente avvia il service chiamando startService(). Riceve l'Intent fornito dal client (il componente che ha chiamato startService()) e due interi: flags, che forniscono informazioni aggiuntive sulla richiesta di avvio, e startId, un identificatore univoco per questa particolare richiesta di avvio. \u00c8 in questo metodo che il service esegue il lavoro richiesto dall'Intent. Il valore restituito da onStartCommand() indica al sistema come dovrebbe comportarsi se il service viene interrotto inaspettatamente.</p> <p>onBind(Intent intent): Questo metodo viene chiamato quando un client desidera collegarsi al service chiamando bindService(). Restituisce un oggetto IBinder che il client utilizza per comunicare con il service. I service che intendono essere collegati devono implementare questo metodo; tuttavia, un service pu\u00f2 essere sia avviato che collegato (in tal caso implementer\u00e0 sia onStartCommand() che onBind()). Un service collegato generalmente non implementa onStartCommand().</p> <ul> <li>onUnbind(Intent intent): Questo metodo viene chiamato quando tutti i client collegati al service si sono disconnessi (hanno chiamato unbindService()). Il valore booleano restituito indica se onRebind() debba essere chiamato quando un nuovo client si collega al service.</li> <li>onRebind(Intent intent): Questo metodo viene chiamato quando un nuovo client si collega al service dopo che onUnbind() \u00e8 gi\u00e0 stato chiamato. Viene chiamato se onUnbind() ha restituito true.</li> <li>onDestroy(): Questo metodo viene chiamato quando il service non \u00e8 pi\u00f9 in uso e sta per essere distrutto. Questo pu\u00f2 avvenire quando il service si ferma da solo chiamando stopSelf() o quando un altro componente chiama stopService(), oppure quando tutti i client collegati si disconnettono (per i service collegati). \u00c8 qui che si dovrebbero rilasciare tutte le risorse utilizzate dal service (come thread, listener, ecc.).</li> </ul> <p>\u00c8 importante notare che i service avviati continuano la loro esecuzione indipendentemente dal componente che li ha avviati e devono essere fermati esplicitamente. I service collegati, invece, esistono solo per servire il componente applicativo che \u00e8 collegato ad essi e vengono distrutti quando non ci sono pi\u00f9 componenti collegati.</p> <p>Come le activity e altri componenti, tutti i service devono essere dichiarati nel file manifest dell'applicazione. Per dichiarare un service, \u00e8 necessario aggiungere un elemento  come figlio dell'elemento . <p>Comprendere il ciclo di vita e le diverse tipologie di service \u00e8 fondamentale per sviluppare applicazioni Android efficienti che eseguono operazioni in background in modo appropriato, senza impattare negativamente sull'esperienza utente o sulle risorse del dispositivo.</p> <p>Quando un servizio \u00e8 in esecuzione, pu\u00f2 notificare gli eventi all'utente utilizzando le notifiche snackbar o le notifiche della barra di stato.</p> <p>Una notifica nella barra di app \u00e8 un messaggio che viene visualizzato sulla superficie della finestra corrente solo per un breve istante prima di scomparire. Una notifica nella barra di stato fornisce un'icona con un messaggio, che l'utente pu\u00f2 selezionare per eseguire un'azione (ad esempio avviare un'attivit\u00e0).</p> <p>In genere, una notifica nella barra di stato \u00e8 la tecnica migliore da utilizzare quando un'operazione in background, come il download di un file, \u00e8 stata completata e l'utente pu\u00f2 ora intervenire. Quando l'utente seleziona la notifica dalla visualizzazione espansa, la notifica pu\u00f2 avviare un'attivit\u00e0 (ad esempio per visualizzare il file scaricato).</p>"},{"location":"30_Frameworks_Tools/Android/5_Broadcast_Receiver/","title":"5 Broadcast Receiver","text":""},{"location":"30_Frameworks_Tools/Android/5_Broadcast_Receiver/#broadcast-receiver","title":"BROADCAST RECEIVER","text":"<p>Un Broadcast Receiver \u00e8 un componente Android progettato per rispondere a messaggi provenienti da altre applicazioni o dal sistema operativo. Per implementare un broadcast receiver si estende la classe BroadcastReceiver e implementare il metodo onReceive(Context context, Intent intent) dal quale estraiamo l\u2019evento di intent, i dati ecc.</p> <p>Questi messaggi sono incapsulati negli intent per poter attraversare le applicazioni. Le app possono registrarsi per ascoltare specifici tipi di intent broadcast; quando un intent di quel tipo viene inviato, il sistema notifica il receiver in modo che possa eseguire un'azione.</p> <p>Gli intent broadcast non sono indirizzati a destinatari specifici, ma a tutte le app interessate che hanno registrato un receiver per quel tipo di intent lo riceveranno. Le app anche in background possono ricevere messaggi dai broadcast receiver e svolgere delle attivit\u00e0.</p> <p>Esistono due tipi di intent broadcast: quelli inviati dal sistema (system broadcast intents) e quelli inviati dalla tua app (custom broadcast intents).</p> <ol> <li>Gli intent broadcast di sistema vengono inviati quando si verifica un evento di sistema che potrebbe interessare la tua app, come l'avvio del dispositivi, la connessione o disconnessione dall'alimentazione ecc.</li> <li>Gli intent broadcast personalizzati vengono utilizzati quando vuoi che la tua app esegua un'azione senza avviare un'attivit\u00e0, ad esempio per informare altre app che sono stati scaricati dei dati.</li> </ol> <p>Ci sono due modi per registrare un broadcast receiver:</p> <ol> <li>staticamente nel file manifest aggiungendo un elemento \\ al file AndroidManifest.xml e usare il percorso della tua sottoclasse BroadcastReceiver come attributo android:name.     I receiver registrati staticamente possono essere attivati anche se il processo della tua app non \u00e8 in esecuzione e pu\u00f2 accedere ad ogni eventi di sistema. <p>Infatti Android si accorse che questo causava problemi di sicurezza, visto che potevano essere inseriti dei malware quando si verificavano deteminati eventi di sistema. Allora definirono una registrazione</p> <ol> <li>dinamica sulla base del contesto con cui si chiamava il broadcast receiver. La registrazione avviene chiamando il metodo registerReceiver() e passando un oggetto BroadcastReceiver e un IntentFilter. I receiver registrati dinamicamente sono legati al ciclo di vita del componente in cui sono registrati, infatti \u00e8 necessario gestire anche la loro cancellazione perch\u00e9 potrebbero contenere dati che sprecherebbero risorse</li> </ol> <p></p> <p>Il pattern che viene usato \u00e8 l\u2019observer con tassonomia ad eventi</p>"},{"location":"30_Frameworks_Tools/Android/5_Broadcast_Receiver/#modalita-di-invio-dei-broadcast","title":"MODALIT\u00c0 DI INVIO DEI BROADCAST","text":"<p>Broadcast Normali, con cui il broadcast intente \u00e8 prodotto da un singolo produce e viene inviato a tutti i receiver contemporaneamente. Essendo che vengono mandati sul thread principale, i receiver non vengono eseguiti in parallelo, quindi non \u00e8 possibile fare affidamento su un ordine di esecuzione particolare n\u00e9 sapere quando tutti i receiver hanno completato l'esecuzione.</p> <p>Vengono inviati tramite il metodo sendBroadcast(). I receiver sono indipendenti fra loro e quindi non possono scambiarsi informazioni fra loro.</p> <p>Broadcast Ordinati, sono principalmente eventi di sistema, e questi sono mandati ad una sequenza di broadcast che quandi ricevono l\u2019intent verificano se lo possono risolvere o se ne hanno autorizzazione a risolvelo, altrimenti viene mandato al broadcast successivo fino ad arrivare alla fine della sequenza dove viene lanciata un\u2019eccezione per segnalare che non \u00e8 stato possibile risolverlo.</p> <p>E possibile anche assegnare delle priorit\u00e0, tramite android:priority per modificare l\u2019ordine di esecuzione. Conviene nella catena mettere sempre quelli pi\u00f9 specifici per quello che si deve fare. Questo implementa il pattern di catena di responsabilit\u00e0.</p> <p></p> <p>LocalBroadcastManager Questi rimangono nell\u2019app e quindi non hanno bisogno di intent e n\u00e9 della registrazione nel manifest. Si ottiene un'istanza singleton chiamando getInstance(context), che \u00e8 thread-safe. Per inviare un broadcast locale si usa il suo metodo sendBroadcast(), e per registrare un receiver si usa registerReceiver(). I receiver locali devono essere registrati dinamicamente nel codice; la registrazione statica nel manifest non \u00e8 disponibile per LocalBroadcastManager. \u00c8 importante annullare la registrazione del receiver locale quando non \u00e8 pi\u00f9 necessario per evitare memory leak.</p> <p>Custom Broadcast sia il producer che il receiver devono avere lo stesso nome e devono avere un URI di riferimenti che deve essere univoco, infatti si usa il FQN del package in cui si trova</p>"},{"location":"30_Frameworks_Tools/Android/5_Broadcast_Receiver/#restizione-dei-broadcast","title":"RESTIZIONE DEI BROADCAST","text":"<p>Bisogna evitare che altre applicazione estraggano dati dei broadcast. Infatti il sistema Android non \u00e8 multiutente, ma per dare maggiori sicurezza android definisce delle linee guida per evitare minacce alla sicurezza. \u00c8 necessario creare un sistema di permessi valido, implementando setpackage() per far consumare i messaggi broadcast solo da package specifici. I permessi che devono essere richiesti all\u2019utente devono esser specificati nel manifest e non si possono mandare messaggi non confinati, l\u2019unico che pu\u00f2 \u00e8 Android, che pu\u00f2 mandare permessi null, cio\u00e8 non confinati.</p> <p>\u00c8 possibile imporre permessi per il ricevente e lo si fa con registerReceiver() e nel manifest dobbiamo specificare nel BroadcastReceiver android:permission con i permessi di cui ha bisogno. Quando si hanno bisogno dei permessi, si chiede all\u2019utente di darli o meno. Se l\u2019utente accetta, allora il BroadcastReceiver sar\u00e0 registrato. Non si devono fare operazioni long run perch\u00e9 impegneremmo troppo il sistema, quindi una volta che abbiamo acquisito i dati nella onReceiver(), liberiamo la callback e poi elaboriamo in modo asincrono. (code)</p>"},{"location":"30_Frameworks_Tools/Android/6_Content_Provider/","title":"CONTENET PROVIDER","text":"<p>Un Content Provider \u00e8 un componente di Android che gestisce l'accesso a un repository di dati. L'applicazione non ha bisogno di sapere dove o come i dati sono archiviati, formattati o acceduti.</p> <p></p> <p>Un Content Provider separa i dati dal codice dell'interfaccia utente dell'app, fornendo un modo standard per accedere ai dati. Rende possibile la condivisione di dati tra diverse applicazioni. (Pattern Adapter)</p> <p>Consente a pi\u00f9 applicazioni di accedere, utilizzare e modificare in modo sicuro una singola origine dati fornita dalla tua app.</p> <p>Per ottenere dati e interagire con un Content Provider, un'app utilizza un ContentResolver per inviare richieste al Content Provider. L'applicazione di un fornitore pu\u00f2 specificare le autorizzazioni che altre applicazioni devono avere per accedere ai dati del fornitore. Queste autorizzazioni consentono all'utente di sapere a quali dati un'applicazione tenta di accedere. In base ai requisiti del fornitore, altre applicazioni richiedono le autorizzazioni necessarie per accedere al fornitore. Gli utenti finali vedono le autorizzazioni richieste quando installano l'applicazione.</p> <p>Se l'applicazione di un provider non specifica alcuna autorizzazione, le altre applicazioni non avranno accesso ai dati del provider, a meno che il provider non venga esportato.</p> <p>Per rendere disponibile un ContentProvider all'interno di un'app Android, \u00e8 necessario dichiararlo esplicitamente nel file AndroidManifest.xml, all\u2019interno del tag  tramite l'elemento , che contiene una serie di attributi fondamentali. <ul> <li>android:name, che specifica il nome completo della classe che implementa il ContentProvider.</li> <li>android:authorities, che rappresenta un identificatore univoco del provider. Questo valore viene utilizzato dalle app per costruire gli URI di accesso al provider. Per esempio, se l\u2019authority \u00e8 com.miaapp.provider, l\u2019URI per accedere a una risorsa potrebbe essere content://com.miaapp.provider/risorse.</li> <li>android:exported. Questo valore determina se il provider pu\u00f2 essere accessibile da altre app. Se impostato su true, il provider potr\u00e0 essere utilizzato anche da app esterne, mentre se \u00e8 false, sar\u00e0 accessibile solo dall\u2019interno dell\u2019applicazione stessa. Questo \u00e8 un parametro importante per la sicurezza, specialmente se i dati gestiti sono sensibili.</li> </ul> <p>\u00c8 anche possibile specificare dei permessi di accesso per controllare quali app possono leggere o scrivere dati tramite il provider. Questo si fa aggiungendo gli attributi android:readPermission e android:writePermission, dove si indicano i nomi dei permessi richiesti. Le app che vogliono accedere al provider dovranno dichiarare nel proprio manifest questi permessi, e l\u2019utente li vedr\u00e0 al momento dell\u2019installazione.</p> <p>L'architettura di un Content Provider include i seguenti componenti:</p> <ul> <li>Data and Open Helper: Il repository dei dati. Comunemente i dati sono archiviati in un database SQLite, ma possono essere anche file, dati sul web o dati generati dinamicamente. Per i database SQLite, si utilizza spesso un SQLiteOpenHelper per l'accesso ai dati.</li> <li>Contract: Una classe pubblica che espone informazioni importanti sul Content Provider ad altre app. Include solitamente gli schemi URI, costanti importanti e la struttura dei dati restituiti. L'uso di un contract separa le informazioni pubbliche da quelle private e fornisce un unico punto di riferimento per le altre app.</li> <li>Content Provider: Una classe che estende ContentProvider e implementa i metodi query(), insert(), update() e delete() per accedere ai dati. Fornisce un'interfaccia pubblica e sicura ai dati.</li> <li>Content Resolver: Un oggetto utilizzato dalle app per inviare richieste al Content Provider e ottenere i dati. Fornisce i metodi query(), insert(), update() e delete() che rispecchiano quelli del Content Provider.</li> </ul> <p>Per implementare un Content Provider, \u00e8 necessario:</p> <ul> <li>Avere i dati e un modo per accedervi</li> <li>Dichiarare il Content Provider nel file AndroidManifest.xml per renderlo disponibile. \u00c8 importante impostare l'attributo android:exported=\"true\" se si desidera che altre app possano accedervi.</li> <li>Creare una sottoclasse di ContentProvider che implementi i metodi per l'accesso e la manipolazione dei dati (query(), insert(), delete(), update(), getType()).</li> <li>Definire una classe Contract pubblica che esponga l'URI scheme, i nomi delle tabelle, i tipi MIME e altre costanti importanti.</li> </ul>"},{"location":"30_Frameworks_Tools/Android/6_Content_Provider/#uri-e-tipi-mime","title":"URI e tipi MIME","text":"<p>Le app inviano richieste ai Content Provider utilizzando gli Uniform Resource Identifier (URI). Un content URI ha la forma generale scheme://authority/path/ID, dove lo scheme \u00e8 sempre content://, l'authority rappresenta il dominio del provider (solitamente il nome del package che termina con .provider), il path \u00e8 il percorso ai dati e l'ID identifica univocamente un set di dati. Il contract definisce costanti per l'AUTHORITY, il CONTENT_PATH e il CONTENT_URI.</p> <p>Il tipo MIME indica il tipo e il formato dei dati restituiti dal Content Provider. Per i Content URI che puntano a righe di una tabella, si utilizzano tipi MIME specifici del vendor Android, con il formato generale type.subtype/provider-specific-part. Il type \u00e8 vnd, il subtype \u00e8 android.cursor.item/ per una singola riga e android.cursor.dir/ per pi\u00f9 righe, e la parte specifica del provider include solitamente il nome del package e il nome della tabella. Il metodo getType() del Content Provider restituisce il tipo MIME dei dati per un dato URI.</p> <p>Il ContentResolver fornisce metodi (query(), insert(), delete(), update()) che corrispondono a quelli implementati nel ContentProvider.</p> <ul> <li>Il metodo query() viene utilizzato per recuperare dati e restituisce un oggetto Cursor, che \u00e8 un puntatore a una riga di dati strutturati in formato tabellare, simile a un risultato di una query SQL. La query pu\u00f2 includere una proiezione (le colonne da restituire), una clausola di selezione (il WHERE), gli argomenti di selezione e l'ordine di ordinamento (ORDER BY).</li> <li>I metodi insert(), delete() e update() vengono utilizzati per modificare i dati. Il metodo insert() riceve i valori da inserire come ContentValues e restituisce l'URI della nuova riga.</li> </ul> <p>\u00c8 buona pratica utilizzare un UriMatcher per gestire il matching degli URI all'interno del Content Provider, associando ogni URI supportato a un codice intero.</p>"},{"location":"30_Frameworks_Tools/Android/7_Intent/","title":"INTENT","text":"<p>In Android, un Intent \u00e8 un meccanismo IPC per comunicare con il sistema operativo e fra le applicazioni. Gli Intent sono messaggi che effettuano una richiesta all'Android runtime per avviare un'activity o un altro componente dell'app o di un'altra app. Invece di avviare direttamente le activity, si costruiscono Intent con la classe Intent e si chiama il metodo startActivity() per inviare l'intent.</p> <p>Un Intent esplicito specifica l'activity (o un altro componente) ricevente tramite il suo nome di classe completo. Si utilizzano Intent espliciti per avviare componenti all'interno della propria applicazione. Per creare un Intent esplicito, si utilizza un Context e un oggetto Class. Il metodo newIntent() pu\u00f2 essere utilizzato per configurare correttamente un Intent esplicito con gli extra necessari. L'activity ricevente ottiene l'Intent con getIntent() e recupera i dati dagli extra. \u00c8 anche possibile avviare un'activity aspettandosi un risultato utilizzando startActivityForResult(Intent, requestCode). L'activity chiamata invier\u00e0 un risultato tramite un altro Intent, e l'activity chiamante ricever\u00e0 il risultato nel metodo onActivityResult(). Una Activity avviata tramite startActivity \u00e8 indipendente da quella chiamante e non fornir\u00e0 alcun dato di risposta alla chiusura.</p> <p>Laddove \u00e8 richiesto un feedback, \u00e8 possibile avviare un'attivit\u00e0 come subactivity che pu\u00f2 restituire irisultati al suo genitore. Per fare questi si utilizza startActivityForResult(). Quando la sub-activity \u00e8 pronta per essere restituita, si utilizza setResultprima della fine per restituire un risultato all'attivit\u00e0 chiamante.Il metodo setResultaccetta due parametri: il codice del risultato e i dati del risultato stesso, rappresentati come un Intent.</p> <p>Il codice del risultato indica il successo dell'esecuzione dell'attivit\u00e0 secondaria (RESULT_OK) o insuccesso (Activity.RESULT_CANCELED).</p> <p>Un Intent implicito non specifica un'activity o un altro componente specifico per ricevere l'intent. Invece, si dichiara un'azione generica da eseguire nell'intent. Il sistema Android abbina la richiesta a un'activity o a un altro componente in grado di gestire l'azione richiesta (late binding). Se pi\u00f9 activity corrispondono, all'utente viene presentata una finestra di dialogo di selezione dell'app. Le activity dichiarano la loro capacit\u00e0 di gestire Intent impliciti tramite i filtri di intent definiti nel file AndroidManifest.xml. Per inviare un Intent implicito, si crea un oggetto Intent specificando l'azione, i dati (se presenti) e il tipo MIME dei dati. Prima di chiamare un Intent implicito, \u00e8 buona pratica verificare se ci sono activity in grado di gestirlo chiamando resolveActivity(getPackageManager()). Se si desidera mostrare sempre all'utente un chooser di app quando pi\u00f9 app possono gestire l'intent, si pu\u00f2 utilizzare Intent.createChooser(Intent target, String title).</p> <p>Il passaggio da un'Activity ad un'altra coinvolge i cicli di vita di entrambe. La prima, quella messa a riposo, dovr\u00e0 passare almeno per onPause() e onStop() mentre la seconda percorrer\u00e0 la catena di creazione onCreate-onStart-onResume. La priorit\u00e0 del sistema \u00e8 il mantenimento della fluidit\u00e0 della user-experience, quindi:</p> <ul> <li>La prima Activity passa per onPause e viene fermata in stato Paused;</li> <li>La seconda Activity va in Running venendo attivata completamente. In tale maniera l'utente potr\u00e0 usarla al pi\u00f9 presto non subendo tempi di ritardo;</li> <li>a questo punto, mentre l'utente sta gi\u00e0 usando la seconda Activity, il sistema pu\u00f2 invocare\u00a0onStop sulla prima.</li> </ul>"},{"location":"30_Frameworks_Tools/Android/7_Intent/#filtri","title":"FILTRI","text":"<p>I filtri di intent sono dichiarazioni nel file manifest di un componente dell'app (solitamente un'attivit\u00e0, un servizio o un ricevitore di broadcast) che specificano i tipi di intent che il componente pu\u00f2 gestire.</p> <p>I filtri di intent sono fondamentali per il funzionamento degli intent impliciti. Quando un'applicazione invia un intent implicito, il sistema Android utilizza i filtri di intent dichiarati da tutte le app installate per determinare quale componente \u00e8 il pi\u00f9 adatto a gestire la richiesta.</p> <p>I filtri di intent sono dichiarati nel file AndroidManifest.xml all'interno dell'elemento ,  o  usando uno o pi\u00f9 elementi  che pu\u00f2 contenere tre tipi di elementi che corrispondono alle informazioni contenute in un oggetto Intent: <ul> <li>: Specifica l'azione generica che il componente pu\u00f2 eseguire. Le azioni sono definite come costanti nella classe Intent. Un intent implicito deve contenere un'azione che corrisponda ad almeno una delle azioni dichiarate nel filtro. \u00c8 possibile specificare pi\u00f9 azioni all'interno dello stesso filtro. <li>: Fornisce informazioni aggiuntive sulla categoria del componente che dovrebbe gestire l'intent. Le categorie sono definite come costanti nella classe Intent. Un intent deve corrispondere a tutte le categorie specificate in un filtro per passare. \u00c8 importante notare che tutte le attivit\u00e0 che intendono ricevere intent impliciti devono includere la categoria android.intent.category.DEFAULT, in quanto questa categoria viene aggiunta implicitamente a tutti gli oggetti Intent impliciti dal sistema Android. <li>: Specifica il tipo di dati che il componente pu\u00f2 gestire. Questo include il tipo MIME dei dati o altri attributi di un URI (come lo schema, l'host, la porta e il percorso). Un intent pu\u00f2 specificare un URI di dati e/o un tipo MIME. Il filtro pu\u00f2 dichiarare quali schemi URI e tipi MIME sono supportati. <p>Per un intent implicito affinch\u00e9 venga consegnato a un componente, l'intent deve superare i test di tutti e tre gli elementi (azione, categoria e dati) definiti in almeno uno dei filtri di intent dichiarati dal componente. Se un componente ha pi\u00f9 filtri di intent, un intent che non corrisponde a un filtro potrebbe comunque corrispondere a un altro.</p>"},{"location":"30_Frameworks_Tools/Android/7_Intent/#gli-extras","title":"GLI EXTRAS","text":"<p>Gli Intent \u00e8 che essi, nel recapitare questo messaggio, portano con se dati che possono essere letti dal destinatario. Questi valori condivisi mediante Intent vengono chiamati Extras e possono essere di varie tipologie, sia appartenenti a classi pi\u00f9 comuni che ad altre purch\u00e9 serializzabili. La gestione degli Extras negli Intent funziona in maniera simile ad una struttura dati HashMap: con dei metodi putviene inserito un valore etichettato con una chiave e con i corrispondenti metodi get viene prelevato il valore, richiedendolo mediante la chiave di riconoscimento.</p>"},{"location":"30_Frameworks_Tools/Android/7_Intent/#paramtri-intent","title":"PARAMTRI INTENT","text":"<p>Activity class (per Intent espliciti): il nome della classe dell'activity o del componente che dovrebbe ricevere l'intent.</p> <p>Intent action: l'azione generica che l'activity ricevente dovrebbe eseguire. Le azioni disponibili sono definite come costanti nella classe Intent e iniziano con ACTION_. Esempi includono ACTION_VIEW, ACTION_SEND e ACTION_PICK.</p> <p>Intent category: fornisce informazioni aggiuntive sulla categoria del componente che dovrebbe gestire l'intent. Le categorie sono opzionali e possono essere aggiunte con il metodo addCategory(). Esempi includono CATEGORY_LAUNCHER, CATEGORY_DEFAULT e CATEGORY_BROWSABLE. Per rispondere a Intent impliciti, un filtro di intent deve impostare esplicitamente la categoria DEFAULT, che viene aggiunta implicitamente a ogni Intent implicito.</p> <p>Intent data: contiene un riferimento ai dati su cui l'activity ricevente dovrebbe operare, come un oggetto Uri. Pu\u00f2 rappresentare un URL web, un numero di telefono o un percorso a un file. Il tipo di dati pu\u00f2 anche essere specificato con il metodo setType(), utilizzando un tipo MIME.</p> <p>Intent extras: coppie chiave-valore che trasportano informazioni aggiuntive richieste dall'activity ricevente. I valori possono essere tipi primitivi o oggetti che implementano l'interfaccia Parcelable. I metodi putExtra() vengono utilizzati per aggiungere extra a un Intent, e getIntent().getExtras() o metodi specifici come getStringExtra() o getIntExtra() vengono utilizzati per recuperarli nell'activity ricevente.</p> <p>Intent flags: metadati aggiuntivi che istruiscono il sistema Android su come avviare un'activity o come trattarla dopo l'avvio.</p>"},{"location":"30_Frameworks_Tools/Android/7_Intent/#tipi-di-intent","title":"TIPI DI INTENT","text":"<p>Un broadcast intent \u00e8 un tipo di intent che non avvia un'activity specifica, ma viene consegnato a tutti i broadcast receiver interessati registrati per tale intent. I broadcast receiver sono componenti che ascoltano specifici broadcast di sistema o personalizzati.</p> <p>Un PendingIntent \u00e8 un token che si concede a un'altra applicazione per utilizzare le autorizzazioni del proprio processo per eseguire un'azione in un secondo momento. Viene spesso utilizzato per le notifiche.</p> <p>Un IntentService \u00e8 una sottoclasse di Service che gestisce le richieste intent in background, una alla volta.</p>"},{"location":"30_Frameworks_Tools/Android/8_Notifiche/","title":"NOTIFICHE","text":"<p>Una notifica \u00e8 un messaggio che un'app visualizza all'utente al di fuori interfaccia utente dell'applicazione. Quando si indica al sistema di emettere una notifica, questa appare per la prima volta all'utente come un'icona nell'area di notifica, sul lato sinistro della barra di stato. Per vedere i dettagli della notifica, l'utente apre il drawer di notifica o visualizza la notifica sulla schermata di blocco se il dispositivo \u00e8 bloccato. L'area di notifica, la schermata di blocco e il drawer di notifica sono aree controllate dal sistema che l'utente pu\u00f2 visualizzare in qualsiasi momento.</p> <p>Le notifiche sono il modo in cui Android consente di visualizzare informazioni al di fuori della propria applicazione. Consentono all'utente di essere avvisato delle informazioni dalle applicazioni installate, anche se non le sta utilizzando al momento. Questo \u00e8 particolarmente utile quando nuove informazioni, come email o messaggi, arrivano sul dispositivo in modo asincrono. Quando progettiamo le notifiche dobbiamo evitare di disturbare l\u2019utente per notizie inutile, perch\u00e9 l\u2019utente distraendosi pu\u00f2 decidere di cancellare l\u2019applicazione.</p> <p>Quando si progettano le notifiche, \u00e8 fondamentale ricordare che interrompono sempre l'utente. Pertanto, devono essere,:</p>"},{"location":"30_Frameworks_Tools/Android/8_Notifiche/#1-brevi-utilizza-il-minor-numero-possibile-di-parole-sii-conciso-evita-di-irritare-gli-utenti-inviando-troppe-notifiche-o-notifiche-con-contenuti-inutili-o-fastidiosi","title":"1. Brevi: Utilizza il minor numero possibile di parole. Sii conciso. Evita di irritare gli utenti inviando troppe notifiche o notifiche con contenuti inutili o fastidiosi.","text":""},{"location":"30_Frameworks_Tools/Android/8_Notifiche/#2-tempestive-le-notifiche-devono-apparire-quando-sono-utili-altrimenti-se-arrivano-i-ritardo-potremmo-non-servire-piu","title":"2. Tempestive: Le notifiche devono apparire quando sono utili, altrimenti se arrivano i ritardo potremmo non servire pi\u00f9.","text":""},{"location":"30_Frameworks_Tools/Android/8_Notifiche/#3-pertinenti-linformazione-deve-essere-utile-per-lutente-notifiche-che-disturbino-inutilmente-lutente-o-che-lo-possono-trarre-in-inganno-posso-partare-la-cancellazione-dellapplicazione","title":"3. Pertinenti: l'informazione deve essere utile per l'utente. Notifiche che disturbino inutilmente l\u2019utente o che lo possono trarre in inganno posso partare la cancellazione dell\u2019applicazione.","text":"<p>La classe NotificationCompat.Builder permette di creare le notifiche ed \u00e8 costruita secondo il pattern Builder. La notifica deve avere:</p> <ul> <li>Un ID che la identifica;</li> <li>Il contesto;</li> <li>Icona piccola da mostrare nella barra di stato. Questa \u00e8 impostata con setSmallIcon().</li> <li>Titolo mostrato sopra il testo dettagliato. \u00c8 impostato con setContentTitle().</li> <li>Testo dettagliato cio\u00e8 il messaggio della notifica, un breve testo che descrive alcuni aspetti importanti \u00c8 impostato con setContentText().</li> </ul> <p>Questi metodi setter fanno parte della classe Builder e sono costruiti usando l\u2019interfaccia fluent un modello di progettazione che permette di scrivere il codice in modo pi\u00f9 leggibile e \"fluente\", simile a un linguaggio naturale, concatenando pi\u00f9 metodi attraverso il method chaining*.* Quindi tutti i metodi di settaggio della notifica, in questo caso, restituiscono l\u2019oggetto Builder in modo da apportare pi\u00f9 modifiche. Poi alla fine del settaggio si dovr\u00e0 invocare un metodo di chiusura per ottenere l\u2019oggetto.</p> <p>La notifica pu\u00f2 essere estesa mostrando pi\u00f9 informazioni. Si usano le viste espanse nel drawer di notifica</p>"},{"location":"30_Frameworks_Tools/Android/8_Notifiche/#1-notificationcompatbigtextstyle-utilizzata-per-notifiche-di-grande-formato-che-includono-molto-testo","title":"1. NotificationCompat.BigTextStyle: Utilizzata per notifiche di grande formato che includono molto testo.","text":""},{"location":"30_Frameworks_Tools/Android/8_Notifiche/#2-notificationcompatinboxstyle-utilizzata-per-notifiche-di-grande-formato-che-includono-una-lista-di-fino-a-cinque-stringhe","title":"2. NotificationCompat.InboxStyle: Utilizzata per notifiche di grande formato che includono una lista di fino a cinque stringhe.","text":""},{"location":"30_Frameworks_Tools/Android/8_Notifiche/#3-notificationcompatbigpicturestyle-utilizzata-per-notifiche-di-grande-formato-che-includono-un-grande-allegato-immagine-puoi-impostare-limmagine-grande-con-bigpicture-e-anche-un-titolo-per-il-contenuto-grande-con-setbigcontenttitle","title":"3. NotificationCompat.BigPictureStyle: Utilizzata per notifiche di grande formato che includono un grande allegato immagine. Puoi impostare l'immagine grande con bigPicture() e anche un titolo per il contenuto grande con setBigContentTitle().","text":""},{"location":"30_Frameworks_Tools/Android/8_Notifiche/#4-notificationmediastyle-utilizzata-per-notifiche-di-riproduzione-multimediale","title":"4. Notification.MediaStyle: Utilizzata per notifiche di riproduzione multimediale.","text":"<p>Per applicare uno di questi stili a una notifica, utilizzi il metodo setStyle() sull'oggetto NotificationCompat.Builder. Quindi oltre ad implementare un pattern Builder, ne implementa anche una decorator.</p> <p>Oltre al contenuto testuale o multimediale aggiuntivo, puoi mostrare pi\u00f9 informazioni aggiungendo azioni alla notifica che l'utente pu\u00f2 eseguire sulla notifica stessa, resa disponibile tramite un pulsante di azione. Queste azioni aggiungono funzionalit\u00e0 e permettono all'utente di interagire direttamente con la notifica per accedere o manipolare le informazioni.</p> <p>Pending Intent</p> <p>Quando usiamo delle notifiche modifichiamo il pattern navigazionale dell\u2019applicazione, perch\u00e9 per evitare di far percorrere tutta la strada per arrivare al punto di interesse, possiamo permettere all\u2019utente di cliccare sulla notifica e di essere indirizzato direttamente li. Quindi aggiungiamo dei deep link per arrivare direttamente nelle zone di interesse.</p> <p>Questo \u00e8 realizzato tramite PendingIntent un oggetto che incapsula un Intent. Il suo scopo \u00e8 permettere a un'altra applicazione o al sistema Android di eseguire un Intent per conto della tua applicazione, in un momento futuro. Questo \u00e8 particolarmente utile perch\u00e9 garantisce che il sistema possa consegnare l'Intent anche se la tua app non \u00e8 in esecuzione nel momento in cui l'utente interagisce con esso.</p> <p>Quando si crea un PendingIntent si ottiene un token che non \u00e8 l'Intent stesso, ma una riferimento o un permesso mantenuto dal sistema operativo. Quando consegni questo PendingIntent (token) a un altro componente, quel componente pu\u00f2 utilizzare il token per chiedere al sistema di eseguire l'Intent originale come se fosse stato avviato dalla app che l\u2019ha creato.</p> <p>I PendingIntent sono comunemente utilizzati in vari scenari in cui un'azione deve essere posticipata o eseguita da un altro componente di sistema o un'altra app per conto della tua:</p> <ul> <li>Notifiche: Quando l'utente tocca una notifica, solitamente si vuole che venga avviata un'Activity della tua app. Per fare ci\u00f2, si incapsula l'Intent che avvia l'Activity in un PendingIntent e lo si imposta sulla notifica usando setContentIntent().</li> <li>Allarmi: L'AlarmManager pu\u00f2 attivare un PendingIntent dopo un certo periodo di tempo o a intervalli regolari.</li> <li>Broadcast: Un PendingIntent pu\u00f2 incapsulare un Intent da inviare come broadcast,</li> </ul> <p>Per creare un'istanza di un PendingIntent, si utilizzano metodi statici appropriati a seconda di come si desidera che l'Intent contenuto venga consegnato:</p> <ul> <li>PendingIntent.getActivity(): Per un Intent che dovrebbe essere consegnato usando startActivity(). Si passa un Intent esplicito per l'Activity che si desidera avviare.</li> <li>PendingIntent.getService(): Per un Intent che dovrebbe essere passato a startService()</li> <li>PendingIntent.getBroadcast(): Per un Intent broadcast consegnato con sendBroadcast().</li> </ul> <p>Ciascuno di questi metodi per creare PendingIntent richiede solitamente i seguenti argomenti:</p>"},{"location":"30_Frameworks_Tools/Android/8_Notifiche/#1-il-contesto-dellapplicazione","title":"1. Il contesto dell'applicazione.","text":""},{"location":"30_Frameworks_Tools/Android/8_Notifiche/#2-un-codice-di-richiesta-un-id-per-distinguere-i-pendingintent","title":"2. Un codice di richiesta (un ID per distinguere i PendingIntent).","text":""},{"location":"30_Frameworks_Tools/Android/8_Notifiche/#3-lintent-da-consegnare","title":"3. L'Intent da consegnare.","text":""},{"location":"30_Frameworks_Tools/Android/8_Notifiche/#4-un-flag-pendingintent-che-determina-come-il-sistema-gestisce-piu-oggetti-pendingintent-dalla-stessa-applicazione","title":"4. Un flag PendingIntent che determina come il sistema gestisce pi\u00f9 oggetti PendingIntent dalla stessa applicazione.","text":"<p>Se richiedi un PendingIntent due volte con gli stessi parametri si ottiene lo stesso oggetto PendingIntent.</p> <p>Notification Channel</p> <p>Un altro principio di progettazione \u00e8 quello di dare agli utenti la possibilit\u00e0 di scegliere tramite le impostazioni dell\u2019app i tipi di notifiche che desiderano ricevere e come desiderano riceverle. Questo \u00e8 possibile realizzarlo a partire dall\u2019API26 che permette di creare dei NotificationChannel per offrire all'utente un maggiore controllo sui tipi di notifiche che riceve dall'applicazione. Quando si crea un canale, si definiscono alcune impostazioni iniziali, ma l'utente pu\u00f2 personalizzare ciascun canale e decidere come si comporta.</p> <ul> <li>Azioni: Un'azione che l'utente pu\u00f2 intraprendere sulla notifica. L'azione \u00e8 resa disponibile tramite un pulsante adiacente al contenuto della notifica. Un'azione utilizza un PendingIntent per completare l'azione. Si aggiunge un'azione usando il metodo addAction() passando l'icona, la stringa del titolo e il PendingIntent da attivare.</li> <li>Importance</li> <li>Priorit\u00e0: Influenzano il modo in cui il sistema Android consegner\u00e0 la notifica. Le notifiche hanno una priorit\u00e0 tra MIN (-2) e MAX (2). Le priorit\u00e0 disponibili includono PRIORITY_MAX (critiche/urgenti), PRIORITY_HIGH (comunicazioni importanti come messaggi), PRIORITY_DEFAULT (quelle che non rientrano nelle altre categorie), PRIORITY_LOW (informazioni non urgenti) e PRIORITY_MIN (informazioni di sfondo \"nice-to-know\"). La priorit\u00e0 \u00e8 impostata con setPriority(). Sono rimaste pi\u00f9 per un fatto di compatibilit\u00e0 con le versioni precedenti.</li> <li>Notifiche continue/Servizi in foreground (setOngoing(), startForeground()): Le notifiche continue non possono essere eliminate dall'utente e devono essere esplicitamente cancellate dall'app. Vengono utilizzate per indicare attivit\u00e0 in background con cui l'utente interagisce attivamente (come la riproduzione di musica) o attivit\u00e0 che occupano il dispositivo (come download). Per rendere una notifica continua, si imposta setOngoing() su true. Un servizio in foreground richiede che visualizzi una notifica visibile all'utente. Per avviare un servizio in modalit\u00e0 foreground e visualizzare la notifica, si utilizza startForegroundService() e startForeground(), passando un ID di notifica univoco e l'oggetto notifica. L'ID intero passato a startForeground() non deve essere 0. Per rimuovere un servizio dal foreground, si chiama stopForeground(), specificando se rimuovere la notifica.</li> </ul> <p>Gestione delle notifiche</p> <p>Il NotificationManager \u00e8 un servizio di sistema utilizzato per consegnare o attivare le notifiche. Per ottenere un'istanza del NotificationManager, devi chiamare il metodo getSystemService(), passando la costante NOTIFICATION_SERVICE. Non si dovrebbe mai chiamare questo direttamente, ma usare il NotificationMangerCompact che garantisce anche la retrocomatibilit\u00e0 con le versioni precedenti.</p> <p>La funzione principale del NotificationManager \u00e8 quella di mostrare la notifica all'utente. Ci\u00f2 si fa chiamando il metodo notify(). Il metodo notify() richiede due parametri:</p>"},{"location":"30_Frameworks_Tools/Android/8_Notifiche/#1-un-id-di-notifica-un-numero-intero-utilizzato-per-aggiornare-o-annullare-la-notifica-in-seguito-dovrebbe-essere-unico-allinterno-della-tua-applicazione-se-chiami-notify-piu-volte-con-lo-stesso-tag-e-id-sostituira-qualsiasi-notifica-esistente-con-lo-stesso-tag-e-id-questo-e-il-modo-in-cui-puoi-implementare-ad-esempio-una-barra-di-avanzamento-o-altre-visualizzazioni-dinamiche-in-una-notifica","title":"1. Un ID di notifica (un numero intero), utilizzato per aggiornare o annullare la notifica in seguito. Dovrebbe essere unico all'interno della tua applicazione. Se chiami notify() pi\u00f9 volte con lo stesso tag e ID, sostituir\u00e0 qualsiasi notifica esistente con lo stesso tag e ID. Questo \u00e8 il modo in cui puoi implementare, ad esempio, una barra di avanzamento o altre visualizzazioni dinamiche in una notifica.","text":""},{"location":"30_Frameworks_Tools/Android/8_Notifiche/#2-loggetto-notification-stesso-questo-oggetto-viene-tipicamente-costruito-utilizzando-la-classe-notificationcompatbuilder","title":"2. L'oggetto Notification stesso. Questo oggetto viene tipicamente costruito utilizzando la classe NotificationCompat.Builder.","text":"<p>A partire dall'API 26 , il NotificationManager \u00e8 anche responsabile della gestione dei canali di notifica, infatti \u00e8 obbligatorio associare la notifica ad un canale. Puoi utilizzare il NotificationManager per controllare se un canale esiste gi\u00e0 e, in caso contrario, creare un nuovo oggetto. Questo d\u00e0 all'utente un maggiore controllo sui tipi di notifiche che riceve dall'applicazione, poich\u00e9 pu\u00f2 personalizzare le impostazioni per ciascun canale.</p> <p>Le notifiche rimangono visibili fino a quando non si verifica una delle seguenti condizioni:</p> <ul> <li>L'utente le ignora individualmente o tramite \"Cancella tutto\"</li> <li>Chiami setAutoCancel(true) sul builder della notifica, in tal caso la notifica scompare quando l'utente ci clicca sopra.</li> <li>Chiami cancel() per un ID di notifica specifico.</li> <li>Chiami cancelAll() per far sparire tutte le notifiche che hai emesso.</li> </ul> <p>APP SETTING</p> <p>Le app settings si riferiscono alle preferenze dell'utente che consentono di modificare le caratteristiche e i comportamenti dell'applicazione. Sono controlli che catturano le preferenze degli utenti che influiscono sulla maggior parte di essi o forniscono supporto critico a una minoranza. Esempi includono l'abilitazione delle notifiche o la frequenza di sincronizzazione dei dati con il cloud. In iOS, concetti simili (\"user defaults\") sono usati per preferenze come lingua, stile UI o unit\u00e0 di misura.</p> <p>Gli utenti dovrebbero poter navigare alle impostazioni dell'app toccando un'opzione Settings. Questa opzione \u00e8 solitamente collocata nella navigazione lateral o nel menu opzioni. Secondo le linee guida di design, l'opzione \"Settings\" dovrebbe trovarsi al di sotto di tutti gli altri elementi (eccetto Help e Send Feedback) sia nella navigazione laterale che nel menu opzioni.</p> <p>Le impostazioni sono solitamente accessibili infrequentemente, poich\u00e9 una volta che l'utente cambia un'impostazione, raramente ha bisogno di modificarla di nuovo. Se un controllo o una preferenza necessita di accesso frequente, \u00e8 meglio spostarlo nel menu opzioni della app bar o in un menu di navigazione laterale. \u00c8 importante impostare dei valori di default per le impostazioni che siano familiari agli utenti e migliorino l'esperienza dell'app. I default dovrebbero rappresentare la scelta pi\u00f9 comune, usare meno batteria, comportare il minor rischio per la sicurezza/perdita di dati, e interrompere solo quando importante. Informazioni sull'app come numero di versione o licenze dovrebbero essere spostate in una schermata di Help separata.</p>"},{"location":"30_Frameworks_Tools/Android/9_Setting/","title":"9 Setting","text":"<p>Settings UI</p> <p>Per costruire la UI delle impostazioni, si usano sottoclassi della classe Preference piuttosto che oggetti View. La classe Preference fornisce la View da visualizzare per ogni impostazione e si associa a un'interfaccia SharedPreferences per memorizzare/recuperare i dati.</p> <p>Per visualizzare una lista di impostazioni, si usa una Activity o un Fragment specializzato. La best practice per Android 3.0+ \u00e8 usare una SettingsActivity che ospita un PreferenceFragment. Per compatibilit\u00e0 con la v7 appcompat library, si estende la Settings Activity con AppCompatActivity e il fragment con PreferenceFragmentCompat. Per versioni pi\u00f9 vecchie di Android (\\&lt;3.0), si usa PreferenceActivity. L'uso di PreferenceFragment \u00e8 generalmente pi\u00f9 flessibile rispetto alla sola PreferenceActivity.</p> <p>Android Studio fornisce un template Settings Activity. Questo template facilita la creazione di schermate di impostazioni, specialmente se si hanno pi\u00f9 gruppi di impostazioni. Fornisce layout diversi per smartphone (header links) e tablet (master/detail view). Il template crea i file XML (res/xml/) che definiscono le impostazioni (pref_data_sync.xml, pref_general.xml, pref_headers.xml, pref_notification.xml), risorse stringa (strings.xml), e le classi Activity/Fragment necessarie (SettingsActivity, AppCompatPreferenceActivity). Il template include anche la funzionalit\u00e0 per ascoltare i cambiamenti delle impostazioni e aggiornare il riassunto (summary).</p> <p>La gerarchia delle impostazioni inizia con un layout PreferenceScreen.</p>"},{"location":"30_Frameworks_Tools/Android/9_Setting/#1-tipi-di-controlli-ui-diverse-sottoclassi-di-preference-offrono-ui-appropriate-per-modificare-le-impostazioni","title":"1. Tipi di Controlli UI: Diverse sottoclassi di Preference offrono UI appropriate per modificare le impostazioni:","text":"<ul> <li>CheckBoxPreference: Per impostazioni abilitate/disabilitate (valore booleano).</li> <li>ListPreference: Mostra una lista di pulsanti radio in un dialogo.</li> <li>SwitchPreference: Un'opzione toggle con due stati (on/off, true/false).</li> <li>EditTextPreference: Un campo di testo in un dialogo per l'inserimento di stringhe.</li> <li>RingtonePreference: Consente all'utente di scegliere una suoneria.</li> </ul> <p>I valori delle impostazioni vengono memorizzati in un file SharedPreferences. Questo \u00e8 un modo comune per persistere piccole quantit\u00e0 di dati primitivi come coppie chiave-valore tra le sessioni dell'app. Ogni oggetto Preference (impostazione) ha una coppia chiave-valore corrispondente che il sistema usa per salvare il valore in un file SharedPreferences predefinito.</p> <p>Dopo aver salvato le impostazioni, \u00e8 necessario leggere i valori dallo SharedPreferences file per usarli nella logica dell'app. Si pu\u00f2 anche implementare un listener (Preference.OnPreferenceChangeListener) per reagire immediatamente ai cambiamenti di un'impostazione.</p> <p></p>"},{"location":"30_Frameworks_Tools/Android/Android/","title":"COMPUTAZIONE PERVASIVA","text":"<p>Con lo sviluppo delle nuove tecnologie che ha portato alla nascita dei dispositivi di compilazione portabili \u00e8 nata una nuova forma di computazione, quella pervasiva.</p> <p>Essendo i dispositivo mobili e non pi\u00f9 fissi si \u00e8 dovuto cercare un nuovo modo di far comunicare i vari dispositivi per via delle connessioni precarie e in continuo cambiamento. Si cerca di progettare anche un software che sia in grado di utilizzare meno risorse possibili e che abbiano una potenza di calcolo minore per evitare di esaurire le risorse del dispositivo punto di tutto questo si occupa l'anno mobile computing. Questi dispositivi pervasivi sono sistemi distribuiti e quindi questi problemi dei sistemi distribuiti e mobile fanno parte del pervasive computing a cui si aggiungono altri problemi come la scalabilit\u00e0 invisibilit\u00e0 la comunicazione remota ecc.</p> <p>Non tutti gli obiettivi del pervasive computer sono stati realizzati infatti creare uno smartplace, uno spazio in cui ci sono dispositivi di calcoli in modo da calcolare il mondo fisico e cyber fisico \u00e8 ancora difficile da realizzare, ma non perch\u00e9 non possediamo le tecnologie adeguate ma perch\u00e9 dobbiamo migliorare i collegamenti.</p> <p>\u00c8 necessario rendere questi dispositivi invisibili, l'uomo non si deve accorgere che ci sono in modo che il mondo fisico e il cyber fisico si fondono in un solo spazio. Un altro problema \u00e8 dovuto al numero sempre crescendo i dispositivi che si connettono tra loro quindi si cerca di realizzare la scalabilit\u00e0 localizzata cio\u00e8 di mantenere le stesse qualit\u00e0 di servizi ma man mano che aumentano i nuovi dispositivi.</p> <p>S\u00ec cerca di mascherare le condizioni di non uniformit\u00e0 dovute diversi dispositivi presenti che possono impedire di collaborare fra loro cercando di creare un sistema per nascondere alle domande e questi problemi.</p> <p>La computazione pervasiva ha modificato anche il modo in cui ci interfacciamo col software perch\u00e9 prima era necessario l'intervento umano per far svolgere qualcosa la macchina mentre oggi il computer \u00e8 in grado di comunicare con tende anche in maniera asincrona.</p> <p>Questo \u00e8 stato reso possibile grazie al fatto che prendono informazioni nel mondo reale tramite i sensori sono in grado di elaborarli e notificare all'uomo qualcosa.</p> <p>Oggi sia una architettura ed Edge cloudcentrica in cui tutti i dispositivi sono connessi tra loro tramite il cloud in cui le risorse informatiche sono regate attraverso la rete internet ospitate e gestite da server remoti.</p> <p>Si provvede di avere un architettura ed internet centrica con cui internet il centro delle connessioni fra i dispositivi e i server. In questo modo l'elaborazione avviene in modo distribuita ai margini della rete contrariamente a come accade in quelle precedenti in cui le elaborazione avviene in economia i server.</p> <p>Nell'architettura di calcolo distribuita ci sono tre segmenti che rappresentano muri diversi di elaborare e archiviare dati a seconda delle distanze dal punto di generazione</p> <p>\ud83d\udccd Edge Computing Alla base di tutto troviamo l\u2019Edge, ovvero il bordo della rete. I dati vengono elaborati il pi\u00f9 vicino possibile alla fonte che li genera, spesso direttamente all\u2019interno del dispositivo stesso. I dati vengono elaborati in tempo reale, senza dover prima inviare i dati a un server esterno.</p> <p>Questo approccio \u00e8 ideale per situazioni in cui la velocit\u00e0 \u00e8 fondamentale, come nelle auto a guida autonoma o nei dispositivi medici. Riduce la latenza, cio\u00e8 il tempo che passa tra l\u2019input e la risposta, e limita il traffico di rete.</p> <p>\ud83c\udf2b\ufe0f Fog Computing Salendo di un livello, troviamo il Fog Computing, un modello pensato per distribuire l\u2019elaborazione pi\u00f9 vicino alla rete, ma non necessariamente sul dispositivo.</p> <p>Nel fog computing, i dati vengono inviati a nodi local, un router o un server che li elaborano e, solo se necessario, li inoltrano al cloud. Questo modello \u00e8 utile quando bisogna elaborare rapidamente grandi quantit\u00e0 di dati provenienti da pi\u00f9 dispositivi, ma non si ha la necessit\u00e0 di farlo in tempo reale estremo.</p> <p>\u2601\ufe0f Cloud Computing Infine, abbiamo il Cloud, che rappresenta l\u2019approccio centralizzato. I dati vengono inviati a server remoti, spesso situati in data center geograficamente lontani. Qui possono essere elaborati con grande potenza computazionale, salvati per lungo tempo o usati per addestrare algoritmi complessi di intelligenza artificiale.</p> <p>Il cloud \u00e8 perfetto per elaborazioni intensive. Tuttavia, presenta limiti in termini di latenza e dipendenza dalla connessione internet.</p> <p>Edge, Fog e Cloud non si escludono a vicenda: collaborano. In un sistema moderno ed efficiente, i dati vengono prima processati localmente (edge), poi aggregati e raffinati in una rete vicina (fog), e infine archiviati o ulteriormente analizzati nel cloud.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#hci","title":"HCI","text":"<p>La Human computer interaction HCI Eh lo studio dell\u2019interazione uomo computer per la progettazione di sistemi informatici che siano usabili e affidabili. Il loro scopo \u00e8 quello di semplificare l\u2019attivit\u00e0 umane e non di ostacolarle. Se hai il computer che le persone offrono diversi modi di interagire fra loro e l\u2019interazione pu\u00f2 essere</p> <ul> <li>diretta cio\u00e8 tramite l\u2019uso del dispositivo e di risposte da parte del calcolatore ;</li> <li>indiretta tramite sensori se analizzano il mondo esterno e danno dei feedback per svolgere azioni</li> </ul> <p>La HCI \u00e8 una materia multidisciplinare che coinvolge</p> <p></p> <p>Il principio base della disciplina \u00e8</p> <p>usabilit\u00e0 cio\u00e8 la facilit\u00e0 con il quale l'utente pu\u00f2 interagire con la macchina per raggiungere obiettivi con efficacia, efficienza e soddisfazione per un certo contesto</p> <p>\u2260</p> <p>accessibilit\u00e0 che indica se un sistema informatico pu\u00f2 essere usato da tutti compreso chi ha disabilit\u00e0</p> <p>Interazione umana</p> <p>L'uomo \u00e8 colui che usa i calcolatori e devono essere progettati per assisterlo. Qui entrano in gioco le scienze cognitive che devono capire le capacit\u00e0 e le limitazioni per progettare in modo corretto un sistema informatico</p> <p>Interazione processo con il quale l'utente fornisce la macchina in un input e la macchina lo processa restituendo un output o viceversa</p> <p>Per la macchina si sono molte forme di IO, ma per l'essere umano sono principalmente i cinque sensi e pi\u00f9 in particolare la vista l'udito e il tatto. Interagiamo con la macchina principalmente con il tatto, le dita fungono da cursore. Solo recentemente siamo in grado di interagire anche con la voce per fornire un input.</p> <p> Vista La vista \u00e8 il principale mezzo con il quale otteniamo informazioni. La percezione visiva si pu\u00f2 dividere in due fasi</p> <ol> <li>ricezione fisica dello stimolo</li> <li>elaborazione e un'interpretazione dello stimolo</li> </ol> <p>Dobbiamo capire come funziona l'occhio e come la mente interpreta gli stimoli per progettare sistemi informatici. La prima cosa da capire \u00e8 cosa l'utente vede punto la vista umana tende ad avere una visione centrale dove l\u2019utente di attento e nota le cose; \u00e8 una visione centrale che trascura le cose che sono fuori da quella centrale.</p> <p>Capire questo ci permette di realizzare un design utile all\u2019utente</p> <p>\ud83e\udc6a le info importanti devono essere al centro del campo</p> <p>\ud83e\udc6a le info meno importanti devono essere pi\u00f9 all'esterno</p> <p>Importante \u00e8 capire anche come percepiamo i colori, dimensioni, e profondit\u00e0 per una buona progettazione delle interfaccia visive. Bisogna definire il contesto in cui gli oggetti si trovano perch\u00e9 diamo sulla base di esso o un'interpretazione diversa dovuta al fatto che possiamo gi\u00e0 conoscere il contesto e le info relative da conoscenze passate. Definiamo correttamente il contesto permette all'utente di capire subito di cosa si tratta ed evita le illusioni ottiche che lo portano in disabilit\u00e0 quindi bisogna definire correttamente le dimensioni degli oggetti dove posizionarli e cos\u00ec via per poter sviluppare una buona interfaccia utente.</p> <p>Udito Un altro canale di output per l'uomo pu\u00f2 essere il canale uditivo grazie al quale siamo in grado di riconoscere i suoni in quanto il nostro sistema filtro i suoni che ascoltiamo per concentrarci sulle informazioni importanti il suono \u00e8 spesso usato nelle interfacce grafiche ad esempio per dare informazioni sullo stato di qualcosa, focalizzare l'attenzione ecc.. quindi per notificare/rafforzare l'idea dell'utente.</p> <p>Tatto Il tatto ci d\u00e0 informazioni sull'ambiente circostante e specialmente nei sistemi informatici \u00e8 la fonte di input ma anche di output. In questo modo siamo in grado di interagire con gli aggettivi fuori dagli smartphone in modo da svolgere determinati compiti. Anche i movimenti importanti perch\u00e9 comporta un elaborazione di informazioni in seguito a uno stimolo ricevuto toccando qualcosa. Ogni movimento richiede tempo che dipende dalle persone dall'et\u00e0 eccetera eccetera. In movimento si valuta con accuratezza cio\u00e8 la precisione del movimento che dipende anche dalla velocit\u00e0 con il quale si reagisce. Quanto si progetta un\u2019interfaccia e bisogna considerare queste caratteristiche del movimento per progettare i bottoni che siano facilmente raggiungibili e premibili. (Pubblicit\u00e0 ingannevole)</p> <p>Il tempo impiegato per colpire un bersaglio \u00e8 una funzione della dimensione del bersaglio della distanza da percorrere</p> <p>Legge di Fitts</p> <p>Dispositivi Il progettista dell'interfaccia deve essere a conoscenza delle propriet\u00e0 del dispositivo e di tutti i fattori che influenzano il comportamento dell'interfaccia perch\u00e9 influenzano la natura dell\u2019interazione.</p> <p>Donald Norman da una definizione di interazione HC stabilimento che si tratta di un ciclo che si compone di due fasi</p> <ol> <li>Esecuzione</li> <li>Valutazione    |    V</li> </ol> <p>L'utente stabilisce l'obiettivo, formula l'intenzione c'\u00e8 l'obiettivo che deve realizzare, esegue le azioni sul dispositivo e percepisce lo stato del sistema e lo interpreta per capire il posto suggestivo per raggiungere l'obiettivo</p> <p>\u00c8 importante che l'utente capisca cosa fare per completare le loro azioni e le interfacce non devono essere di un tralcio anzi devono semplificare il raggiungimento dell'obiettivo.</p> <p>DESIGN SBAGLIATO \ud83e\udc6alapsus cio\u00e8 quando comprendiamo il sistema ma si fanno</p> <p>| errori di distrazione V</p> <p>errori quando si sbaglia perch\u00e9 non si \u00e8 capito il sistema e quindi cosa deve fare per raggiungere l\u2019obiettivo</p> <p>Ergonomia L\u2019ergonomia \u00e8 lo studio delle caratteristiche fisiche dell\u2019interazione quindi come progettare i controlli layout dei dispositivi ecc.</p> <p>L'obiettivo \u00e8 di migliorare come l\u2019utente usi dispositivi per dare migliori prestazioni sull'uso di questi punto questo si riflette anche sul design, su come posizionare gli elementi sulla base dell'utilit\u00e0 del contesto ecc.</p> <p>Quando progettiamo l'interfaccia dobbiamo tenere conto anche di come gli utenti usano i dispositivi infatti secondo studi la maggior parte delle persone usano il dispositivo con una mano sola e usano il pollice per toccare lo schermo, oppure con la seconda mano lo fissiamo oppure usano entrambe le mani quindi in base a come viene utilizzato progettiamo il design mettendo gli elementi importanti nelle parti dello schermo pi\u00f9 facilmente raggiungibili in base alle modalit\u00e0 di uso mentre gli elementi meno utili o di uso frequente nelle parti pi\u00f9 esterne un design corretto porta ad avere una pessima esperienza d'uso per l'utente finale</p>"},{"location":"30_Frameworks_Tools/Android/Android/#architectural-ui-and-data-management-patterns","title":"ARCHITECTURAL UI AND DATA MANAGEMENT PATTERNS","text":"<p>Prima ancora di scrivere codice, \u00e8 importante definire l\u2019architettura del sistema. Progettare l\u2019architettura in anticipo permette di avere una visionechiara di come sar\u00e0 strutturata l\u2019applicazione, come interagiranno i diversi componenti tra loro e quali saranno le dipendenze principali.</p> <p>Questo ha un impatto diretto sulla qualit\u00e0 del progetto nel lungo periodo. Se in futuro sar\u00e0 necessario apportare modifiche, aggiungere funzionalit\u00e0, sostituire una tecnologia, risolvere bug o adattarsi a nuove esigenze\u2026 avere un\u2019architettura solida e ben pensata render\u00e0 tutto pi\u00f9 semplice, veloce e sicuro.</p> <p>\u00c8 necessario strutturare il sistema in modo che sia indipendente dai framework, librerie e linguaggi che usiamo perch\u00e9 cambiano nel tempo: nuove versioni, nuove API, a volte addirittura vengono abbandonati o sostituiti da soluzioni migliori. Se il nostro sistema dipende troppo da queste tecnologie, ogni cambiamento porta ad errori o riscritture pesanti del codice.</p> <p>a modularit\u00e0 \u00e8 uno dei concetti pi\u00f9 importanti. Significa suddividere un sistema in parti indipendenti e riutilizzabili, chiamate moduli o componenti, ognuno dei quali ha una responsabilit\u00e0 chiara e ben definita.</p> <p>Conviene pensare alla modularit\u00e0 cio\u00e8 dividere il codice in moduli in modo che sia pi\u00f9 semplice da capire, da testare, da manutenere e da evolvere. Ogni modulo pu\u00f2 essere sviluppato (e perfino sostituito) senza dover riscrivere tutto il resto. Dobbiamo fare attenzione alle dipendenze circolari che si verificano quando due (o pi\u00f9) moduli dipendono l\u2019uno dall\u2019altro direttamente o indirettamente. Questo crea una situazione di interdipendenza, dove nessuno dei moduli pu\u00f2 essere isolato, testato o riutilizzato in modo indipendente.</p> <p>Il principio che si trova alla base di ogni pattern architetturale \u00e8 la separazione dei problemi in livelli in modo da avere le dipendenze verso un\u2019unica direzione ed evitare le dipendenze circolari. I vari livelli non devono avere riferimenti ai livelli pi\u00f9 esterni di loro, questo violerebbe la modularit\u00e0 e renderebbe quindi i livelli dipendenti fra loro.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#clean-archicture","title":"CLEAN ARCHICTURE","text":"<p>La Clean Architecture mira a creare sistemi intercambiabili con una forte separazione delle preoccupazioni e un accoppiamento debole tra i livelli.</p> <p>L'idea fondamentale di Clean Architecture, concepita da Robert Martin (Uncle Bob), \u00e8 rendere intercambiabile ogni elemento all'interno di un certo confine architetturale, senza richiedere modifiche nei livelli sottostanti.</p> <p>Le dipendenze del codice sorgente possono puntare solo verso l'interno. Questo significa che i livelli interni non devono dipendere da livelli. Questa direzione delle dipendenze \u00e8 fondamentale per ottenere un basso accoppiamento e facilitare il test e la manutenzione.</p> <p>La Clean Architecture divide un'applicazione in diversi livelli con responsabilit\u00e0 distinte:</p> <ol> <li>Domain/Application Core: Contiene le entit\u00e0 e la logica di business dell'applicazione. Questo livello \u00e8 indipendente da qualsiasi framework o dettaglio di implementazione esterna.</li> <li>Use Cases: Il software in questo livello contiene regole aziendali specifiche dell'applicazione ed incapsula e implementa tutti i casi d'uso del sistema. Questi casi d'uso orchestrano il flusso di dati da e verso le entit\u00e0 e indirizzano tali entit\u00e0 per raggiungere gli obiettivi del caso d'uso. I cambiamenti in questo livello non devono influenzare le entit\u00e0 e questo livello non \u00e8 influenzato da modifiche alle componenti esterne come il database, l'interfaccia utente o qualsiasi framework utilizzato. Questo strato \u00e8 isolato da tali problematiche. Tuttavia, modifiche alle funzioni di dominio dell'applicazione influenzeranno i casi d'uso e quindi il software in questo livello.</li> <li>Infrastructure/Frameworks: Contiene i dettagli di implementazione dei sistemi esterni, come database, framework UI, librerie esterne e API. Le implementazioni delle interfacce definite nel livello Application risiedono qui.</li> <li>Interface Adapters: Questo livello funge da ponte tra i livelli Application e Infrastructure. Contiene adapter, presentatori e controller che convertono i dati da un formato all'altro per soddisfare le esigenze dei diversi livelli.</li> <li>API/UI: Il livello pi\u00f9 esterno che presenta l'applicazione all'utente (tramite un'API web o un'interfaccia utente grafica).</li> </ol> <p></p> <p>Per attraversare i confini (cerchi concentrici) si usano i controller e i Presenter che comunicano con i casi d'uso nel livello successivo.</p> <ol> <li>l'esecuzione inizia nel controller</li> <li>si sposta attraverso il caso d'uso</li> <li>finisce per essere eseguito nel presenter.</li> </ol> <p>Per implementare questa logica si utilizza il principio di inversione delle dipendenze che consente ad A di chiamare metodi su un'astrazione implementata da B, rendendo possibile per A chiamare B in fase di esecuzione, ma per B di dipendere da un'interfaccia controllata da A in fase di compilazione (invertendo cos\u00ec la tipica dipendenza in fase di compilazione). In fase di esecuzione, il flusso di esecuzione del programma rimane invariato, ma l'introduzione di interfacce significa che diverse implementazioni di queste interfacce possono essere facilmente collegate. La stessa tecnica viene utilizzata per attraversare tutti i confini nelle architetture.</p> <p>Sfruttiamo il polimorfismo dinamico per creare dipendenze del codice sorgente che si oppongono al flusso di controllo in modo che possiamo rispettare la regola delle dipendenze indipendentemente dalla direzione in cui sta andando il flusso di controllo.</p> <p></p> <p>Il Repository Pattern \u00e8 spesso integrato in Clean Architecture come un meccanismo per astrarre l'accesso ai dati. L'interfaccia del repository \u00e8 definita nel livello Application, mentre l'implementazione concreta che interagisce con il database si trova nel livello Infrastructure. Questo rispetta la regola della dipendenza, poich\u00e9 il livello Application dipende solo dall'interfaccia del repository, non dalla specifica implementazione del database.</p> <p>La separazione dei livelli e la regola della dipendenza rendono le applicazioni Clean Architecture pi\u00f9 facili da testare. I casi d'uso e la logica di business nel livello Application possono essere testati unitariamente senza dipendere da database o UI. Le interfacce nel livello Application facilitano il mocking delle dipendenze esterne durante i test. L'accoppiamento debole tra i livelli rende le applicazioni Clean Architecture pi\u00f9 scalabili e manutenibili. Le modifiche a un livello hanno meno probabilit\u00e0 di influenzare altri livelli, facilitando l'aggiornamento e l'aggiunta di nuove funzionalit\u00e0.</p> <p>I ViewModel spesso interagiscono con un Repository per l'accesso ai dati. Questa struttura (UI - ViewModel - Repository - Data Source) in Android pu\u00f2 essere vista come un'implementazione pratica di alcuni principi di Clean Architecture, in particolare la separazione delle preoccupazioni e l'astrazione dell'accesso ai dati.</p> <p>Una potenziale violazione della regola della dipendenza in Clean Architecture quando si implementa il Repository pattern utilizzando direttamente un ORM (come Entity Framework Core) nel livello Infrastructure. Questo introduce una dipendenza del livello Interface Adapters (dove si troverebbe l'implementazione del repository) verso un framework esterno e verso l'I/O diretto, violando la dipendenza verso l'interno. Per risolvere questo, si suggerisce di spostare l'implementazione del repository nel livello Frameworks/Infrastructure e di definire le interfacce nel livello Application.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#livedata","title":"LIVEDATA","text":"<p>LiveData \u00e8 una classe di dati osservabile che \u00e8 legata al ciclo di vita dei componenti UI, come Activity o Fragment. Questo significa che LiveData permette di aggiornare la UI automaticamente quando i dati cambiano, ma solo quando la UI \u00e8 in uno stato attivo, evitando aggiornamenti inutili o errori quando la UI non \u00e8 visibile (ad esempio, se l'Activity \u00e8 in background). Implementa il pattern Observer.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#room","title":"ROOM","text":"<p>Room \u00e8 una libreria di persistenza fornita da Google che si colloca all'interno dei componenti dell'architettura Android, con l'obiettivo di semplificare l'interazione con il database SQLite del sistema operativo, fornendo un livello di astrazione.</p> <p>Room \u00e8 descritta come un modo efficace per creare database e salvare dati. Fornisce un accesso al database SQLite mappando oggetto-relazionale (ORM) basato su annotazioni.</p> <p>L'utilizzo di Room si articola principalmente su tre tipi di classi:</p> <ul> <li>Entit\u00e0: Sono Plain Old Java Objects (POJO) che modellano i dati da trasferire verso e dal database. Sono annotate con @Entity, specificando la tabella del database a cui corrispondono. Almeno una propriet\u00e0 deve essere designata come chiave primaria usando l'annotazione @PrimaryKey. Room crea una tabella nel database per ogni entit\u00e0.</li> <li>DAOs - Data Access Objects: Definiscono l'API per interagire con i dati, contenendo metodi per operazioni come query, inserimenti, aggiornamenti ed eliminazioni. I DAOs sono interfacce o classi astratte annotate con @Dao. Le operazioni sul database sono definite all'interno dei metodi del DAO tramite annotazioni come @Query, @Insert, @Update e @Delete. Room genera l'implementazione concreta di queste interfacce o classi astratte in fase di compilazione.</li> <li>Database: Rappresenta l'interfaccia principale al database SQLite sottostante. \u00c8 una classe astratta che estende RoomDatabase ed \u00e8 annotata con @Database, elencando tutte le entit\u00e0 utilizzate dal database e la sua versione. Contiene metodi astratti che restituiscono istanze dei DAO. Si ottiene un'istanza del database tramite un RoomDatabase.Builder.</li> <li>Relazioni tra Entit\u00e0: Sebbene Room supporti relazioni tramite chiavi esterne definite con l'annotazione @ForeignKey, non supporta riferimenti diretti tra entit\u00e0. Per rappresentare relazioni uno-a-molti o molti-a-molti e accedere agli oggetti correlati, si utilizza l'annotazione @Relation all'interno di una classe POJO separata che contiene i campi per le entit\u00e0 correlate. Per le relazioni molti-a-molti \u00e8 necessario implementare una \"join entity\" che crea la tabella di join associata.</li> </ul> <p></p> <p>In Room, le entit\u00e0 sono pensate pi\u00f9 come Data Transfer Objects (DTO) oggetti concepiti come un mezzo per trasferire dati tra diversi punti di un'applicazione. Modellano una risposta o sono ottimizzati per la creazione e la persistenza dei dati. Le Entity in Room rappresentano i dati che si desidera memorizzare nel database e sono anche l'unit\u00e0 tipica di un set di risultati recuperato dal database</p> <p></p> <p>Room pu\u00f2 essere integrato con LiveData per osservare i cambiamenti nel database. Un DAO pu\u00f2 restituire un oggetto LiveData da una query, consentendo all'interfaccia utente di aggiornarsi automaticamente quando i dati sottostanti cambiano.</p> <p>Room si integra bene con ViewModel, che gestisce i dati relativi alla View in modo indipendente dai cambiamenti di configurazione. Il ViewModel pu\u00f2 interagire con il database tramite un repository che utilizza Room.</p> <p>\u00c8 una buona pratica utilizzare il pattern Repository come livello intermedio tra Room e il resto dell'applicazione. Questo permette di astrarre l'accesso ai dati e, se in futuro vorrai cambiare il tipo di persistenza (ad esempio passare da Room a una sorgente di rete o cache), potrai farlo senza modificare i ViewModel o altri componenti della business logic.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#mvc","title":"MVC","text":"<p>Il [[MVC]] Model View Controller \u00e8 un modo per organizzare le funzionalit\u00e0 di un'applicazione separando gli oggetti in tre ruoli distinti:</p> <p></p> <p>Gli oggetti del modello non hanno alcuna conoscenza dell'interfaccia utente (UI). Il loro unico scopo \u00e8 la gestione e la detenzione dei dati.</p> <p>Model Il modello contiene i dati dell'applicazione e la logica di business.Le classi del modello sono progettate per rappresentare le entit\u00e0 con cui l'app lavora, come una domanda vero/falso. In Android, il livello del modello \u00e8 generalmente costituito da classi personalizzate create dallo sviluppatore. Il modello pu\u00f2 anche specificare la struttura dei dati dell'app e il codice per accedervi e manipolarli.</p> <p>View La vista \u00e8 responsabile della visualizzazione dei dati all'utente e della risposta alle azioni dell'utente. Ogni elemento visibile sullo schermo \u00e8 una vista. Android fornisce molteplici tipi di viste. Le viste sanno come disegnarsi sullo schermo e come rispondere all'input dell'utente, come i tocchi.</p> <p>Controller Il controllore agisce come un intermediario tra il modello e la vista. Contiene la logica dell'applicazione .I controllori rispondono agli eventi innescati dalle viste e gestiscono il flusso di dati da e verso il modello e la vista. In Android, un controllore \u00e8 tipicamente una sottoclasse di Activity, Fragment o Service.</p> <p>\u00c8 importante notare che il modello e la vista non comunicano direttamente. Il controllore si trova al centro, ricevendo messaggi da un lato e inviando istruzioni all'altro.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#benefici-dellmvc","title":"Benefici dell'MVC","text":"<ul> <li>Separazione delle responsabilit\u00e0: Aiuta a progettare e comprendere l'applicazione come un insieme di classi distinte.</li> <li>Migliore organizzazione del codice: La separazione in livelli (modello, vista, controllore) facilita la progettazione e la comprensione dell'applicazione a un livello superiore.</li> <li>Riutilizzabilit\u00e0 del codice: Le classi con responsabilit\u00e0 limitate sono pi\u00f9 riutilizzabili.</li> </ul>"},{"location":"30_Frameworks_Tools/Android/Android/#observer-synchronization","title":"Observer Synchronization","text":"<p>Questo approccio, strettamente associato all'MVC, si basa sul concetto che le viste e i controllori osservano il modello.</p> <p>Quando il modello subisce una modifica, viene notificato a tutti i suoi osservatori (le viste e potenzialmente i controllori).</p> <p>Le viste reagiscono a queste notifiche aggiornando la propria visualizzazione in base ai nuovi dati del modello.</p> <p>Il controllore, in questo modello, \u00e8 relativamente \"ignorante\" di quali altre viste potrebbero aver bisogno di essere aggiornate quando l'utente interagisce con una specifica vista. Il controllore si limita a modificare il modello, lasciando che il meccanismo di osservazione si occupi di propagare i cambiamenti alle viste interessate.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#flow-synchronization","title":"Flow Synchronization","text":"<p>Nella sincronizzazione tramite flusso, \u00e8 l'applicazione (spesso il controllore) che manipola direttamente le viste per riflettere i cambiamenti nel modello. Ad esempio, quando si apre una schermata o si preme un pulsante di salvataggio, il codice dell'applicazione si occupa di aggiornare esplicitamente i vari controlli (viste) con i dati del modello. In questo caso, il form (o l'attivit\u00e0/il fragment in Android) deve tenere traccia di quali controlli devono essere aggiornati in seguito a un cambiamento, il che pu\u00f2 diventare complesso in schermate elaborate.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#mvvm","title":"MVVM","text":"<p>Il pattern MVVM Model-View-ViewModel permette una gestione pi\u00f9 fluida della UI e una separazione pi\u00f9 chiara tra la logica di business e l'interfaccia utente.</p> <p>Il pattern MVVM \u00e8 composto da tre componenti principali:</p> <ol> <li>Model</li> <li>View</li> <li>ViewModel che da intermediario tra la View e il Model. \u00c8 responsabile della gestione dei dati da visualizzare nella UI e dell'elaborazione della logica necessaria per presentarli. La ViewModel fornisce i dati alla View tramite LiveData, che consente di osservare i cambiamenti dei dati e aggiornare automaticamente la UI quando necessario. La ViewModel non ha conoscenza diretta della View. Comunica con il Model per recuperare i dati e li prepara in una forma che la View pu\u00f2 facilmente consumare.</li> </ol>"},{"location":"30_Frameworks_Tools/Android/Android/#interazione-tra-i-componenti-nel-pattern-mvvm","title":"Interazione tra i componenti nel pattern MVVM","text":"<ol> <li>L'utente interagisce con la View (ad esempio, tocca un pulsante).</li> <li>La View invia un'azione al ViewModel (ad esempio, invoca un metodo che cambia i dati).</li> <li>Il ViewModel interagisce con il Model per recuperare o modificare i dati. In caso di operazioni asincrone, il ViewModel gestisce il flusso di lavoro.</li> <li>Quando il Model restituisce i dati (ad esempio tramite una chiamata API), il ViewModel li prepara (ad esempio, li converte in un formato adatto alla visualizzazione).</li> <li>Il ViewModel aggiorna un LiveData, che \u00e8 osservato dalla View.</li> <li>La View riceve i nuovi dati tramite LiveData e aggiorna automaticamente l'interfaccia utente.</li> </ol> <p>In questo modo, ogni componente ha un compito preciso:</p> <ul> <li>la UI si concentra solo sulla presentazione e l\u2019interazione,</li> <li>il ViewModel gestisce la logica di visualizzazione,</li> <li>il Repository coordina l\u2019accesso ai dati,</li> <li>e il livello Model (Room + Retrofit) fornisce le sorgenti dati reali.</li> </ul>"},{"location":"30_Frameworks_Tools/Android/UI%20Testing%20%28Espresso%29/","title":"UI Testing (Espresso)","text":"<p>ESPRESSO</p> <p>Il UI testing si concentra sul test degli aspetti dell'interfaccia utente e delle interazioni con gli utenti.</p> <p>Espresso lavora con il test runner AndroidJUnitRunner e richiede instrumentation.</p> <p>I test Espresso si basano sulla simulazione delle azioni che un utente potrebbe compiere: trovare una view, eseguire un'azione (es. clic) e verificare il risultato (asserzione sullo stato della view).</p> <p>I test Espresso vengono eseguiti su dispositivi Android reali o emulatori. Richiedono l'instrumentazione e funzionano con il test runner AndroidJUnitRunner.</p> <ul> <li>L'app restituisce l'output UI corretto in risposta a una sequenza di azioni dell'utente.</li> <li>I controlli di navigazione e input dell'app aprono le Activity, le View e i campi corretti.</li> <li>L'app risponde correttamente con dipendenze \"mockate\" (false) o pu\u00f2 lavorare con metodi backend \"stubbed out\" (simulati).</li> </ul> <p>Un vantaggio fondamentale di Espresso \u00e8 l'accesso alle informazioni di strumentazione, come il contesto dell'app. Sincronizza automaticamente le azioni di test con l'UI dell'app, rilevando quando il thread principale \u00e8 inattivo. Ci\u00f2 permette ai test di essere eseguiti al momento opportuno, migliorando l'affidabilit\u00e0 ed evitando la necessit\u00e0 di workaround basati sul tempo, come i ritardi (sleep) nel codice di test.</p> <p>La scrittura dei test Espresso si basa su ci\u00f2 che farebbe un utente. I passaggi fondamentali sono:</p>"},{"location":"30_Frameworks_Tools/Android/UI%20Testing%20%28Espresso%29/#1-trovare-una-vista-match-a-view-individuare-lelemento-ui-con-cui-interagire-spesso-usando-il-metodo-onview","title":"1. Trovare una vista (Match a view): Individuare l'elemento UI con cui interagire, spesso usando il metodo onView().","text":""},{"location":"30_Frameworks_Tools/Android/UI%20Testing%20%28Espresso%29/#2-eseguire-unazione-perform-an-action-interagire-con-la-vista-trovata-ad-esempio-cliccando-click","title":"2. Eseguire un'azione (Perform an action): Interagire con la vista trovata, ad esempio cliccando (click()).","text":""},{"location":"30_Frameworks_Tools/Android/UI%20Testing%20%28Espresso%29/#3-asserire-e-verificare-il-risultato-assert-and-verify-the-result-controllare-lo-stato-della-vista-o-loutput-per-vedere-se-corrisponde-allo-stato-o-al-comportamento-atteso","title":"3. Asserire e verificare il risultato (Assert and verify the result): Controllare lo stato della vista o l'output per vedere se corrisponde allo stato o al comportamento atteso.","text":"<p>Espresso ha una sintassi fluida e un paradigma funzionale. Il framework Hamcrest \u00e8 comunemente usato con Espresso per le asserzioni. Permette di creare matcher personalizzati e combinare espressioni per definire regole di corrispondenza in modo dichiarativo. Questo porta a messaggi di errore pi\u00f9 utili rispetto alle semplici asserzioni booleane.</p>"},{"location":"30_Frameworks_Tools/Android/Unit%20Testing%20%28JUnit%29/","title":"Unit Testing (JUnit)","text":"<p>Il testing \u00e8 fondamentale per assicurarsi che un'app si comporti come previsto in ogni situazione, specialmente man mano che l'app cresce e cambia.</p> <p>Aiuta a identificare i problemi nelle prime fasi dello sviluppo, quando sono meno costosi da risolvere, e migliora la robustezza del codice. Ci sono vari tipi di test:</p> <ul> <li>unit test \u00e8 una verifica che si concentra sul comportamento di una singola unit\u00e0 di codice. Questa \"unit\u00e0\" di codice \u00e8 solitamente una singola funzione o un metodo. L'obiettivo \u00e8 garantire che quella specifica parte del codice funzioni correttamente in isolamento, senza dipendenze esterne.</li> <li>Component test si verifica se le classi fra loro collaborano bene</li> <li>integration test si concentrano sull'interazione tra pi\u00f9 unit\u00e0 di codice, per verificare che diversi componenti funzionino insieme come previsto. Mentre i unit test testano singole unit\u00e0 in isolamento, gli integration test verificano la corretta integrazione di pi\u00f9 unit\u00e0, come moduli, librerie o servizi, e se queste interazioni producono il comportamento desiderato.</li> </ul> <p>Il testing automatizzato rende pi\u00f9 facile eseguire test su diverse configurazioni di dispositivi e stati. Scriverli da tutti sarebbe una follia.\ud83e\udd2a</p> <p>Bisogna individuare i test suite e usare dei framework per poter scrivere test in modo automatico. Lo scopo dei test non \u00e8 di rimuovere gli errori, ma di capire cosa non funziona per poterli risolvere il problema.</p> <p></p> <p>I test suite vengono dati ad un test runner che gli esegue e crea delle test class con i method test eseguendo per ogni metodo delle operazioni:</p> <ul> <li>Setup: Prima dell'esecuzione dei metodi di test, il test runner pu\u00f2 invocare metodi di setup che sono utilizzati per configurare le risorse necessarie per il test</li> <li>Esecuzione dei Test: I metodi di test vengono eseguiti uno alla volta.</li> <li>Tear Down: Dopo l'esecuzione di un test, possono essere invocati metodi di teardown per liberare risorse, come la chiusura di connessioni al database o la pulizia di dati temporanei.</li> </ul> <p>Una volta che i test sono stati eseguiti, il test runner crea un report dei risultati. Questo report mostra:</p> <ul> <li>I test che sono passati.</li> <li>I test che sono falliti.</li> <li>I test che hanno generato errori (ad esempio, eccezioni non gestite).</li> </ul> <p>Android supporta diverse tipologie di test e framework di testing.</p> <p>JUnit 4 \u00e8 un framework comune per scrivere unit test in Java per Android.</p> <p>Il framework JUnit implementa il composite, quindi possiede il TestSuite (compose) e i TestCase (leaf).</p> <p>Per creare gli unit Test si crea una classe test che implementa i metedi:</p> <ul> <li>setUp()</li> <li>tearDown</li> <li>TestXXX</li> <li>Suite()</li> </ul> <p>Nei metodi di test ci mettiamo le asserzioni per verificare che il comportamento del codice corrisponda a quanto previsto.</p> <p>La libreria Hamcrest \u00e8 uno strumento utile per scrivere asserzioni nei test, permettendo di creare regole di matching in modo dichiarativo.</p> <p>1. Framework di Unit Test di \"Prima Generazione\"</p> <p>Nei framework di unit test di prima generazione, il concetto di base \u00e8 che un test deve verificare che una condizione sia vera durante l'esecuzione del codice. Questo avviene tramite l'istruzione assert, che verifica una condizione booleana e, se la condizione non \u00e8 vera, fa fallire il test.</p> <p>I framework di \"prima generazione\" forniscono un messaggio di errore generico, come \"Assertion failed\", che non \u00e8 particolarmente utile per capire cosa sia andato storto.</p> <p>2. Framework di Unit Test di \"Seconda Generazione\"</p> <p>I framework di unit test di seconda generazione migliorano la situazione fornendo una serie di asserzioni specializzate che sono in grado di produrre messaggi di errore pi\u00f9 chiari e specifici, adattandosi a diversi tipi di confronti (ad esempio, uguaglianza, differenza, ecc.).</p> <p>Alcuni esempi includono:</p> <ul> <li>assert_equal(x, y): Verifica che x e y siano uguali.</li> <li>assert_not_equal(x, y): Verifica che x e y non siano uguali.</li> </ul> <p>Queste asserzioni specializzate sono pi\u00f9 esplicite e forniscono messaggi di errore pi\u00f9 significativi. Tuttavia, il problema principale di questo approccio \u00e8 che il numero di macro di asserzione tende a crescere rapidamente, perch\u00e9 ogni tipo di confronto richiede una macro di asserzione</p> <p>3. Framework di Unit Test di \"Terza Generazione\"</p> <p>I framework di unit test di terza generazione (come Hamcrest, un popolare framework di asserzione in Java) risolvono questo problema introducendo un approccio pi\u00f9 generico e composibile. In questi framework, l'operatore assert_that viene combinato con matcher (oggetti che eseguono verifiche su una condizione).</p> <p>Un matcher \u00e8 una classe o un oggetto che definisce una condizione che pu\u00f2 essere verificata. In questo caso, assert_that viene utilizzato per affermare che un oggetto soddisfi una determinata condizione definita dal matcher.</p> <p>MOCKITO (mock a mamm\u2019t) \ud83d\ude35</p> <p>Mockito \u00e8 un framework di mocking che pu\u00f2 essere utilizzato per isolare le unit\u00e0 di codice durante l'esecuzione di unit test.</p> <p>Permette di creare oggetti mock (fittizi o simulati) che si comportano come le dipendenze di un'unit\u00e0 di codice che stai testando. Questo \u00e8 utile perch\u00e9 consente di testare la logica specifica di un componente in isolamento, senza doversi preoccupare del comportamento reale delle sue dipendenze.</p> <p>Mockito \u00e8 specificamente menzionato nel contesto della creazione di unit test. Quando si esegue un unit test, l'obiettivo \u00e8 verificare la logica di una piccola porzione di codice (come un metodo o una classe).</p> <p>Android permette due tipi di test:</p> <ul> <li>Local Unit TestQuesti test vengono compilati ed eseguiti interamente sulla tua macchina locale utilizzando la Java Virtual Machine (JVM). Sono utilizzati per testare la logica interna dell'app che non richiede l'accesso all'Android framework o a un dispositivo/emulatore1 .</li> <li>Instrumented TestQuesti test vengono eseguiti su un dispositivo o emulatore Android.</li> </ul> <p></p>"},{"location":"30_Frameworks_Tools/Building_Tools/Building_Tools_MOC/","title":"\ud83d\uddfa\ufe0f Building Tools (MOC)","text":"<p>Area: [[30_Frameworks_Tools]]</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Building_Tools_MOC/#indice","title":"\ud83d\udccc Indice","text":"<ul> <li>Maven</li> <li>Gradle</li> </ul>"},{"location":"30_Frameworks_Tools/Building_Tools/Gradle/","title":"Gradle","text":"<p>Parent: Building_Tools_MOC</p> <p></p> <p>Gradle \u00e8 un sistema di automazione della build open source che combina la potenza e la flessibilit\u00e0 di Ant con la gestione delle dipendenze e le convenzioni di Maven. A differenza di Maven (basato su XML), Gradle utilizza un DSL (Domain Specific Language) basato su Groovy o Kotlin, permettendo di scrivere logica di build come vero e proprio codice.</p> <p>\u00c8 lo standard de facto per lo sviluppo Android.</p> <p>Apache Ant (acronimo di Another Neat Tool) \u00e8 stato il primo vero standard per l'automazione della build nel mondo Java, rilasciato nel 2000. A differenza dei suoi successori, Ant \u00e8 nato come strumento puramente imperativo: non impone convenzioni su come il progetto debba essere strutturato, ma richiede allo sviluppatore di descrivere esplicitamente ogni singolo passaggio del processo. Questo approccio offre grande flessibilit\u00e0, ma pu\u00f2 portare a build scripts complessi e difficili da mantenere, soprattutto in progetti di grandi dimensioni. Ant non ha un sistema di gestione delle dipendenze integrato, il che significa che gli sviluppatori devono gestire manualmente le librerie esterne, spesso scaricandole e includendole nel progetto senza un meccanismo centralizzato.</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Gradle/#architettura-e-struttura","title":"Architettura e Struttura","text":"<p>Gradle adotta la struttura di directory standard di Maven, ma i file di configurazione sono diversi:</p> <ul> <li>build.gradle (o build.gradle.kts): Lo script di build principale (equivalente al pom.xml).</li> <li>settings.gradle: Definisce la struttura del progetto e quali moduli includere (multi-module).</li> <li>gradle.properties: Variabili di configurazione e propriet\u00e0 della JVM.</li> <li>gradlew (Gradle Wrapper): Uno script shell che scarica e utilizza una versione specifica di Gradle, garantendo che tutti nel team usino la stessa versione.</li> </ul>"},{"location":"30_Frameworks_Tools/Building_Tools/Gradle/#il-gradle-wrapper","title":"Il Gradle Wrapper","text":"<p>Il Wrapper \u00e8 uno script (<code>gradlew</code>) che invoca una versione dichiarata di Gradle, scaricandola se necessario. Garantisce che ogni sviluppatore e il server di CI (es. Jenkins/GitHub Actions) usino l'esatta stessa versione di Gradle, eliminando problemi di compatibilit\u00e0.</p> <p>Per aggiornare il progetto a una nuova versione di Gradle:</p> <pre><code>./gradlew wrapper --gradle-version 8.5 --distribution-type all\n</code></pre>"},{"location":"30_Frameworks_Tools/Building_Tools/Gradle/#script-vs-dichiarazione","title":"Script vs Dichiarazione","text":"<p>Mentre Maven \u00e8 dichiarativo (\"Descrivo cosa voglio\"), Gradle \u00e8 imperativo/dichiarativo (\"Descrivo cosa voglio, ma posso anche scrivere codice per dire come ottenerlo\").</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Gradle/#gestione-delle-dipendenze","title":"Gestione delle Dipendenze","text":"<p>Gradle sostituisce il concetto di \"Scope\" di Maven con le Configurations. Questo offre un controllo pi\u00f9 granulare sulla transitivit\u00e0 e sulla compilazione.</p> Maven Scope Gradle Configuration Descrizione compile implementation Dipendenza interna, non esposta transitivamente. Migliora la velocit\u00e0 di build. (N/A) api Espone la dipendenza transitivamente (plugin <code>java-library</code>). provided compileOnly Necessaria per compilare ma non inclusa nel pacchetto finale. runtime runtimeOnly Necessaria solo in esecuzione. test testImplementation Disponibile solo nei test."},{"location":"30_Frameworks_Tools/Building_Tools/Gradle/#version-catalogs-toml","title":"Version Catalogs (TOML)","text":"<p>Introdotto stabilmente in Gradle 7.4, il Version Catalog \u00e8 il metodo moderno per centralizzare le dipendenze. Invece di hardcodare versioni nei vari <code>build.gradle</code>, si utilizza un file TOML situato in <code>gradle/libs.versions.toml</code>.</p> <p>Il file \u00e8 diviso in sezioni:</p> <ol> <li><code>[versions]</code> - Definisce le versioni in un unico posto.</li> <li><code>[libraries]</code> - Mappa i nomi delle librerie alle coordinate Maven, con riferimento alle versioni.</li> <li>Esteso: <code>retrofit-core = { group = \"...\", name = \"...\", version.ref = \"...\" }</code></li> <li>Compatto: <code>retrofit-core = { module = \"group:name\", version.ref = \"...\" }</code>      Gradle trasforma i nomi separati da trattini in notazione punto (type-safe). <code>retrofit-core</code> nel TOML diventa <code>libs.retrofit.core</code> nel file <code>build.gradle</code>.</li> <li><code>[plugins]</code> - Definisce i plugin con le loro versioni, anch'essi referenziati da <code>[versions]</code>.</li> <li><code>[bundles]</code> - Permette di raggruppare pi\u00f9 librerie sotto un unico nome per importarle insieme.    Nel <code>build.gradle</code>, invece di aggiungere 5 righe per ogni libreria di test, ne aggiungi una sola</li> </ol> <p>```gradle    // Senza Bundle:</p> <p>testImplementation(libs.junit)    testImplementation(libs.mockito)    testImplementation(libs.assertj)</p> <p>// Con Bundle:</p> <p>testImplementation(libs.bundles.testing)    ```</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Gradle/#struttura-del-file-libsversionstoml","title":"Struttura del file <code>libs.versions.toml</code>","text":"<pre><code>[versions]\nspringBoot = \"3.2.0\"\njunit = \"5.10.0\"\nlombok = \"1.18.30\"\n\n[libraries]\n# Definizione singola libreria\nlombok = { group = \"org.projectlombok\", name = \"lombok\", version.ref = \"lombok\" }\n\n# Riferimento alla versione definita sopra\njunit-jupiter = { module = \"org.junit.jupiter:junit-jupiter\", version.ref = \"junit\" }\n\n[plugins]\nspring-boot = { id = \"org.springframework.boot\", version.ref = \"springBoot\" }\n\n[bundles]\n# Raggruppamento di librerie per importarle in un colpo solo\ntesting = [\"junit-jupiter\"]\n</code></pre> <p>Vantaggi:</p> <ul> <li>Centralizzazione: Un solo posto dove aggiornare le versioni per progetti multi-modulo.</li> <li>Type-Safety: L'IDE suggerisce i nomi delle librerie (libs.nomeLibreria).</li> <li>Standardizzazione: Formato leggibile e condivisibile tra team diversi.</li> </ul>"},{"location":"30_Frameworks_Tools/Building_Tools/Gradle/#build-lifecycle-e-task-graph","title":"Build Lifecycle e Task Graph","text":"<p>Il cuore di Gradle \u00e8 il DAG (Directed Acyclic Graph) dei Task. Il ciclo di vita ha tre fasi distinte:</p> <ol> <li>Initialization: Gradle determina quali progetti partecipano alla build (legge settings.gradle).</li> <li>Configuration: Esegue gli script di build di tutti i progetti, crea il grafo dei task e popola le propriet\u00e0. Attenzione: Non mettere codice pesante qui, verr\u00e0 eseguito ad ogni comando!</li> <li>Execution: Esegue i task richiesti (es. build, test) nell'ordine determinato dal grafo.</li> </ol>"},{"location":"30_Frameworks_Tools/Building_Tools/Gradle/#il-file-gradleproperties","title":"Il file <code>gradle.properties</code>","text":"<p>Equivalente parziale del <code>settings.xml</code> di Maven per le propriet\u00e0. Si usa per configurare l'ambiente di build:</p> <pre><code># Aumenta la memoria per la build (Performance)\norg.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8\n# Abilita la cache e il demone per velocit\u00e0\norg.gradle.caching=true\norg.gradle.daemon=true\n# Variabili custom\nmyVersion=1.0.0\n</code></pre>"},{"location":"30_Frameworks_Tools/Building_Tools/Gradle/#repository-e-credenziali","title":"Repository e Credenziali","text":"<p>Definiti nel blocco repositories del <code>build.gradle</code> (o globalmente in un init script):</p> <pre><code>repositories {\n    mavenCentral()\n    maven {\n        url \"[https://repo.mycompany.com/maven2](https://repo.mycompany.com/maven2)\"\n        credentials {\n            username = property('repoUser')\n            password = property('repoPassword')\n        }\n    }\n}\n</code></pre>"},{"location":"30_Frameworks_Tools/Building_Tools/Gradle/#multi-module-projects","title":"Multi-module projects","text":"<p>Un progetto multi-modulo \u00e8 definito da un unico file <code>settings.gradle</code> (o <code>.kts</code>) alla radice, che dichiara quali directory fanno parte della build.</p> <pre><code>root-project/\n\u251c\u2500\u2500 settings.gradle.kts    // Definisce la topologia\n\u251c\u2500\u2500 build.gradle.kts       // Configurazione condivisa (opzionale)\n\u251c\u2500\u2500 gradle.properties      // Propriet\u00e0 globali\n\u251c\u2500\u2500 core/                  // Modulo libreria\n\u2502   \u2514\u2500\u2500 build.gradle.kts\n\u251c\u2500\u2500 api/                   // Modulo interfacce\n\u2502   \u2514\u2500\u2500 build.gradle.kts\n\u2514\u2500\u2500 app/                   // Modulo applicazione (eseguibile)\n    \u2514\u2500\u2500 build.gradle.kts\n</code></pre> <p>Nel file <code>settings.gradle</code> (o <code>settings.gradle.kts</code>) si dichiarano i moduli:</p> <pre><code>rootProject.name = \"my-enterprise-app\"\n\ninclude(\"core\")\ninclude(\"api\")\ninclude(\"app\")\n\n// Strutture nidificate (es. features/login)\ninclude(\"features:login\")\n</code></pre> <p>Nel modulo <code>web/build.gradle</code> si importa il modulo core:</p> <pre><code>dependencies {\n    implementation project(':core')\n}\n</code></pre>"},{"location":"30_Frameworks_Tools/Building_Tools/Gradle/#cross-configuration","title":"Cross-Configuration","text":"<p>Esistono due approcci principali per applicare configurazioni comuni a tutti i moduli (Cross-Configuration), che sono:</p> <ol> <li><code>ubprojects / allprojects</code> Nel <code>build.gradle.kts</code> del progetto root, si inietta la configurazione nei figli.</li> </ol> <p>```gradle    // root/build.gradle.kts</p> <p>// Applica a TUTTI i progetti (root + figli)    allprojects {        group = \"com.azienda\"        version = \"1.0.0\"    }</p> <p>// Applica solo ai figli (esclusa la root)    subprojects {        apply(plugin = \"java-library\")</p> <pre><code>   repositories {\n       mavenCentral()\n   }\n\n   dependencies {\n       testImplementation(\"org.junit.jupiter:junit-jupiter:5.10.0\")\n   }\n</code></pre> <p>}    ```</p> <p>Crea Accoppiamento. Modificare la root invalida la cache di tutti i figli. Inoltre, rende la configurazione meno leggibile nei singoli moduli.</p> <ol> <li>Convention Plugins (buildSrc) con il quale si crea un Convention Plugins all\u2019interno della directory <code>buildSrc</code>. Questo permette di definire logica di configurazione in codice Kotlin o Groovy, mantenendo i singoli <code>build.gradle</code> puliti e focalizzati sulle dipendenze specifiche del modulo.</li> <li>Creare <code>buildSrc/src/main/kotlin/my-java-conventions.gradle.kts</code>.</li> <li>Definire l\u00ec la logica comune.</li> <li>Applicare il plugin nei singoli moduli: <code>plugins { id(\"my-java-conventions\") }</code>.       Questo favorisce la Composizione sull'Ereditariet\u00e0, riduce l\u2019accoppiamento e migliora la manutenibilit\u00e0.</li> </ol> <p>Un modulo pu\u00f2 dipendere da un altro usando la sintassi <code>project()</code>.</p> <p>Nel file <code>app/build.gradle.kts</code>:</p> <pre><code>dependencies {\n    // Dipendenza diretta da un altro modulo\n    implementation(project(\":core\"))\n\n    // Dipendenza da un modulo nidificato\n    implementation(project(\":features:login\"))\n}\n</code></pre> <p>In un progetto multi-modulo, Gradle costruisce il Task Graph.</p> <p>Se esegui <code>./gradlew :app:build:</code> Gradle vede che <code>:app</code> dipende da <code>:core</code>. Verifica se <code>:core</code> \u00e8 aggiornato (UP-TO-DATE).</p> <p>Se necessario, ricompila <code>:core</code> prima di <code>:app</code>.</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Gradle/#comandi-cli","title":"Comandi (CLI)","text":"<p>\u00c8 buona norma usare sempre il Wrapper (<code>./gradlew</code> su Linux/Mac, <code>gradlew.bat</code> su Windows).</p> Comando Descrizione <code>./gradlew build</code> Compila ed esegue i test. <code>./gradlew clean</code> Cancella la directory <code>build</code>. <code>./gradlew test</code> Esegue i test. <code>./gradlew dependencies</code> Mostra l\u2019albero delle dipendenze. <code>./gradlew tasks</code> Elenca i task disponibili. <code>./gradlew assemble</code> Compila senza eseguire i test. <code>./gradlew publish</code> Pubblica l\u2019artefatto su un repository. <code>./gradlew --refresh-dependencies</code> Forza il download delle dipendenze."},{"location":"30_Frameworks_Tools/Building_Tools/Maven/","title":"Maven","text":"<p>Parent: Building_Tools_MOC</p> <p></p> <p>Maven \u00e8 un progetto open source sviluppato da Apache che facilita l'organizzazione efficiente di un progetto Java. Rende pi\u00f9 facile gestire e mantenere grandi progetti fornendo una struttura coerente e una serie di convenzioni su come organizzare il progetto, aiutando gli sviluppatori ad automatizzare il processo di build, test e distribuzione del software.</p> <p>Una delle caratteristiche principali di Maven \u00e8 la sua capacit\u00e0 di gestire le dipendenze. Maven tiene traccia di tutte le librerie e altre dipendenze necessarie per un progetto e le scarica automaticamente quando sono richieste. Questo rende facile per gli sviluppatori utilizzare librerie esterne nei loro progetti senza doverle scaricare e gestire manualmente.</p> <p>Maven obbliga ad avere una struttura fissa delle directory</p> <ul> <li>Il POM \u00e8 alla radice del progetto</li> <li>Poi ci sono due directory:</li> <li>src: contiene il sorgente</li> <li>target: contiene i file generati alla fine del processo di compilazione</li> </ul> <p>Avendo a disposizione il POM e la directory src, chiunque pu\u00f2 essere in grado di ricostruire la directory target</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#pom-project-object-model","title":"POM (Project Object Model)","text":"<p>Maven utilizza un approccio dichiarativo per specificare la build e le dipendenze del progetto. Il file centrale che Maven utilizza \u00e8 il pom.xml (Project Object Model). Questo file gestisce le dipendenze del progetto, i plugin e la configurazione della build. Inoltre, Maven offre una serie di plugin integrati per attivit\u00e0 comuni e pu\u00f2 essere esteso con plugin personalizzati.</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#repository-maven","title":"Repository Maven","text":"<p>Un repository Maven \u00e8 una directory che contiene i file compilati insieme ai relativi metadati. I metadati si riferiscono ai file POM associati a ciascun progetto. Questi metadati consentono a Maven di scaricare le dipendenze necessarie per il progetto.</p> <p>Maven dispone di tre tipi di repository:</p> <ol> <li>Repository Locale: Il repository locale si trova sulla macchina dello sviluppatore e contiene tutte le dipendenze, come i file JAR. Ogni sviluppatore ha il proprio repository locale.</li> <li>Repository Remoto: Il repository remoto \u00e8 situato su un server web e viene utilizzato quando Maven deve scaricare le dipendenze. Quando un artefatto non \u00e8 presente nel repository locale, Maven lo scarica dal repository remoto e lo memorizza nel repository locale.</li> <li>Repository Centrale: Il repository centrale \u00e8 gestito dalla comunit\u00e0 Maven ed \u00e8 la fonte principale da cui Maven scarica le dipendenze, qualora non siano presenti nei repository locali o remoti.</li> </ol>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#le-coordinate-maven","title":"Le Coordinate Maven","text":"<p>Il file pom.xml definisce le coordinate Maven per ciascun artefatto. Le coordinate sono composte da tre parti obbligatorie: groupId, artifactId e version. Questi elementi identificano in modo univoco un artefatto all'interno del repository Maven, agendo come un sistema di coordinate per i progetti.</p> <ol> <li>groupId: Questo identificatore \u00e8 generalmente univoco all'interno di un'organizzazione o di un progetto. Non \u00e8 necessario che il groupId corrisponda alla struttura del pacchetto del progetto, ma \u00e8 una buona pratica seguire la convenzione.</li> <li>artifactId: L'artifactId \u00e8 generalmente il nome del progetto. Insieme al groupId, definisce univocamente un progetto nel repository. \u00c8 raro che venga menzionato separatamente, poich\u00e9 il groupId \u00e8 spesso condiviso tra pi\u00f9 progetti all'interno della stessa organizzazione.</li> <li>version: La version specifica la versione dell'artefatto. Questo campo \u00e8 fondamentale per mantenere il versionamento del progetto e gestire modifiche e aggiornamenti.</li> </ol>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#snapshot-vs-release","title":"SNAPSHOT vs Release","text":"<p>La gestione delle versioni in Maven segue una logica rigorosa per garantire la riproducibilit\u00e0 della build. Le versioni possono essere classificate in due categorie principali:</p> <ul> <li>SNAPSHOT: Una versione contrassegnata dal suffisso -SNAPSHOT (es. 1.2.0-SNAPSHOT) indica un artefatto in fase di evoluzione.   Quando un progetto dipende da uno SNAPSHOT, Maven controlla periodicamente (solitamente ogni 24 ore o forzando con -u, Aggiornamento Dinamico) se esiste una versione pi\u00f9 recente nel repository remoto.</li> <li>Release: Una versione senza suffissi o con suffissi puramente numerici (es. 1.2.0) \u00e8 considerata finale. Una volta pubblicata in un repository di release, una versione non deve mai essere sovrascritta. Se il codice cambia, deve necessariamente cambiare la versione (es. 1.2.1). Garantisce che una build eseguita oggi produca lo stesso identico risultato tra dieci anni, poich\u00e9 le dipendenze di release sono statiche.</li> </ul>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#build-lifecycle","title":"Build Lifecycle","text":"<p>Il Build Lifecycle di Maven \u00e8 un concetto centrale che definisce il flusso di esecuzione delle fasi di costruzione di un progetto, dal momento in cui avvii la build fino alla sua conclusione. Il ciclo di vita di Maven \u00e8 suddiviso in una serie di fasi, e ogni fase rappresenta una parte specifica del processo di compilazione, test e distribuzione del progetto.</p> <p>Maven prevede tre cicli di vita principali:</p> <ol> <li>default: gestisce il processo di build del progetto.</li> <li>clean: gestisce la rimozione dei file generati durante la build.</li> <li>site: gestisce la creazione del sito web del progetto (documentazione e altre risorse).</li> </ol>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#default-build-lifecycle-ciclo-di-vita-predefinito","title":"Default Build Lifecycle (Ciclo di Vita Predefinito)","text":"<p>Il ciclo di vita predefinito \u00e8 il pi\u00f9 importante e definisce le fasi che vengono eseguite durante la costruzione del progetto. Esso include fasi come la compilazione, l'esecuzione dei test, la creazione del pacchetto e il deploy.</p> <p>Le fasi principali del ciclo di vita default sono:</p> <ol> <li>validate: Verifica che il progetto sia corretto e che tutte le informazioni necessarie siano disponibili.</li> <li>compile: Compila il codice sorgente del progetto.</li> <li>test: Esegue i test unitari sul codice compilato per verificare che funzioni correttamente.</li> <li>package: Crea il pacchetto del progetto (ad esempio, un file JAR, WAR o EAR) a partire dal codice compilato e dai file di configurazione.</li> <li>verify: Verifica che il pacchetto sia valido e che i test siano passati.</li> <li>install: Installa il pacchetto nel repository locale di Maven, rendendolo disponibile per altri progetti.</li> <li>deploy: Distribuisce il pacchetto nel repository remoto per renderlo accessibile ad altri sviluppatori o progetti.</li> </ol>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#goal","title":"GOAL","text":"<p>Un goal appresenta un'azione specifica da eseguire durante un ciclo di vita di build. I goal sono l'unit\u00e0 pi\u00f9 piccola e specifica di un processo Maven e sono generalmente associati ai plugin. Ogni plugin pu\u00f2 avere uno o pi\u00f9 goal, e ogni goal \u00e8 progettato per eseguire una particolare attivit\u00e0, come la compilazione del codice, l'esecuzione dei test, la creazione del pacchetto o la distribuzione.</p> <p>Questi goal possono essere eseguiti direttamente dalla linea di comando o come parte di un ciclo di vita di Maven.</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#maven-profiles","title":"Maven Profiles","text":"<p>I profili consentono di adattare il processo di build a contesti specifici (sviluppo locale, ambiente di test, produzione) senza modificare il codice sorgente. Essi permettono di sovrascrivere o integrare le configurazioni standard del pom.xml.</p> <p>Un profilo pu\u00f2 essere attivato in diversi modi:</p> <ul> <li>Esplicito: Tramite riga di comando usando il flag -P (es. mvn clean install -Pproduction).</li> <li>Impostazioni di Sistema: Basato sulla versione del JDK, sul sistema operativo o sulla presenza/assenza di un file specifico.</li> <li>Default: Dichiarando \\true nella configurazione del profilo.</li> </ul>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#plugin-e-mojo","title":"Plugin e Mojo","text":"<p>I plugin sono la funzionalit\u00e0 centrale di Maven che consentono il riutilizzo della logica di build comune tra pi\u00f9 progetti. Questo avviene eseguendo un'azione (ad esempio, creare un file WAR o compilare i test unitari) nel contesto del POM. Il comportamento dei plugin pu\u00f2 essere personalizzato tramite un set di parametri unici che vengono esposti nella descrizione di ciascun goal del plugin (o Mojo).</p> <p>Un Mojo \u00e8 un goal in Maven, e i plugin consistono in uno o pi\u00f9 goal (Mojos). I Mojos possono essere definiti come classi Java annotate. Un Mojo specifica i metadati su un goal: il nome del goal, a quale fase del ciclo di vita appartiene, e i parametri che si aspetta.</p> <p>I goal dei plugin sono legati a fasi specifiche del ciclo di vita.</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#archetipi","title":"Archetipi","text":"<p>Gli archetipi in Maven sono modelli predefiniti utilizzati per creare nuovi progetti cio\u00e8 \u00e8 un template che fornisce una struttura base per un progetto, compreso il file pom.xml, la struttura delle directory, e talvolta anche codice di esempio. Gli archetipi semplificano la creazione di nuovi progetti, standardizzando la configurazione iniziale e riducendo il tempo necessario per configurare un nuovo progetto Maven.</p> <p>Quando crei un progetto utilizzando un archetipo, Maven esegue una serie di operazioni:</p> <ol> <li>Creazione di una struttura di directory predefinita: Ogni archetipo contiene una struttura di directory predefinita</li> <li>Generazione di un pom.xml di base: Ogni archetipo fornisce un file pom.xml preconfigurato che definisce le dipendenze, i plugin, e le configurazioni di base per il progetto.</li> <li>Codice di esempio (facoltativo): Alcuni archetipi possono includere codice di esempio per un tipo di applicazione specifico.</li> </ol> <p>mvn archetype:generate -DgroupId=com.example -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false</p> <ul> <li>-DgroupId=com.example definisce l'ID del gruppo del progetto.</li> <li>-DartifactId=my-app definisce l'ID dell'artefatto (nome del progetto).</li> <li>-DarchetypeArtifactId=maven-archetype-quickstart specifica l'archetipo da usare (in questo caso, un archetipo di base per un'applicazione Java).</li> <li>-DinteractiveMode=false evita di dover rispondere a delle domande durante la creazione del progetto.</li> </ul>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#dipendenze","title":"Dipendenze","text":"<p>Le dipendenze sono librerie o altri progetti di cui il tuo progetto ha bisogno per essere compilato e funzionare correttamente. Maven gestisce le dipendenze in modo centralizzato, scaricando automaticamente le librerie richieste da repository remoti o locali.</p> <p>Le dipendenze in Maven sono definite nel file pom.xml del progetto, utilizzando l'elemento \\. Ogni dipendenza \u00e8 identificata da tre informazioni principali: <ol> <li>groupId: Identifica il gruppo o l'organizzazione che mantiene la libreria.</li> <li>artifactId: Il nome della libreria o dell'artefatto.</li> <li>version: La versione specifica della libreria.</li> <li>Dipendenze di compilazione (Compile Dependencies):</li> </ol> <p>Sono necessarie per compilare il codice. Queste dipendenze vengono incluse automaticamente in fase di compilazione e in fase di esecuzione. Sono definite nel blocco \\ nel pom.xml."},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#dipendenze-di-test-test-dependencies","title":"Dipendenze di test (Test Dependencies)","text":"<p>Sono necessarie solo durante la fase di test e non vengono incluse nel pacchetto finale. Queste dipendenze sono definite utilizzando l'elemento \\test.</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#dipendenze-runtime-runtime-dependencies","title":"Dipendenze runtime (Runtime Dependencies)","text":"<p>Sono necessarie per l'esecuzione del programma, ma non per la compilazione. Vengono incluse solo in fase di esecuzione.</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#dipendenze-di-sistema-system-dependencies","title":"Dipendenze di sistema (System Dependencies)","text":"<p>Sono librerie che devono essere fornite manualmente, ad esempio librerie che non sono disponibili in un repository pubblico. Queste dipendenze sono identificate con un percorso locale.</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#dipendenze-di-provided-provided-dependencies","title":"Dipendenze di provided (Provided Dependencies)","text":"<p>Sono necessarie solo durante la fase di compilazione e test, ma sono fornite in fase di esecuzione dall'ambiente in cui il progetto verr\u00e0 eseguito.</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#scope-delle-dipendenze","title":"Scope delle dipendenze","text":"<p>Lo scope di una dipendenza definisce in quale fase del ciclo di vita del progetto la dipendenza \u00e8 necessaria.</p> <ol> <li>compile: \u00c8 il default e indica che la dipendenza \u00e8 necessaria per la compilazione, il test, l'esecuzione e la distribuzione.</li> <li>provided: Indica che la dipendenza \u00e8 necessaria per la compilazione e i test, ma sar\u00e0 fornita dal contenitore o dall'ambiente di esecuzione (ad esempio, un server web come Tomcat).</li> <li>runtime: La dipendenza \u00e8 necessaria solo durante l'esecuzione del programma, ma non durante la compilazione.</li> <li>test: La dipendenza \u00e8 necessaria solo durante la fase di test e non per la compilazione o l'esecuzione.</li> <li>system: La dipendenza \u00e8 necessaria per la compilazione e l'esecuzione, ma deve essere fornita manualmente con un percorso specificato nel pom.xml.</li> </ol> <p>Le dipendenze in Maven possono essere transitive, cio\u00e8 che se il tuo progetto dipende da una libreria A e la libreria A dipende a sua volta da una libreria B, Maven gestir\u00e0 automaticamente anche la dipendenza di B. Questo ti evita di dover gestire manualmente ogni dipendenza indiretta.</p>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#multi-module-projects","title":"Multi-module projects","text":"<p>Un progetto multi-modulo \u00e8 un progetto che contiene pi\u00f9 moduli (o sotto-progetti) gestiti sotto un'unica configurazione. Ogni modulo pu\u00f2 essere un progetto Maven indipendente, ma sono tutti gestiti insieme in modo centralizzato da un progetto padre.</p> <p>Maven esegue la build dei moduli nell'ordine in cui sono elencati nel pom.xml del progetto padre. Ogni modulo dipende dalle configurazioni definite nel progetto padre, ma pu\u00f2 anche avere configurazioni specifiche se necessario.</p> <p>In progetti complessi, si usa \\ nel POM padre per definire le versioni delle librerie in un unico punto. I moduli figli erediteranno la versione senza doverla specificare, evitando conflitti di versione (il cosiddetto \"Dependency Hell\")."},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#ereditarieta-vs-aggregazione","title":"Ereditariet\u00e0 vs Aggregazione","text":"<ul> <li>Ereditariet\u00e0 (Parent POM): I moduli figli ereditano configurazioni e dipendenze dal padre.</li> <li>Aggregazione (Multi-module): Un progetto \"contenitore\" che permette di compilare pi\u00f9 moduli con un unico comando.</li> </ul>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#maven-properties","title":"Maven Properties","text":"<p>Permettono di centralizzare valori costanti (es. versioni delle librerie o encoding dei file):</p> <pre><code>&lt;properties&gt;\n    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;spring.version&gt;6.1.0&lt;/spring.version&gt;\n&lt;/properties&gt;\n</code></pre>"},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#il-file-settingsxml","title":"Il file <code>settings.xml</code>","text":"<p>Situato in <code>~/.m2/settings.xml</code>, non riguarda il progetto ma l'utente/ambiente. Contiene:</p> <p>-Credenziali per i repository remoti (\\). -Configurazione di Proxy aziendali. -Mirror dei repository centrali."},{"location":"30_Frameworks_Tools/Building_Tools/Maven/#guida-ai-comandi-utili-cli","title":"Guida ai Comandi Utili (CLI)","text":"Comando Descrizione <code>mvn clean</code> Rimuove la directory <code>target</code>. Utile per forzare una ricompilazione totale. <code>mvn clean install</code> Pulisce e installa il pacchetto nel repository locale. <code>mvn clean install -U</code> Pulisce, installa e forza l'aggiornamento delle dipendenze SNAPSHOT. <code>mvn compile</code> Compila solo il codice sorgente in <code>src/main/java</code>. <code>mvn test</code> Esegue i test unitari definiti nel progetto. <code>mvn package</code> Compila e crea l'archivio (JAR/WAR) nella cartella <code>target</code>. <code>mvn install</code> Copia il pacchetto nel repository locale per usarlo in altri progetti. <code>mvn deploy</code> Carica l'artefatto finale in un repository remoto (es. Nexus o Artifactory). <code>mvn dependency:tree</code> Mostra l'albero gerarchico di tutte le dipendenze. <code>mvn help:effective-pom</code> Mostra il POM finale con parent e profili attivi. <code>mvn archetype:generate</code> Avvia il wizard per creare un nuovo progetto da template. <code>mvn archetype:catalog</code> Mostra la lista di tutti gli archetipi disponibili. <code>mvn clean install -DskipTests</code> Build completa saltando l'esecuzione dei test. <code>mvn release:prepare</code> Prepara il rilascio di una nuova versione del progetto. <code>mvn release:perform</code> Esegue il rilascio effettivo del progetto. <code>maven-release-plugin</code> Plugin Maven per automatizzare il processo di rilascio."},{"location":"30_Frameworks_Tools/Spring/Spring_MOC/","title":"\ud83d\uddfa\ufe0f Spring (MOC)","text":"<p>Stato: #seed | Collegamenti: index</p>"},{"location":"30_Frameworks_Tools/Spring/Spring_MOC/#indice-argomenti","title":"\ud83d\udccc Indice Argomenti","text":""},{"location":"40_Software_Engineering/DevOps/DevOps_MOC/","title":"\ud83d\uddfa\ufe0f DevOps (MOC)","text":"<p>Area: [[40_Design_Patterns]]</p>"},{"location":"40_Software_Engineering/DevOps/DevOps_MOC/#indice","title":"\ud83d\udccc Indice","text":""},{"location":"40_Software_Engineering/Software_Design/Software_Design_MOC/","title":"\ud83d\uddfa\ufe0f Software Design (MOC)","text":"<p>Area: [[40_Design_Patterns]]</p>"},{"location":"40_Software_Engineering/Software_Design/Software_Design_MOC/#indice","title":"\ud83d\udccc Indice","text":""},{"location":"40_Software_Engineering/Versioning/Versioning_MOC/","title":"\ud83d\uddfa\ufe0f Versioning (MOC)","text":"<p>Area: [[40_Design_Patterns]]</p>"},{"location":"40_Software_Engineering/Versioning/Versioning_MOC/#indice","title":"\ud83d\udccc Indice","text":""},{"location":"50_Artificial_Intelligence/Deep_Learning/Deep_Learning_MOC/","title":"\ud83d\uddfa\ufe0f Deep Learning (MOC)","text":"<p>Area: [[60_Artificial_Intelligence]]</p>"},{"location":"50_Artificial_Intelligence/Deep_Learning/Deep_Learning_MOC/#indice","title":"\ud83d\udccc Indice","text":""},{"location":"50_Artificial_Intelligence/Machine_Learning/Machine_Learning_MOC/","title":"\ud83d\uddfa\ufe0f Machine Learning (MOC)","text":"<p>Area: [[60_Artificial_Intelligence]]</p>"},{"location":"50_Artificial_Intelligence/Machine_Learning/Machine_Learning_MOC/#indice","title":"\ud83d\udccc Indice","text":""},{"location":"98_Project_Journal/2026_Learning_Log/","title":"2026 Learning Log","text":"<p>Stato: #seed</p>"},{"location":"98_Project_Journal/2026_Learning_Log/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"99_Meta/Templates/Technical_Note_Template/","title":"Technical Note Template","text":"<p>Stato: #seed</p>"},{"location":"99_Meta/Templates/Technical_Note_Template/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"}]}