{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83c\udf10 Engineering KB: Master MOC","text":"<p>Stato: #active \"L'organizzazione della conoscenza \u00e8 l'inizio della saggezza ingegneristica.\"</p> <p>Benvenuto nel punto di ingresso centrale del tuo secondo cervello tecnico. Questa mappa collega tutte le macro-aree della tua conoscenza.</p>","tags":["hub","directory"]},{"location":"#aree-principali","title":"\ud83c\udfd7\ufe0f Aree Principali","text":"","tags":["hub","directory"]},{"location":"#1-10_theory_moc","title":"1. [[10_Theory_MOC]]","text":"<p>Fondamenta scientifiche e teoriche.</p> <ul> <li>Algoritmi, Strutture Dati, Sistemi Operativi e Reti.</li> </ul>","tags":["hub","directory"]},{"location":"#2-20_languages_moc","title":"2. [[20_Languages_MOC]]","text":"<p>Linguaggi di programmazione e sintassi core.</p> <ul> <li>[[Python_MOC]], [[Java_MOC]]</li> </ul>","tags":["hub","directory"]},{"location":"#3-30_frameworks_tools_moc","title":"3. [[30_Frameworks_Tools_MOC]]","text":"<p>Ecosistemi di sviluppo e strumenti specifici.</p> <ul> <li>[[Android_MOC]], [[Spring_MOC]].</li> </ul>","tags":["hub","directory"]},{"location":"#4-40_design_patterns_moc","title":"4. [[40_Design_Patterns_MOC]]","text":"<p>Architettura del software e qualit\u00e0 del codice.</p> <ul> <li>[[SOLID_Principles]].</li> </ul>","tags":["hub","directory"]},{"location":"#operativita-quotidiana","title":"\ud83d\udcdd Operativit\u00e0 Quotidiana","text":"<ul> <li>[[00_Inbox]]: Note rapide e bozze da elaborare.</li> <li>[[50_Project_Journal]]: Log delle decisioni tecniche e post-mortem dei progetti.</li> </ul>","tags":["hub","directory"]},{"location":"#sistema-meta","title":"\ud83d\udee0\ufe0f Sistema (Meta)","text":"<ul> <li>[[99_Meta_MOC]]: Gestione di template e configurazioni della KB.</li> </ul>","tags":["hub","directory"]},{"location":"00_Inbox/","title":"README","text":"<p>Stato: #seed</p>"},{"location":"00_Inbox/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"10_Theory/Algorithms/Complexity_Basics/","title":"Complexity Basics","text":"<p>Stato: #seed</p>"},{"location":"10_Theory/Algorithms/Complexity_Basics/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"10_Theory/Data_Structures/Trees_and_Graphs/","title":"Trees and Graphs","text":"<p>Stato: #seed</p>"},{"location":"10_Theory/Data_Structures/Trees_and_Graphs/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"20_Languages/Java/Java_MOC/","title":"\ud83d\uddfa\ufe0f Java (MOC)","text":"<p>Stato: #seed | Collegamenti: [[index]]</p>"},{"location":"20_Languages/Java/Java_MOC/#indice-argomenti","title":"\ud83d\udccc Indice Argomenti","text":""},{"location":"20_Languages/Python/Python_MOC/","title":"Python MOC","text":"<p>Stato: #seed</p>"},{"location":"20_Languages/Python/Python_MOC/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"30_Frameworks_Tools/Android/Activity_e_Fragment/","title":"Activity e Fragment","text":""},{"location":"30_Frameworks_Tools/Android/Activity_e_Fragment/#activity","title":"ACTIVITY","text":"<p>Un'Activity \u00e8 una componente visibile di un'applicazione Android che permette agli utenti di interagire con essa. Un'app pu\u00f2 essere composta da pi\u00f9 Activity, ciascuna delle quali svolge un compito specifico ed \u00e8 indipendente dalle altre. Ogni Activity \u00e8 formata da una serie di View, ovvero gli elementi dell'interfaccia utente</p>"},{"location":"30_Frameworks_Tools/Android/Activity_e_Fragment/#ciclo-di-vita","title":"CICLO DI VITA","text":"<p>Il sistema operativo Android gestisce il ciclo di vita di un'Activity, determinando quando questa viene creata, avviata, arrestata o distrutta. La classe Activity fornisce diversi metodi di callback che permettono agli sviluppatori di definire il comportamento dell'applicazione nei vari stati dell'Activity.</p> <p></p> <p>L\u2019activity pu\u00f2 essere avviata dall\u2019utente che preme sull\u2019icona dell\u2019applicazione, oppure da un\u2019altra activity tramite un intent.</p> <p>Quando un'app viene avviata Zygote clona se stesso per creare un nuovo processo, riducendo il tempo di avvio. Questo nuovo processo eredita le classi e le librerie gi\u00e0 caricate, ottimizzando l'esecuzione.</p> <p>L'ActivityManagerService (AMS) \u00e8 il componente principale che gestisce il ciclo di vita delle Activity e coordina le transizioni tra di esse.</p> <ul> <li>Riceve la richiesta di avvio dell'app.</li> <li>Controlla se il processo dell\u2019app \u00e8 gi\u00e0 in esecuzione o se deve essere creato.</li> <li>Comunica con il Zygote per avviare un nuovo processo se necessario.</li> </ul> <p>Dopo l\u2019avvio dell\u2019app, vengono chiamate tre metodi per creare un activity.</p> <ol> <li>onCreate() in questo momento l\u2019activity viene effetivamente creata e in questa fase si inizializzano tutte le risorse necessarie. Viene carocato in memoria l\u2019albero delle views che formano l\u2019activity.    La onCreate() di un'Activity non deve essere bloccante perch\u00e9 viene eseguita nel Main Thread, lo UI Thread. Questo thread \u00e8 responsabile della gestione dell\u2019interfaccia utente e dell\u2019interazione con l\u2019utente. Se il codice in onCreate() \u00e8 troppo pesante Android termina forzatamente le app che bloccano il Main Thread.</li> <li>Subito dopo, Android chiama il metodo onStart() che permette all\u2019Activity di essere visibile all\u2019utente, ma non \u00e8 ancora interattiva. L\u2019interfaccia viene renderizzata visualizzando le componenti che formano l\u2019activity.</li> <li>Con l\u2019invocazione di onResume() l\u2019Activity diventa pienamente attiva e interattiva e l\u2019utente pu\u00f2 effetti interagire con le componenti dell\u2019appliczione. Gli event generati vengono catturati dal looper e fa cambiare stato all\u2019activity. Durante questa fase, l\u2019Activity \u00e8 in primo piano e qualsiasi altra Activity aperta in precedenza \u00e8 stata messa in pausa o nascosta.</li> </ol> <p>Dopo queste tre operazioni l\u2019applicazione si trova nello stato di running e l\u2019utente pu\u00f2 interagire. Se l'utente non interagisce l\u2019activity passa in uno stato di onPause(), che indica che l\u2019activity non \u00e8 pi\u00f9 in primo piano, ma questo non vuol dire che debba essere distrutta.</p> <p>Quando la tua attivit\u00e0 non \u00e8 pi\u00f9 visibile all'utente, ma \u00e8 ancora in memoria viene invocata la chiamata onStop() e da qui inizia il ciclo di distruzione e rilascio delle risorse dell\u2019activity.</p> <p>La differenza tra onStop() e onPause() \u00e8 che nella onPause() il lavoro relativo all'interfaccia utente continua anche se l'utente sta visualizzando la tua attivit\u00e0 in modalit\u00e0 multi-finestra.</p> <p>Con la onRestart() tato transitorio si verifica solo se un'Activity fermata viene riavviata. onRestart() viene chiamato tra onStop() e onStart(). onDestroy() viene chiamato prima che l'Activity venga distrutta. Questo pu\u00f2 avvenire perch\u00e9 l'Activity sta terminando, perch\u00e9 il sistema sta distruggendo l'Activity per risparmiare risorse, o a causa di un cambiamento di configurazione. \u00c8 importante eseguire qui la pulizia finale delle risorse. Tuttavia, non si dovrebbe fare affidamento su onDestroy() per salvare dati importanti, in quanto potrebbe non essere sempre chiamato.</p>"},{"location":"30_Frameworks_Tools/Android/Activity_e_Fragment/#back-stack-e-navigazione-fra-le-activity","title":"BACK STACK E NAVIGAZIONE FRA LE ACTIVITY","text":"<p>In Android, le Activity sono gestite attraverso uno stack di Activity, il back stack, gestito in modo FIFO.</p> <p>Il back stack \u00e8 un insieme di Activity che l'utente ha visitato e a cui pu\u00f2 tornare premendo il pulsante Indietro del dispositivo. Una task \u00e8 un insieme di Activity correlate all'applicazione o ad una specifica interazione dell'utente e ha il suo back stack e che possiamo gestire insieme.</p> <p>Quando si avvia una nuova Activity, essa viene inserita in cima al back stack e prende il focus dell'utente. L'Activity precedente viene fermata ma rimane disponibile nel back stack, conservando il suo stato attuale. Quando l'utente preme il pulsante Indietro, l'Activity in cima allo stack viene rimossa (e distrutta), e l'Activity precedente riprende.</p> <p>Alla base dello stack sta il launcher e da questo si iniziano ad impilare le activity. Android non rimuover\u00e0 mai le activity tranne se si trova in situazioni critiche del sistema e allora rimuove prima le activity che si trovano in fondo allo stack, evitando di rimuove l\u2019activity attiva.</p> <p>Il back stack non \u00e8 specifico di una singola applicazione; pu\u00f2 contenere Activity di diverse applicazioni lanciate dall'utente in ordine cronologico inverso. Ci\u00f2 significa che premendo il pulsante Indietro, l'utente potrebbe ritrovarsi in un'Activity di un'altra app se l'ha avviata precedentemente.</p> <p> Un\u2019activity pu\u00f2 spostarsi\u00a0inbackground\u00a0quando un utente avvia una nuova attivit\u00e0 o passa alla schermata Home. In background, tutte le attivit\u00e0 dell'attivit\u00e0 vengono arrestate, ma lo stack precedente dell'attivit\u00e0 rimane intatto, perde l'attenzione mentre \u00e8 in corso un'altra attivit\u00e0. R l'attivit\u00e0 pu\u00f2 tornare in primo piano per consentire agli utenti di riprendere da dove hanno interrotto disattivata.</p> <p>Le activity nel back-stack non vengono mai riorganizzate, ma \u00e8 possibili modificare questo andamento lineare dello stack perch\u00e9 in certe situazioni questa gestione non va bene. Esistono cinque modalit\u00e0 di lancio che si possono assegnare all'attributo\u00a0launchMode:</p> <ol> <li>StandardLa modalit\u00e0 predefinita. Il sistema crea una nuova istanza dell'attivit\u00e0 nell'attivit\u00e0 da cui \u00e8 stato avviato e instrada l'intent a quest'ultimo. L'attivit\u00e0 pu\u00f2 essere creata pi\u00f9 volte, ogni istanza pu\u00f2 appartenere ad attivit\u00e0 diverse un'attivit\u00e0 pu\u00f2 avere pi\u00f9 istanze.</li> <li>SingleTopSe nella parte superiore dell'attivit\u00e0 corrente esiste gi\u00e0 un'istanza dell'attivit\u00e0, il sistema instrada l'intent a quell'istanza tramite una chiamata alla sua\u00a0onNewIntent()\u00a0anzich\u00e9 creare una nuova istanza dell'attivit\u00e0. L'attivit\u00e0 \u00e8 creata pi\u00f9 volte, ogni istanza pu\u00f2 appartenere ad attivit\u00e0 diverse e un'attivit\u00e0 pu\u00f2 avere pi\u00f9 istanze (ma solo se l'attivit\u00e0 in alto dello stack posteriore\u00a0non\u00a0\u00e8 un'istanza esistente dell'attivit\u00e0).</li> <li>singleTaskIl sistema crea l'attivit\u00e0 alla base di una nuova attivit\u00e0 o individua la su un'attivit\u00e0 esistente con la stessa affinit\u00e0. Se un'istanza del componente esiste gi\u00e0 un'attivit\u00e0, il sistema instrada all'istanza esistente tramite una chiamata alla sua onNewIntent() anzich\u00e9 creare una nuova istanza. Nel frattempo, tutti gli altri vengono distrutte.</li> <li>singleInstanceIl comportamento \u00e8 lo stesso di\u00a0\"singleTask\", ad eccezione del fatto che il sistema non avvia nessun altro delle attivit\u00e0 nell'attivit\u00e0 che contiene l'istanza. L'attivit\u00e0 \u00e8 sempre l'unico e unico membro della sua attivit\u00e0. Tutte le attivit\u00e0 iniziate da questa si aprono tra per un'attivit\u00e0 a parte.</li> <li>singleInstancePerTaskL'attivit\u00e0 pu\u00f2 essere eseguita solo come attivit\u00e0 principale dell'attivit\u00e0, la prima all'attivit\u00e0 che ha creato l'attivit\u00e0, perci\u00f2 pu\u00f2 esserci una sola istanza di questa attivit\u00e0 in un'attivit\u00e0. A differenza della modalit\u00e0 di avvio di\u00a0singleTask, questa l'attivit\u00e0 pu\u00f2 essere avviata in pi\u00f9 istanze in diverse attivit\u00e0 se\u00a0FLAG_ACTIVITY_MULTIPLE_TASK\u00a0o\u00a0FLAG_ACTIVITY_NEW_DOCUMENT\u00a0\u00e8 stato impostato.</li> </ol> <p>SingleTask e SingleInstancePerTask\u00a0rimuovono tutte le attivit\u00e0 superiori all'attivit\u00e0 iniziale dell'attivit\u00e0.</p> <p>I cambiamenti di configurazione, come la rotazione dello schermo, comportano la distruzione dell'Activity corrente e la creazione di una nuova Activity per adattarsi alla nuova configurazione. Per evitare la perdita di dati durante questi cambiamenti, \u00e8 possibile salvare lo stato dell'istanza dell'Activity.</p> <ol> <li>sovrascrivendo il metodo onSaveInstanceState(Bundle). Lo stato viene salvato come una serie di coppie chiave/valore in un oggetto Bundle che viene passato a onCreate() quando l'Activity viene ricreata. \u00c8 anche possibile utilizzare il callback onRestoreInstanceState() per ripristinare lo stato.</li> <li>Oppure con il model-view-controller</li> </ol>"},{"location":"30_Frameworks_Tools/Android/Activity_e_Fragment/#fragment","title":"FRAGMENT","text":"<p>Un Fragment \u00e8 un componente utilizzato per dividere l'interfaccia utente in parti pi\u00f9 piccole. Un Fragment rappresenta una porzione di UI o di comportamento che vive all\u2019interno di un\u2019Activity, e pu\u00f2 essere riutilizzato o sostituito dinamicamente. Un Fragment riceve i propri eventi di input e ha una propria vista che viene composta da un file di layout apposito. I Fragment possono esistere solo all'interno di un'Activity. Un'attivit\u00e0 pu\u00f2 delegare a un fragment l'esecuzione di compiti.</p> <p>Le Activity fungono da host per i Fragment queste devono conoscere i dettagli di come ospitare i loro Fragment, ma i Fragment non devono conoscere i dettagli delle Activity che le ospitano (loosely couple). Come le attivit\u00e0, i fragment sono \"attivi\" quando appartengono ad una activity focalizzata e in primo piano.</p> <p>Quando un'attivit\u00e0 viene messa in pausa o interrotta, anche i frammenti che contiene vengono messi in pausa e arrestati e anche i frammenti contenuti in un'attivit\u00e0 inattiva sono inattivi.</p> <p>Quando un'attivit\u00e0 viene finalmente distrutta, ogni Fragment che contiene viene ugualmente distrutto. Poich\u00e9 il gestore della memoria Android chiude regolarmente le applicazioni per liberare risorse, anche i frammenti all'interno di tali attivit\u00e0 vengono distrutti.</p> <p>Non dovrebbe esserci alcuna differenza nel passaggio di un frammento da uno stato scollegato, in pausa, interrotto o inattivo allo stato attivo, quindi \u00e8 importante salvare tutto lo stato dell'interfaccia utente e conservare tutti i dati</p> <p>quando un frammento viene sospeso o interrotto. Come un'activity, quando un frammento diventa di nuovo attivo, dovrebbe ripristinare lo stato salvato.</p> <p></p> <p>AUF, Always Use Fragments</p> <p> I Fragment hanno anche un proprio ciclo di vita che \u00e8 simile a quello di un'attivit\u00e0. Questo \u00e8 importante perch\u00e9, visto che un fragment lavora per conto di un'attivit\u00e0, il suo stato dovrebbe riflettere lo stato dell'attivit\u00e0. Pertanto, ha bisogno di metodi del ciclo di vita corrispondenti per gestire il lavoro dell'attivit\u00e0.</p> <p>I callback del ciclo di vita di un Fragment includono</p> <ul> <li>onCreateView(): il valore restituito di questo metodo deve essere un'istanza di View affinch\u00e9 il Fragment abbia un'interfaccia utente visibile</li> <li>onDestroyView(): Ci sono anche callback per onActivityCreated e callback che vengono attivati quando un Fragment viene aggiunto (onAttached) a o rimosso (onDetached) dall'UI utilizzando i metodi di FragmentTransaction.</li> <li>I metodi onAttach(Activity), onCreate(Bundle) e onCreateView(...) vengono chiamati quando si aggiunge il fragment al FragmentManager.</li> <li>Il metodo onActivityCreated(...) viene chiamato dopo che il metodo onCreate(...) dell'attivit\u00e0 ospitante \u00e8 stato eseguito.</li> <li>Il FragmentManager di un'attivit\u00e0 \u00e8 responsabile della chiamata dei metodi del ciclo di vita dei fragment nella sua lista.</li> </ul> <p>La vista di un fragment viene generalmente inflata nel metodo onCreateView().</p> <p>Per aggiungere un fragment a un'attivit\u00e0 nel codice, si effettuano chiamate esplicite al FragmentManager dell'attivit\u00e0 che \u00e8 responsabile della gestione dei fragment e dell'aggiunta delle loro viste alla gerarchia delle viste dell'attivit\u00e0.</p> <p>Il FragmentManager gestisce due cose:</p> <ul> <li>un elenco di fragment</li> <li>stack di back delle transazioni di fragment.</li> </ul> <p>Per ottenere il FragmentManager, si usa</p> <ul> <li>getSupportFragmentManager(), se si estende AppCompatActivity o FragmentActivity;</li> <li>getFragmentManager(), se si estende Activity e il fragment estende android.app.Fragment o PreferenceFragment).</li> </ul> <p>Le FragmentTransaction vengono utilizzate per aggiungere, rimuovere, allegare, staccare o sostituire i fragment nell'elenco dei fragment in fase di runtime. Il FragmentManager mantiene uno stack di back delle transazioni di fragment su cui \u00e8 possibile navigare.</p> <p>Il metodo FragmentManager.beginTransaction() crea e restituisce un'istanza di FragmentTransaction. La classe FragmentTransaction utilizza una fluent interface: i metodi che configurano FragmentTransaction restituiscono un FragmentTransaction invece di void, il che consente di concatenarli.</p> <ul> <li>Il metodo add() della FragmentTransaction ha due parametri: un ID del container view e il newFragment. L'ID del container view \u00e8 l'ID risorsa del FrameLayout definito nel layout dell'attivit\u00e0. Un ID del container view ha indica al FragmentManager dove nella vista dell'attivit\u00e0 dovrebbe apparire la vista del fragment e viene utilizzato come identificatore univoco per un fragment nell'elenco del FragmentManager.</li> </ul> <p>Quando \u00e8 necessario recuperare il Fragment dal FragmentManager, lo si richiede tramite l'ID del container view utilizzando fm.findFragmentById(R.id.fragment_container).</p> <p>\u00c8 prassi comune aggiungere un metodo statico newInstance() alla classe Fragment. Questo metodo crea l'istanza del fragment, raggruppa e imposta i suoi argomenti.</p>"},{"location":"30_Frameworks_Tools/Android/Activity_e_Fragment/#stato-di-un-fragment","title":"Stato di un Fragment","text":"<p>Ogni istanza di fragment pu\u00f2 avere un oggetto Bundle allegato. Questo bundle contiene coppie chiave-valore,</p> <p>Per creare gli argomenti di un fragment, si crea prima un oggetto Bundle. Quindi, si utilizzano i metodi \"put\" specifici del tipo di Bundle (simili a quelli di Intent) per aggiungere argomenti al bundle.</p> <p>Per allegare il bundle degli argomenti a un fragment, si chiama Fragment.setArguments(Bundle). L'allegamento degli argomenti a un fragment deve essere fatto dopo che il fragment \u00e8 stato creato ma prima che venga aggiunto a un'attivit\u00e0.</p> <p>Quando un fragment deve accedere ai suoi argomenti, chiama il metodo getArguments() del Fragment e quindi uno dei metodi \"get\" specifici del tipo di Bundle.</p>"},{"location":"30_Frameworks_Tools/Android/Activity_e_Fragment/#comunicazione-tra-activity-e-fragment","title":"Comunicazione tra Activity e Fragment","text":"<p>Per delegare funzionalit\u00e0 all'attivit\u00e0 ospitante, un fragment definisce in genere un'interfaccia di callback denominata Callbacks. Questa interfaccia definisce il lavoro che il fragment deve far svolgere all'attivit\u00e0 ospitante. Qualsiasi attivit\u00e0 che ospiter\u00e0 il fragment deve implementare questa interfaccia.</p> <p>Con un'interfaccia di callback, un fragment \u00e8 in grado di chiamare metodi sulla sua attivit\u00e0 ospitante senza dover sapere nulla di quale attivit\u00e0 lo stia ospitando.</p> <p>L'attivit\u00e0 viene assegnata nel metodo del ciclo di vita del Fragment: onAttach(Activity activity). Questo metodo viene chiamato quando un fragment viene collegato a un'attivit\u00e0, sia che sia stato conservato o meno.</p> <p>Allo stesso modo, la variabile viene impostata su null nel corrispondente metodo del ciclo di vita in diminuzione: onDetach(). La variabile viene impostata su null qui perch\u00e9 in seguito non \u00e8 possibile accedere all'attivit\u00e0 o contare sulla sua continua esistenza.</p>"},{"location":"30_Frameworks_Tools/Android/Activity_e_Fragment/#conservazione-dei-fragment","title":"Conservazione dei Fragment","text":"<p>Per impostazione predefinita, la propriet\u00e0 retainInstance di un fragment \u00e8 false. Ci\u00f2 significa che non viene conservato e viene distrutto e ricreato alla rotazione insieme all'attivit\u00e0 che lo ospita. La chiamata a setRetainInstance(true) conserva il fragment. Quando un fragment viene conservato, il fragment non viene distrutto con l'attivit\u00e0. Invece, viene preservato e passato intatto alla nuova attivit\u00e0.</p> <p>Quando si conserva un fragment, si pu\u00f2 contare sul fatto che tutte le sue variabili d'istanza mantengano gli stessi valori.</p> <p>Un fragment conservato non viene distrutto, ma viene staccato dall'attivit\u00e0 morente. Questo mette il fragment in uno stato di conservazione. Il fragment esiste ancora, ma non \u00e8 ospitato da alcuna attivit\u00e0. Lo stato di conservazione viene raggiunto solo quando si verificano due condizioni:</p> <ol> <li>setRetainInstance(true) \u00e8 stato chiamato sul fragment</li> <li>l'attivit\u00e0 ospitante viene distrutta per un cambio di configurazione</li> </ol> <p>Ricever\u00e0 l'evento onDetach quando l'attivit\u00e0 padre viene distrutta, seguito dagli eventi onAttach, onCreateView e onActivityCreated quando viene creata un'istanza della nuova attivit\u00e0 padre.</p>"},{"location":"30_Frameworks_Tools/Android/Android/","title":"COMPUTAZIONE PERVASIVA","text":"<p>Con lo sviluppo delle nuove tecnologie che ha portato alla nascita dei dispositivi di compilazione portabili \u00e8 nata una nuova forma di computazione, quella pervasiva.</p> <p>Essendo i dispositivo mobili e non pi\u00f9 fissi si \u00e8 dovuto cercare un nuovo modo di far comunicare i vari dispositivi per via delle connessioni precarie e in continuo cambiamento. Si cerca di progettare anche un software che sia in grado di utilizzare meno risorse possibili e che abbiano una potenza di calcolo minore per evitare di esaurire le risorse del dispositivo punto di tutto questo si occupa l'anno mobile computing. Questi dispositivi pervasivi sono sistemi distribuiti e quindi questi problemi dei sistemi distribuiti e mobile fanno parte del pervasive computing a cui si aggiungono altri problemi come la scalabilit\u00e0 invisibilit\u00e0 la comunicazione remota ecc.</p> <p>Non tutti gli obiettivi del pervasive computer sono stati realizzati infatti creare uno smartplace, uno spazio in cui ci sono dispositivi di calcoli in modo da calcolare il mondo fisico e cyber fisico \u00e8 ancora difficile da realizzare, ma non perch\u00e9 non possediamo le tecnologie adeguate ma perch\u00e9 dobbiamo migliorare i collegamenti.</p> <p>\u00c8 necessario rendere questi dispositivi invisibili, l'uomo non si deve accorgere che ci sono in modo che il mondo fisico e il cyber fisico si fondono in un solo spazio. Un altro problema \u00e8 dovuto al numero sempre crescendo i dispositivi che si connettono tra loro quindi si cerca di realizzare la scalabilit\u00e0 localizzata cio\u00e8 di mantenere le stesse qualit\u00e0 di servizi ma man mano che aumentano i nuovi dispositivi.</p> <p>S\u00ec cerca di mascherare le condizioni di non uniformit\u00e0 dovute diversi dispositivi presenti che possono impedire di collaborare fra loro cercando di creare un sistema per nascondere alle domande e questi problemi.</p> <p>La computazione pervasiva ha modificato anche il modo in cui ci interfacciamo col software perch\u00e9 prima era necessario l'intervento umano per far svolgere qualcosa la macchina mentre oggi il computer \u00e8 in grado di comunicare con tende anche in maniera asincrona.</p> <p>Questo \u00e8 stato reso possibile grazie al fatto che prendono informazioni nel mondo reale tramite i sensori sono in grado di elaborarli e notificare all'uomo qualcosa.</p> <p>Oggi sia una architettura ed Edge cloudcentrica in cui tutti i dispositivi sono connessi tra loro tramite il cloud in cui le risorse informatiche sono regate attraverso la rete internet ospitate e gestite da server remoti.</p> <p>Si provvede di avere un architettura ed internet centrica con cui internet il centro delle connessioni fra i dispositivi e i server. In questo modo l'elaborazione avviene in modo distribuita ai margini della rete contrariamente a come accade in quelle precedenti in cui le elaborazione avviene in economia i server.</p> <p>Nell'architettura di calcolo distribuita ci sono tre segmenti che rappresentano muri diversi di elaborare e archiviare dati a seconda delle distanze dal punto di generazione</p> <p>\ud83d\udccd Edge Computing Alla base di tutto troviamo l\u2019Edge, ovvero il bordo della rete. I dati vengono elaborati il pi\u00f9 vicino possibile alla fonte che li genera, spesso direttamente all\u2019interno del dispositivo stesso. I dati vengono elaborati in tempo reale, senza dover prima inviare i dati a un server esterno.</p> <p>Questo approccio \u00e8 ideale per situazioni in cui la velocit\u00e0 \u00e8 fondamentale, come nelle auto a guida autonoma o nei dispositivi medici. Riduce la latenza, cio\u00e8 il tempo che passa tra l\u2019input e la risposta, e limita il traffico di rete.</p> <p>\ud83c\udf2b\ufe0f Fog Computing Salendo di un livello, troviamo il Fog Computing, un modello pensato per distribuire l\u2019elaborazione pi\u00f9 vicino alla rete, ma non necessariamente sul dispositivo.</p> <p>Nel fog computing, i dati vengono inviati a nodi local, un router o un server che li elaborano e, solo se necessario, li inoltrano al cloud. Questo modello \u00e8 utile quando bisogna elaborare rapidamente grandi quantit\u00e0 di dati provenienti da pi\u00f9 dispositivi, ma non si ha la necessit\u00e0 di farlo in tempo reale estremo.</p> <p>\u2601\ufe0f Cloud Computing Infine, abbiamo il Cloud, che rappresenta l\u2019approccio centralizzato. I dati vengono inviati a server remoti, spesso situati in data center geograficamente lontani. Qui possono essere elaborati con grande potenza computazionale, salvati per lungo tempo o usati per addestrare algoritmi complessi di intelligenza artificiale.</p> <p>Il cloud \u00e8 perfetto per elaborazioni intensive. Tuttavia, presenta limiti in termini di latenza e dipendenza dalla connessione internet.</p> <p>Edge, Fog e Cloud non si escludono a vicenda: collaborano. In un sistema moderno ed efficiente, i dati vengono prima processati localmente (edge), poi aggregati e raffinati in una rete vicina (fog), e infine archiviati o ulteriormente analizzati nel cloud.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#hci","title":"HCI","text":"<p>La Human computer interaction HCI Eh lo studio dell\u2019interazione uomo computer per la progettazione di sistemi informatici che siano usabili e affidabili. Il loro scopo \u00e8 quello di semplificare l\u2019attivit\u00e0 umane e non di ostacolarle. Se hai il computer che le persone offrono diversi modi di interagire fra loro e l\u2019interazione pu\u00f2 essere</p> <ul> <li>diretta cio\u00e8 tramite l\u2019uso del dispositivo e di risposte da parte del calcolatore ;</li> <li>indiretta tramite sensori se analizzano il mondo esterno e danno dei feedback per svolgere azioni</li> </ul> <p>La HCI \u00e8 una materia multidisciplinare che coinvolge</p> <p></p> <p>Il principio base della disciplina \u00e8</p> <p>usabilit\u00e0 cio\u00e8 la facilit\u00e0 con il quale l'utente pu\u00f2 interagire con la macchina per raggiungere obiettivi con efficacia, efficienza e soddisfazione per un certo contesto</p> <p>\u2260</p> <p>accessibilit\u00e0 che indica se un sistema informatico pu\u00f2 essere usato da tutti compreso chi ha disabilit\u00e0</p> <p>Interazione umana</p> <p>L'uomo \u00e8 colui che usa i calcolatori e devono essere progettati per assisterlo. Qui entrano in gioco le scienze cognitive che devono capire le capacit\u00e0 e le limitazioni per progettare in modo corretto un sistema informatico</p> <p>Interazione processo con il quale l'utente fornisce la macchina in un input e la macchina lo processa restituendo un output o viceversa</p> <p>Per la macchina si sono molte forme di IO, ma per l'essere umano sono principalmente i cinque sensi e pi\u00f9 in particolare la vista l'udito e il tatto. Interagiamo con la macchina principalmente con il tatto, le dita fungono da cursore. Solo recentemente siamo in grado di interagire anche con la voce per fornire un input.</p> <p> Vista La vista \u00e8 il principale mezzo con il quale otteniamo informazioni. La percezione visiva si pu\u00f2 dividere in due fasi</p> <ol> <li>ricezione fisica dello stimolo</li> <li>elaborazione e un'interpretazione dello stimolo</li> </ol> <p>Dobbiamo capire come funziona l'occhio e come la mente interpreta gli stimoli per progettare sistemi informatici. La prima cosa da capire \u00e8 cosa l'utente vede punto la vista umana tende ad avere una visione centrale dove l\u2019utente di attento e nota le cose; \u00e8 una visione centrale che trascura le cose che sono fuori da quella centrale.</p> <p>Capire questo ci permette di realizzare un design utile all\u2019utente</p> <p>\ud83e\udc6a le info importanti devono essere al centro del campo</p> <p>\ud83e\udc6a le info meno importanti devono essere pi\u00f9 all'esterno</p> <p>Importante \u00e8 capire anche come percepiamo i colori, dimensioni, e profondit\u00e0 per una buona progettazione delle interfaccia visive. Bisogna definire il contesto in cui gli oggetti si trovano perch\u00e9 diamo sulla base di esso o un'interpretazione diversa dovuta al fatto che possiamo gi\u00e0 conoscere il contesto e le info relative da conoscenze passate. Definiamo correttamente il contesto permette all'utente di capire subito di cosa si tratta ed evita le illusioni ottiche che lo portano in disabilit\u00e0 quindi bisogna definire correttamente le dimensioni degli oggetti dove posizionarli e cos\u00ec via per poter sviluppare una buona interfaccia utente.</p> <p>Udito Un altro canale di output per l'uomo pu\u00f2 essere il canale uditivo grazie al quale siamo in grado di riconoscere i suoni in quanto il nostro sistema filtro i suoni che ascoltiamo per concentrarci sulle informazioni importanti il suono \u00e8 spesso usato nelle interfacce grafiche ad esempio per dare informazioni sullo stato di qualcosa, focalizzare l'attenzione ecc.. quindi per notificare/rafforzare l'idea dell'utente.</p> <p>Tatto Il tatto ci d\u00e0 informazioni sull'ambiente circostante e specialmente nei sistemi informatici \u00e8 la fonte di input ma anche di output. In questo modo siamo in grado di interagire con gli aggettivi fuori dagli smartphone in modo da svolgere determinati compiti. Anche i movimenti importanti perch\u00e9 comporta un elaborazione di informazioni in seguito a uno stimolo ricevuto toccando qualcosa. Ogni movimento richiede tempo che dipende dalle persone dall'et\u00e0 eccetera eccetera. In movimento si valuta con accuratezza cio\u00e8 la precisione del movimento che dipende anche dalla velocit\u00e0 con il quale si reagisce. Quanto si progetta un\u2019interfaccia e bisogna considerare queste caratteristiche del movimento per progettare i bottoni che siano facilmente raggiungibili e premibili. (Pubblicit\u00e0 ingannevole)</p> <p>Il tempo impiegato per colpire un bersaglio \u00e8 una funzione della dimensione del bersaglio della distanza da percorrere</p> <p>Legge di Fitts</p> <p>Dispositivi Il progettista dell'interfaccia deve essere a conoscenza delle propriet\u00e0 del dispositivo e di tutti i fattori che influenzano il comportamento dell'interfaccia perch\u00e9 influenzano la natura dell\u2019interazione.</p> <p>Donald Norman da una definizione di interazione HC stabilimento che si tratta di un ciclo che si compone di due fasi</p> <ol> <li>Esecuzione</li> <li>Valutazione    |    V</li> </ol> <p>L'utente stabilisce l'obiettivo, formula l'intenzione c'\u00e8 l'obiettivo che deve realizzare, esegue le azioni sul dispositivo e percepisce lo stato del sistema e lo interpreta per capire il posto suggestivo per raggiungere l'obiettivo</p> <p>\u00c8 importante che l'utente capisca cosa fare per completare le loro azioni e le interfacce non devono essere di un tralcio anzi devono semplificare il raggiungimento dell'obiettivo.</p> <p>DESIGN SBAGLIATO \ud83e\udc6alapsus cio\u00e8 quando comprendiamo il sistema ma si fanno</p> <p>| errori di distrazione V</p> <p>errori quando si sbaglia perch\u00e9 non si \u00e8 capito il sistema e quindi cosa deve fare per raggiungere l\u2019obiettivo</p> <p>Ergonomia L\u2019ergonomia \u00e8 lo studio delle caratteristiche fisiche dell\u2019interazione quindi come progettare i controlli layout dei dispositivi ecc.</p> <p>L'obiettivo \u00e8 di migliorare come l\u2019utente usi dispositivi per dare migliori prestazioni sull'uso di questi punto questo si riflette anche sul design, su come posizionare gli elementi sulla base dell'utilit\u00e0 del contesto ecc.</p> <p>Quando progettiamo l'interfaccia dobbiamo tenere conto anche di come gli utenti usano i dispositivi infatti secondo studi la maggior parte delle persone usano il dispositivo con una mano sola e usano il pollice per toccare lo schermo, oppure con la seconda mano lo fissiamo oppure usano entrambe le mani quindi in base a come viene utilizzato progettiamo il design mettendo gli elementi importanti nelle parti dello schermo pi\u00f9 facilmente raggiungibili in base alle modalit\u00e0 di uso mentre gli elementi meno utili o di uso frequente nelle parti pi\u00f9 esterne un design corretto porta ad avere una pessima esperienza d'uso per l'utente finale</p>"},{"location":"30_Frameworks_Tools/Android/Android/#architectural-ui-and-data-management-patterns","title":"ARCHITECTURAL UI AND DATA MANAGEMENT PATTERNS","text":"<p>Prima ancora di scrivere codice, \u00e8 importante definire l\u2019architettura del sistema. Progettare l\u2019architettura in anticipo permette di avere una visionechiara di come sar\u00e0 strutturata l\u2019applicazione, come interagiranno i diversi componenti tra loro e quali saranno le dipendenze principali.</p> <p>Questo ha un impatto diretto sulla qualit\u00e0 del progetto nel lungo periodo. Se in futuro sar\u00e0 necessario apportare modifiche, aggiungere funzionalit\u00e0, sostituire una tecnologia, risolvere bug o adattarsi a nuove esigenze\u2026 avere un\u2019architettura solida e ben pensata render\u00e0 tutto pi\u00f9 semplice, veloce e sicuro.</p> <p>\u00c8 necessario strutturare il sistema in modo che sia indipendente dai framework, librerie e linguaggi che usiamo perch\u00e9 cambiano nel tempo: nuove versioni, nuove API, a volte addirittura vengono abbandonati o sostituiti da soluzioni migliori. Se il nostro sistema dipende troppo da queste tecnologie, ogni cambiamento porta ad errori o riscritture pesanti del codice.</p> <p>a modularit\u00e0 \u00e8 uno dei concetti pi\u00f9 importanti. Significa suddividere un sistema in parti indipendenti e riutilizzabili, chiamate moduli o componenti, ognuno dei quali ha una responsabilit\u00e0 chiara e ben definita.</p> <p>Conviene pensare alla modularit\u00e0 cio\u00e8 dividere il codice in moduli in modo che sia pi\u00f9 semplice da capire, da testare, da manutenere e da evolvere. Ogni modulo pu\u00f2 essere sviluppato (e perfino sostituito) senza dover riscrivere tutto il resto. Dobbiamo fare attenzione alle dipendenze circolari che si verificano quando due (o pi\u00f9) moduli dipendono l\u2019uno dall\u2019altro direttamente o indirettamente. Questo crea una situazione di interdipendenza, dove nessuno dei moduli pu\u00f2 essere isolato, testato o riutilizzato in modo indipendente.</p> <p>Il principio che si trova alla base di ogni pattern architetturale \u00e8 la separazione dei problemi in livelli in modo da avere le dipendenze verso un\u2019unica direzione ed evitare le dipendenze circolari. I vari livelli non devono avere riferimenti ai livelli pi\u00f9 esterni di loro, questo violerebbe la modularit\u00e0 e renderebbe quindi i livelli dipendenti fra loro.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#clean-archicture","title":"CLEAN ARCHICTURE","text":"<p>La Clean Architecture mira a creare sistemi intercambiabili con una forte separazione delle preoccupazioni e un accoppiamento debole tra i livelli.</p> <p>L'idea fondamentale di Clean Architecture, concepita da Robert Martin (Uncle Bob), \u00e8 rendere intercambiabile ogni elemento all'interno di un certo confine architetturale, senza richiedere modifiche nei livelli sottostanti.</p> <p>Le dipendenze del codice sorgente possono puntare solo verso l'interno. Questo significa che i livelli interni non devono dipendere da livelli. Questa direzione delle dipendenze \u00e8 fondamentale per ottenere un basso accoppiamento e facilitare il test e la manutenzione.</p> <p>La Clean Architecture divide un'applicazione in diversi livelli con responsabilit\u00e0 distinte:</p> <ol> <li>Domain/Application Core: Contiene le entit\u00e0 e la logica di business dell'applicazione. Questo livello \u00e8 indipendente da qualsiasi framework o dettaglio di implementazione esterna.</li> <li>Use Cases: Il software in questo livello contiene regole aziendali specifiche dell'applicazione ed incapsula e implementa tutti i casi d'uso del sistema. Questi casi d'uso orchestrano il flusso di dati da e verso le entit\u00e0 e indirizzano tali entit\u00e0 per raggiungere gli obiettivi del caso d'uso. I cambiamenti in questo livello non devono influenzare le entit\u00e0 e questo livello non \u00e8 influenzato da modifiche alle componenti esterne come il database, l'interfaccia utente o qualsiasi framework utilizzato. Questo strato \u00e8 isolato da tali problematiche. Tuttavia, modifiche alle funzioni di dominio dell'applicazione influenzeranno i casi d'uso e quindi il software in questo livello.</li> <li>Infrastructure/Frameworks: Contiene i dettagli di implementazione dei sistemi esterni, come database, framework UI, librerie esterne e API. Le implementazioni delle interfacce definite nel livello Application risiedono qui.</li> <li>Interface Adapters: Questo livello funge da ponte tra i livelli Application e Infrastructure. Contiene adapter, presentatori e controller che convertono i dati da un formato all'altro per soddisfare le esigenze dei diversi livelli.</li> <li>API/UI: Il livello pi\u00f9 esterno che presenta l'applicazione all'utente (tramite un'API web o un'interfaccia utente grafica).</li> </ol> <p></p> <p>Per attraversare i confini (cerchi concentrici) si usano i controller e i Presenter che comunicano con i casi d'uso nel livello successivo.</p> <ol> <li>l'esecuzione inizia nel controller</li> <li>si sposta attraverso il caso d'uso</li> <li>finisce per essere eseguito nel presenter.</li> </ol> <p>Per implementare questa logica si utilizza il principio di inversione delle dipendenze che consente ad A di chiamare metodi su un'astrazione implementata da B, rendendo possibile per A chiamare B in fase di esecuzione, ma per B di dipendere da un'interfaccia controllata da A in fase di compilazione (invertendo cos\u00ec la tipica dipendenza in fase di compilazione). In fase di esecuzione, il flusso di esecuzione del programma rimane invariato, ma l'introduzione di interfacce significa che diverse implementazioni di queste interfacce possono essere facilmente collegate. La stessa tecnica viene utilizzata per attraversare tutti i confini nelle architetture.</p> <p>Sfruttiamo il polimorfismo dinamico per creare dipendenze del codice sorgente che si oppongono al flusso di controllo in modo che possiamo rispettare la regola delle dipendenze indipendentemente dalla direzione in cui sta andando il flusso di controllo.</p> <p></p> <p>Il Repository Pattern \u00e8 spesso integrato in Clean Architecture come un meccanismo per astrarre l'accesso ai dati. L'interfaccia del repository \u00e8 definita nel livello Application, mentre l'implementazione concreta che interagisce con il database si trova nel livello Infrastructure. Questo rispetta la regola della dipendenza, poich\u00e9 il livello Application dipende solo dall'interfaccia del repository, non dalla specifica implementazione del database.</p> <p>La separazione dei livelli e la regola della dipendenza rendono le applicazioni Clean Architecture pi\u00f9 facili da testare. I casi d'uso e la logica di business nel livello Application possono essere testati unitariamente senza dipendere da database o UI. Le interfacce nel livello Application facilitano il mocking delle dipendenze esterne durante i test. L'accoppiamento debole tra i livelli rende le applicazioni Clean Architecture pi\u00f9 scalabili e manutenibili. Le modifiche a un livello hanno meno probabilit\u00e0 di influenzare altri livelli, facilitando l'aggiornamento e l'aggiunta di nuove funzionalit\u00e0.</p> <p>I ViewModel spesso interagiscono con un Repository per l'accesso ai dati. Questa struttura (UI - ViewModel - Repository - Data Source) in Android pu\u00f2 essere vista come un'implementazione pratica di alcuni principi di Clean Architecture, in particolare la separazione delle preoccupazioni e l'astrazione dell'accesso ai dati.</p> <p>Una potenziale violazione della regola della dipendenza in Clean Architecture quando si implementa il Repository pattern utilizzando direttamente un ORM (come Entity Framework Core) nel livello Infrastructure. Questo introduce una dipendenza del livello Interface Adapters (dove si troverebbe l'implementazione del repository) verso un framework esterno e verso l'I/O diretto, violando la dipendenza verso l'interno. Per risolvere questo, si suggerisce di spostare l'implementazione del repository nel livello Frameworks/Infrastructure e di definire le interfacce nel livello Application.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#livedata","title":"LIVEDATA","text":"<p>LiveData \u00e8 una classe di dati osservabile che \u00e8 legata al ciclo di vita dei componenti UI, come Activity o Fragment. Questo significa che LiveData permette di aggiornare la UI automaticamente quando i dati cambiano, ma solo quando la UI \u00e8 in uno stato attivo, evitando aggiornamenti inutili o errori quando la UI non \u00e8 visibile (ad esempio, se l'Activity \u00e8 in background). Implementa il pattern Observer.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#room","title":"ROOM","text":"<p>Room \u00e8 una libreria di persistenza fornita da Google che si colloca all'interno dei componenti dell'architettura Android, con l'obiettivo di semplificare l'interazione con il database SQLite del sistema operativo, fornendo un livello di astrazione.</p> <p>Room \u00e8 descritta come un modo efficace per creare database e salvare dati. Fornisce un accesso al database SQLite mappando oggetto-relazionale (ORM) basato su annotazioni.</p> <p>L'utilizzo di Room si articola principalmente su tre tipi di classi:</p> <ul> <li>Entit\u00e0: Sono Plain Old Java Objects (POJO) che modellano i dati da trasferire verso e dal database. Sono annotate con @Entity, specificando la tabella del database a cui corrispondono. Almeno una propriet\u00e0 deve essere designata come chiave primaria usando l'annotazione @PrimaryKey. Room crea una tabella nel database per ogni entit\u00e0.</li> <li>DAOs - Data Access Objects: Definiscono l'API per interagire con i dati, contenendo metodi per operazioni come query, inserimenti, aggiornamenti ed eliminazioni. I DAOs sono interfacce o classi astratte annotate con @Dao. Le operazioni sul database sono definite all'interno dei metodi del DAO tramite annotazioni come @Query, @Insert, @Update e @Delete. Room genera l'implementazione concreta di queste interfacce o classi astratte in fase di compilazione.</li> <li>Database: Rappresenta l'interfaccia principale al database SQLite sottostante. \u00c8 una classe astratta che estende RoomDatabase ed \u00e8 annotata con @Database, elencando tutte le entit\u00e0 utilizzate dal database e la sua versione. Contiene metodi astratti che restituiscono istanze dei DAO. Si ottiene un'istanza del database tramite un RoomDatabase.Builder.</li> <li>Relazioni tra Entit\u00e0: Sebbene Room supporti relazioni tramite chiavi esterne definite con l'annotazione @ForeignKey, non supporta riferimenti diretti tra entit\u00e0. Per rappresentare relazioni uno-a-molti o molti-a-molti e accedere agli oggetti correlati, si utilizza l'annotazione @Relation all'interno di una classe POJO separata che contiene i campi per le entit\u00e0 correlate. Per le relazioni molti-a-molti \u00e8 necessario implementare una \"join entity\" che crea la tabella di join associata.</li> </ul> <p></p> <p>In Room, le entit\u00e0 sono pensate pi\u00f9 come Data Transfer Objects (DTO) oggetti concepiti come un mezzo per trasferire dati tra diversi punti di un'applicazione. Modellano una risposta o sono ottimizzati per la creazione e la persistenza dei dati. Le Entity in Room rappresentano i dati che si desidera memorizzare nel database e sono anche l'unit\u00e0 tipica di un set di risultati recuperato dal database</p> <p></p> <p>Room pu\u00f2 essere integrato con LiveData per osservare i cambiamenti nel database. Un DAO pu\u00f2 restituire un oggetto LiveData da una query, consentendo all'interfaccia utente di aggiornarsi automaticamente quando i dati sottostanti cambiano.</p> <p>Room si integra bene con ViewModel, che gestisce i dati relativi alla View in modo indipendente dai cambiamenti di configurazione. Il ViewModel pu\u00f2 interagire con il database tramite un repository che utilizza Room.</p> <p>\u00c8 una buona pratica utilizzare il pattern Repository come livello intermedio tra Room e il resto dell'applicazione. Questo permette di astrarre l'accesso ai dati e, se in futuro vorrai cambiare il tipo di persistenza (ad esempio passare da Room a una sorgente di rete o cache), potrai farlo senza modificare i ViewModel o altri componenti della business logic.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#mvc","title":"MVC","text":"<p>Il [[MVC]] Model View Controller \u00e8 un modo per organizzare le funzionalit\u00e0 di un'applicazione separando gli oggetti in tre ruoli distinti:</p> <p></p> <p>Gli oggetti del modello non hanno alcuna conoscenza dell'interfaccia utente (UI). Il loro unico scopo \u00e8 la gestione e la detenzione dei dati.</p> <p>Model Il modello contiene i dati dell'applicazione e la logica di business.Le classi del modello sono progettate per rappresentare le entit\u00e0 con cui l'app lavora, come una domanda vero/falso. In Android, il livello del modello \u00e8 generalmente costituito da classi personalizzate create dallo sviluppatore. Il modello pu\u00f2 anche specificare la struttura dei dati dell'app e il codice per accedervi e manipolarli.</p> <p>View La vista \u00e8 responsabile della visualizzazione dei dati all'utente e della risposta alle azioni dell'utente. Ogni elemento visibile sullo schermo \u00e8 una vista. Android fornisce molteplici tipi di viste. Le viste sanno come disegnarsi sullo schermo e come rispondere all'input dell'utente, come i tocchi.</p> <p>Controller Il controllore agisce come un intermediario tra il modello e la vista. Contiene la logica dell'applicazione .I controllori rispondono agli eventi innescati dalle viste e gestiscono il flusso di dati da e verso il modello e la vista. In Android, un controllore \u00e8 tipicamente una sottoclasse di Activity, Fragment o Service.</p> <p>\u00c8 importante notare che il modello e la vista non comunicano direttamente. Il controllore si trova al centro, ricevendo messaggi da un lato e inviando istruzioni all'altro.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#benefici-dellmvc","title":"Benefici dell'MVC","text":"<ul> <li>Separazione delle responsabilit\u00e0: Aiuta a progettare e comprendere l'applicazione come un insieme di classi distinte.</li> <li>Migliore organizzazione del codice: La separazione in livelli (modello, vista, controllore) facilita la progettazione e la comprensione dell'applicazione a un livello superiore.</li> <li>Riutilizzabilit\u00e0 del codice: Le classi con responsabilit\u00e0 limitate sono pi\u00f9 riutilizzabili.</li> </ul>"},{"location":"30_Frameworks_Tools/Android/Android/#observer-synchronization","title":"Observer Synchronization","text":"<p>Questo approccio, strettamente associato all'MVC, si basa sul concetto che le viste e i controllori osservano il modello.</p> <p>Quando il modello subisce una modifica, viene notificato a tutti i suoi osservatori (le viste e potenzialmente i controllori).</p> <p>Le viste reagiscono a queste notifiche aggiornando la propria visualizzazione in base ai nuovi dati del modello.</p> <p>Il controllore, in questo modello, \u00e8 relativamente \"ignorante\" di quali altre viste potrebbero aver bisogno di essere aggiornate quando l'utente interagisce con una specifica vista. Il controllore si limita a modificare il modello, lasciando che il meccanismo di osservazione si occupi di propagare i cambiamenti alle viste interessate.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#flow-synchronization","title":"Flow Synchronization","text":"<p>Nella sincronizzazione tramite flusso, \u00e8 l'applicazione (spesso il controllore) che manipola direttamente le viste per riflettere i cambiamenti nel modello. Ad esempio, quando si apre una schermata o si preme un pulsante di salvataggio, il codice dell'applicazione si occupa di aggiornare esplicitamente i vari controlli (viste) con i dati del modello. In questo caso, il form (o l'attivit\u00e0/il fragment in Android) deve tenere traccia di quali controlli devono essere aggiornati in seguito a un cambiamento, il che pu\u00f2 diventare complesso in schermate elaborate.</p>"},{"location":"30_Frameworks_Tools/Android/Android/#mvvm","title":"MVVM","text":"<p>Il pattern MVVM Model-View-ViewModel permette una gestione pi\u00f9 fluida della UI e una separazione pi\u00f9 chiara tra la logica di business e l'interfaccia utente.</p> <p>Il pattern MVVM \u00e8 composto da tre componenti principali:</p> <ol> <li>Model</li> <li>View</li> <li>ViewModel che da intermediario tra la View e il Model. \u00c8 responsabile della gestione dei dati da visualizzare nella UI e dell'elaborazione della logica necessaria per presentarli. La ViewModel fornisce i dati alla View tramite LiveData, che consente di osservare i cambiamenti dei dati e aggiornare automaticamente la UI quando necessario. La ViewModel non ha conoscenza diretta della View. Comunica con il Model per recuperare i dati e li prepara in una forma che la View pu\u00f2 facilmente consumare.</li> </ol>"},{"location":"30_Frameworks_Tools/Android/Android/#interazione-tra-i-componenti-nel-pattern-mvvm","title":"Interazione tra i componenti nel pattern MVVM","text":"<ol> <li>L'utente interagisce con la View (ad esempio, tocca un pulsante).</li> <li>La View invia un'azione al ViewModel (ad esempio, invoca un metodo che cambia i dati).</li> <li>Il ViewModel interagisce con il Model per recuperare o modificare i dati. In caso di operazioni asincrone, il ViewModel gestisce il flusso di lavoro.</li> <li>Quando il Model restituisce i dati (ad esempio tramite una chiamata API), il ViewModel li prepara (ad esempio, li converte in un formato adatto alla visualizzazione).</li> <li>Il ViewModel aggiorna un LiveData, che \u00e8 osservato dalla View.</li> <li>La View riceve i nuovi dati tramite LiveData e aggiorna automaticamente l'interfaccia utente.</li> </ol> <p>In questo modo, ogni componente ha un compito preciso:</p> <ul> <li>la UI si concentra solo sulla presentazione e l\u2019interazione,</li> <li>il ViewModel gestisce la logica di visualizzazione,</li> <li>il Repository coordina l\u2019accesso ai dati,</li> <li>e il livello Model (Room + Retrofit) fornisce le sorgenti dati reali.</li> </ul>"},{"location":"30_Frameworks_Tools/Android/Android_MOC/","title":"[[Android_OS]]of Content","text":"<p>Stato: #growing MOC Genitore: [[30_Frameworks_Tools_MOC]]</p>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#fondamentali-del-sistema","title":"\ud83c\udfd7\ufe0f Fondamentali del Sistema","text":"<p>Concetti di base sull'architettura e il funzionamento del sistema operativo.</p> <ul> <li>[[Android_OS]] \u2013 Note sull'architettura del kernel e del runtime.</li> <li>[[Compilazione_app]] \u2013 Panoramica generale sulla compilazione app android.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#componenti-core","title":"\ud83e\uddf1 Componenti Core","text":"<p>Le fondamenta di ogni app Android.</p> <ul> <li>[[Activity_e_Fragment]] \u2013 _Gestione dell'interfaccia utente.</li> <li>[[Service]] \u2013 _Operazioni in background.</li> <li>[[Broadcast_Receiver]] \u2013 _Comunicazione tra app e sistema.</li> <li>[[Content_Provider]] \u2013 _Gestione e condivisione dei dati.</li> <li>[[Intent]] - _Comunicazione interena fra applicazione e fra applicazioni diverse</li> <li>[[Notifiche]] -</li> <li>[[Setting]] -</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#fondamenti-di-ui","title":"\ud83c\udfa8 Fondamenti di UI","text":"<ul> <li>[[Gestione_UI_Android]] -</li> <li>[[Layout]] -</li> <li>[[Modelli_navigazionali]] -</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#ui-user-experience","title":"\ud83c\udfa8 UI &amp; User Experience","text":"<ul> <li>[[Jetpack Compose]] \u2013 Il nuovo standard per la UI dichiarativa.</li> <li>[[Material Design]] \u2013 Linee guida estetiche e funzionali.</li> <li>[[Gestione delle Risorse]] \u2013 Layout, stringhe e file in <code>/assets</code>.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#dati-e-networking","title":"\ud83d\udcbe Dati e Networking","text":"<ul> <li>[[Room Persistence Library]] \u2013 Astrazione su SQLite.</li> <li>[[Retrofit &amp; OkHttp]] \u2013 Consumo di API REST.</li> <li>[[Coroutines &amp; Flow]] \u2013 Gestione della concorrenza in Kotlin.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#testing-e-qualita","title":"\ud83e\uddea Testing e Qualit\u00e0","text":"<ul> <li>[[Unit Testing (JUnit)]]</li> <li>[[UI Testing (Espresso)]]</li> <li>[[Android Profiler]] \u2013 Monitoraggio di CPU, Memoria e Network.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_MOC/#risorse-di-riferimento","title":"\ud83d\udd17 Risorse di Riferimento","text":"<ul> <li>Android Developers Documentation</li> <li>[[50_Project_Journal]] \u2013 Vedi i log dei progetti Android in corso.</li> </ul>","tags":["android","mobile","kotlin","java"]},{"location":"30_Frameworks_Tools/Android/Android_OS/","title":"Android_OS","text":"<p>Android \u00e8 un sistema operativo sviluppato da Google basato su Linux e progettato per dispositivi mobile \u00e8 un sistema operativo open source . Quindi il suo codice sorgente \u00e8 pubblico e pu\u00f2 essere modificato da sviluppatori e produttori di hardware per creare la propria versione di Android e adattarlo a loro dispositivo, Il problema di questo \u00e8 che ci\u00f2 porta a una frammentazione eccessiva delle versioni e questo causa problemi quando dobbiamo sviluppare delle applicazioni, perch\u00e9 dobbiamo individuare il numero di dispositivi compatibili con la versione che dovremo sviluppare. Android cerca di risolvere il problema di compatibilit\u00e0 creando degli appositi librerie che si possono utilizzare con andiamo a sviluppare il codice</p> <p>Google gestisce il rilascio delle nuove versioni di Android sia per i propri dispositivi, la cui distribuzione avviene in maniera abbastanza rapida sia per gli altri dispositivi di altri produttori. Il sistema operativo di questi seguire. Deve seguire un processo di qualifica da parte di Google. Questo vuol dire che ogni qualvolta che Google rilascia un aggiornamento ogni produttore deve adattarlo al proprio hardware del dispositivo e questo richiede molto tempo perch\u00e9 modificano anche l\u2019interfaccia. Una volta che hanno effettuato queste modifiche la versione deve essere approvata da Google per garantire che soddisfi standard di qualit\u00e0 compatibilit\u00e0 e sicurezza se si superano questi test al loro i produttori potranno rilasciare il loro aggiornamento per i loro dispositivi.</p> <p>Il sistema Android \u00e8 interamente sviluppato sopra al kernel Linux. Il motivo di questa scelta \u00e8 dovuto al fatto che non sarebbero mai stati in grado di sviluppare un sistema completamente funzionante in tempi rapidi per poter entrare nel mercato. Linux era gi\u00e0 un sistema operativo pienamente funzionante sotto ogni aspetto e che funzionava in modo molto efficiente e quindi l\u2019idea di Google fu quello di estendere il sistema operativo Linux per adattarlo ai dispositivi mobile.</p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#linux-kernel","title":"Linux Kernel","text":"<p>Questo livello fornisce i servizi di gestione dell'hardware. A questo livello, viene applicato uno schema di protezione per limitare l'accesso ai dati e alle risorse e consentirlo solo ai processi che posseggono l'adeguato livello di autorizzazione. Vi sono i moduli per la gestione della memoria, dei processi, del sistema di archiviazione e della comunicazione sulla rete. Vi sono i driver per la gestione dell'hardware in dotazione al dispositivo, ad esempio la memoria ausiliaria, la radio, la fotocamera. Oltre ai servizi offerti dal nucleo del sistema operativo, il kernel di Android include alcuni componenti particolari, quali ad esempio il sistema di risparmio energetico, il sistema di gestione e condivisione della memoria, un meccanismo di comunicazione tra processi chiamato binder, che permette ai processi di condividere dati e servizi.</p> <p></p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#hardware-abstraction-level","title":"Hardware Abstraction Level","text":"<p>Sopra al kernel troviamo HAL che fornisce interfacce standard per esporre le funzionalit\u00e0 hardware del dispositivo al framework API di livello superiore. HAL \u00e8 formato da pi\u00f9 moduli, ognuno dei quali implementa un\u2019interfaccia per un tipo di componente hardware Linux . quando il framework fa una chiamata per accedere all\u2019hardware del dispositivo Android carica il modulo di libreria di quella componente. I moduli sono scritti dal produttore.</p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#android-runtime","title":"Android RunTime","text":"<p>L\u2019Android Runtime \u00e8 composto dalla macchina virtuale ART (che ha sostituito Dalvik) e dalle librerie principali del sistema. ART \u00e8 un ambiente di esecuzione in cui ogni app viene eseguita nel proprio processo, con una propria istanza di ART.</p> <p>ART traduce il codice scritto in Java o Kotlin in bytecode, che viene poi convertito in codice nativo comprensibile dal processore del dispositivo. Utilizza principalmente un approccio di compilazione Ahead-of-Time (AOT): quando si installa una nuova app, questa viene compilata in codice nativo gi\u00e0 durante la fase di installazione, migliorando cos\u00ec le performance in fase di esecuzione.</p> <p>Inoltre, ART pu\u00f2 usare la modalit\u00e0 Just-In-Time (JIT) per compilare dinamicamente solo alcune parti del codice durante l\u2019esecuzione dell\u2019app, migliorando la reattivit\u00e0 e riducendo i tempi di compilazione iniziale.</p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#native-cc-library-ndk","title":"Native C/C++ Library NDK","text":"<p>Sempre sopra ad HAL troviamo le NDK strumenti per sviluppare app in C/C++. Sono utili per implementare funzionalit\u00e0 che richiedono altre performance o se dobbiamo implementare parte di codice che devono comunicare direttamente con l\u2019hardware.</p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#java-api-framework","title":"Java API Framework","text":"<p>Sopra ai livelli di Android Runtime e HAL troviamo il Java API Framework, un insieme di librerie, classi e interfacce scritte in Java/Kotlin che permettono di interagire facilmente con le funzionalit\u00e0 hardware e software del dispositivo.</p> <p>Questo livello \u00e8 progettato per semplificare lo sviluppo delle app, fornendo un accesso ad alto livello alle componenti del sistema operativo Android</p> <p>Le API mettono a disposizione implementazioni predefinite delle componenti fondamentali del sistema, che possono essere estese e personalizzate dagli sviluppatori per costruire le funzionalit\u00e0 specifiche dell'app.</p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#applicazioni","title":"Applicazioni","text":"<p>Sopra questo livello troviamo le applicazioni dell\u2019utente.</p>"},{"location":"30_Frameworks_Tools/Android/Android_OS/#android-sdk","title":"Android SDK","text":"<p>L\u2019android software development kit ASDK \u00e8 un set di librerie e strumenti per sviluppare un app android. I tool si dividono in;</p> <ul> <li>SDK platform, tools platform dependent. Una nuova versione di queste \u00e8 rilasciata ad ogni versione di android e include librerie, codici sorgenti ecc</li> <li>SDK tools che sono platform indipendent. Sono strumenti usati per sviluppare , farete bugno a disposizione un emulatore per simulate un dispositivo mobile. Ha un android Debug Brigde che permette di comunicare con il dispositivo per eseguire operazioni varie per fare testing e debug.</li> </ul>"},{"location":"30_Frameworks_Tools/Android/Broadcast_Receiver/","title":"Broadcast Receiver","text":""},{"location":"30_Frameworks_Tools/Android/Broadcast_Receiver/#broadcast-receiver","title":"BROADCAST RECEIVER","text":"<p>Un Broadcast Receiver \u00e8 un componente Android progettato per rispondere a messaggi provenienti da altre applicazioni o dal sistema operativo. Per implementare un broadcast receiver si estende la classe BroadcastReceiver e implementare il metodo onReceive(Context context, Intent intent) dal quale estraiamo l\u2019evento di intent, i dati ecc.</p> <p>Questi messaggi sono incapsulati negli intent per poter attraversare le applicazioni. Le app possono registrarsi per ascoltare specifici tipi di intent broadcast; quando un intent di quel tipo viene inviato, il sistema notifica il receiver in modo che possa eseguire un'azione.</p> <p>Gli intent broadcast non sono indirizzati a destinatari specifici, ma a tutte le app interessate che hanno registrato un receiver per quel tipo di intent lo riceveranno. Le app anche in background possono ricevere messaggi dai broadcast receiver e svolgere delle attivit\u00e0.</p> <p>Esistono due tipi di intent broadcast: quelli inviati dal sistema (system broadcast intents) e quelli inviati dalla tua app (custom broadcast intents).</p> <ol> <li>Gli intent broadcast di sistema vengono inviati quando si verifica un evento di sistema che potrebbe interessare la tua app, come l'avvio del dispositivi, la connessione o disconnessione dall'alimentazione ecc.</li> <li>Gli intent broadcast personalizzati vengono utilizzati quando vuoi che la tua app esegua un'azione senza avviare un'attivit\u00e0, ad esempio per informare altre app che sono stati scaricati dei dati.</li> </ol> <p>Ci sono due modi per registrare un broadcast receiver:</p> <ol> <li>staticamente nel file manifest aggiungendo un elemento \\ al file AndroidManifest.xml e usare il percorso della tua sottoclasse BroadcastReceiver come attributo android:name.     I receiver registrati staticamente possono essere attivati anche se il processo della tua app non \u00e8 in esecuzione e pu\u00f2 accedere ad ogni eventi di sistema. <p>Infatti Android si accorse che questo causava problemi di sicurezza, visto che potevano essere inseriti dei malware quando si verificavano deteminati eventi di sistema. Allora definirono una registrazione</p> <ol> <li>dinamica sulla base del contesto con cui si chiamava il broadcast receiver. La registrazione avviene chiamando il metodo registerReceiver() e passando un oggetto BroadcastReceiver e un IntentFilter. I receiver registrati dinamicamente sono legati al ciclo di vita del componente in cui sono registrati, infatti \u00e8 necessario gestire anche la loro cancellazione perch\u00e9 potrebbero contenere dati che sprecherebbero risorse</li> </ol> <p></p> <p>Il pattern che viene usato \u00e8 l\u2019observer con tassonomia ad eventi</p>"},{"location":"30_Frameworks_Tools/Android/Broadcast_Receiver/#modalita-di-invio-dei-broadcast","title":"MODALIT\u00c0 DI INVIO DEI BROADCAST","text":"<p>Broadcast Normali, con cui il broadcast intente \u00e8 prodotto da un singolo produce e viene inviato a tutti i receiver contemporaneamente. Essendo che vengono mandati sul thread principale, i receiver non vengono eseguiti in parallelo, quindi non \u00e8 possibile fare affidamento su un ordine di esecuzione particolare n\u00e9 sapere quando tutti i receiver hanno completato l'esecuzione.</p> <p>Vengono inviati tramite il metodo sendBroadcast(). I receiver sono indipendenti fra loro e quindi non possono scambiarsi informazioni fra loro.</p> <p>Broadcast Ordinati, sono principalmente eventi di sistema, e questi sono mandati ad una sequenza di broadcast che quandi ricevono l\u2019intent verificano se lo possono risolvere o se ne hanno autorizzazione a risolvelo, altrimenti viene mandato al broadcast successivo fino ad arrivare alla fine della sequenza dove viene lanciata un\u2019eccezione per segnalare che non \u00e8 stato possibile risolverlo.</p> <p>E possibile anche assegnare delle priorit\u00e0, tramite android:priority per modificare l\u2019ordine di esecuzione. Conviene nella catena mettere sempre quelli pi\u00f9 specifici per quello che si deve fare. Questo implementa il pattern di catena di responsabilit\u00e0.</p> <p></p> <p>LocalBroadcastManager Questi rimangono nell\u2019app e quindi non hanno bisogno di intent e n\u00e9 della registrazione nel manifest. Si ottiene un'istanza singleton chiamando getInstance(context), che \u00e8 thread-safe. Per inviare un broadcast locale si usa il suo metodo sendBroadcast(), e per registrare un receiver si usa registerReceiver(). I receiver locali devono essere registrati dinamicamente nel codice; la registrazione statica nel manifest non \u00e8 disponibile per LocalBroadcastManager. \u00c8 importante annullare la registrazione del receiver locale quando non \u00e8 pi\u00f9 necessario per evitare memory leak.</p> <p>Custom Broadcast sia il producer che il receiver devono avere lo stesso nome e devono avere un URI di riferimenti che deve essere univoco, infatti si usa il FQN del package in cui si trova</p>"},{"location":"30_Frameworks_Tools/Android/Broadcast_Receiver/#restizione-dei-broadcast","title":"RESTIZIONE DEI BROADCAST","text":"<p>Bisogna evitare che altre applicazione estraggano dati dei broadcast. Infatti il sistema Android non \u00e8 multiutente, ma per dare maggiori sicurezza android definisce delle linee guida per evitare minacce alla sicurezza. \u00c8 necessario creare un sistema di permessi valido, implementando setpackage() per far consumare i messaggi broadcast solo da package specifici. I permessi che devono essere richiesti all\u2019utente devono esser specificati nel manifest e non si possono mandare messaggi non confinati, l\u2019unico che pu\u00f2 \u00e8 Android, che pu\u00f2 mandare permessi null, cio\u00e8 non confinati.</p> <p>\u00c8 possibile imporre permessi per il ricevente e lo si fa con registerReceiver() e nel manifest dobbiamo specificare nel BroadcastReceiver android:permission con i permessi di cui ha bisogno. Quando si hanno bisogno dei permessi, si chiede all\u2019utente di darli o meno. Se l\u2019utente accetta, allora il BroadcastReceiver sar\u00e0 registrato. Non si devono fare operazioni long run perch\u00e9 impegneremmo troppo il sistema, quindi una volta che abbiamo acquisito i dati nella onReceiver(), liberiamo la callback e poi elaboriamo in modo asincrono. (code)</p>"},{"location":"30_Frameworks_Tools/Android/Compilazione_app/","title":"COMPILAZIONE APP ANDROID","text":"<p>Per quanto riguarda la compilazione di un app android prima di generare il bytecode, le risorse usate nel processo vengono analizzate indicizzate e compilate in bytecode, ottimizzato per la piattaforma punto la componente. La componente che si occupa di fare questo \u00e8 AAPT2 che opera il modo incrementale cio\u00e8 compila le risorse e linka tutti i file intermedi generati dalla compilazione. Produce la classe R.java che contiene tutte le risorse compilate a cui sono associate un ID con il quale si pu\u00f2 far riferimento alla risorsa.</p> <p>Viene generato il bytecode del codice Java/Kotlin.</p> <p>La componente AIDL definisce l\u2019interfaccia di programmazione concordata dal client e server per comunicare fra loro usando IPC. Il motivo di ci\u00f2 \u00e8 che ogni app, anche se viene eseguita sullo stesso dispositivo, e un processo separato e quindi pu\u00f2 accedere solo alle zone di memoria che le sono state riservate.</p> <p>Android usa un meccanismo nativo chiamato Binder per gestire la comunicazione tra processi. \u00c8 una tecnologia di basso livello, integrata nel kernel di Linux, che permette a un processo di:</p> <ul> <li>Fare richieste a un altro processo</li> <li>Ricevere risposte come se fossero normali chiamate di funzione</li> </ul> <p>Con tutte queste parti si viene a creare il .class cio\u00e8 il file bytecode Java che per\u00f2 non pu\u00f2 essere ancora utilizzato ma deve essere ottimizzato dalla componente DEX/ART creando un file .dex eseguibile su ART VM.</p> <p>Una volta pronti i file .dex e le risorse, lo strumento apkbuilder li unisce per creare il file .apk, cio\u00e8 il pacchetto installabile dell\u2019app Android. Dentro questo .apk troviamo:</p> <ul> <li>I file .dex</li> <li>Le risorse compilate (.arsc)</li> <li>I file non compilati (come asset, immagini, XML di layout)</li> <li>Il file AndroidManifest.xml</li> </ul> <p>Prima che un'app venga installata su un dispositivo, deve essere firmata digitalmente. Questo garantisce due cose fondamentali:</p> <ul> <li>Autenticit\u00e0: conferma che l\u2019app \u00e8 stata creata da chi dice di averla creata.</li> <li>Integrit\u00e0: assicura che il file non sia stato modificato dopo la firma.</li> </ul> <p>a) Firma con jarsigner</p> <p>La firma avviene usando uno keystore, ovvero un contenitore sicuro di chiavi crittografiche. Con jarsigner, il pacchetto .apk viene firmato utilizzando una chiave privata.</p> <ul> <li>Si calcola un hash del contenuto dell\u2019app.</li> <li>Questo hash viene poi cifrato con la chiave privata \u2192 questo \u00e8 ci\u00f2 che chiamiamo firma digitale.</li> <li>La firma viene allegata all\u2019app.</li> </ul> <p>b) Allineamento con zipalign</p> <p>Dopo la firma, si utilizza lo strumento zipalign per ottimizzare l\u2019accesso alle risorse del pacchetto. Questo \u00e8 un passo importante, soprattutto per app in produzione, perch\u00e9 migliora le prestazioni e riduce il consumo di memoria.</p> <p>Quando un dispositivo Android riceve un\u2019app firmata, esegue la verifica della firma:</p> <ul> <li>Estrae l\u2019hash dal file firmato.</li> <li>Ricalcola l\u2019hash con il contenuto dell\u2019app.</li> <li>Usa la chiave pubblica per verificare che la firma corrisponda all\u2019hash originale.</li> </ul> <p>Se i due hash corrispondono, l\u2019app \u00e8 autentica e non \u00e8 stata manomessa \u2192 viene installata. Se non combaciano, il sistema rifiuta l\u2019installazione.</p> <ul> <li>Durante lo sviluppo, Android Studio firma automaticamente l\u2019app con una chiave debug.</li> <li>Per pubblicare l\u2019app sul Play Store, devi firmarla con una chiave di release generata da te. \u00c8 fondamentale non perdere questa chiave, perch\u00e9 ti servir\u00e0 per aggiornare l\u2019app in futuro.</li> </ul> <p></p>"},{"location":"30_Frameworks_Tools/Android/Compilazione_app/#avvio-di-un-applicazione-android","title":"AVVIO DI UN APPLICAZIONE ANDROID","text":"<p>Il processo di avvio di un'applicazione Android inizia quando l'utente o un altro componente di sistema richiede l'esecuzione di un componente dell\u2019app. Se l'applicazione non \u00e8 gi\u00e0 in esecuzione, il sistema Android avvia un nuovo processo per essa.</p> <p>Ogni app Android viene eseguita nel proprio processo Android, che \u00e8 un processo Linux con un thread di esecuzione iniziale.</p> <p>Il processo di avvio del sistema include l'avvio dell'init process, che a sua volta genera processi Linux di basso livello chiamati daemon. L'init process avvia un processo chiamato Zygote che inizializza la prima istanza della Dalvik Virtual Machine e precarica tutte le classi comuni utilizzate dal framework Android e dalle varie app installate. In questo modo, si prepara a essere replicato e inizia ad ascoltare su un'interfaccia socket per richieste future di generare nuove macchine virtuali per i processi delle nuove applicazioni. Quando riceve una nuova richiesta, Zygote effettua un fork di se stesso per creare un nuovo processo che ottiene un'istanza VM pre-inizializzata. Dopo Zygote, l'init avvia il runtime process, e Zygote esegue un fork per avviare un processo ben gestito chiamato system server. Il system server avvia tutti i servizi principali della piattaforma, come l'Activity Manager Service e i servizi hardware, nel proprio contesto.</p> <p>A questo punto, lo stack completo \u00e8 pronto per avviare il primo processo dell'app: l'app Home, nota anche come Launcher.</p> <p>Quando un utente fa clic sull'icona di un'app nel Launcher, l'evento di clic viene tradotto in startActivity(intent) e viene indirizzato all'ActivityManagerService tramite Binder IPC. L'ActivityManagerService esegue diverse operazioni:</p> <ol> <li>Raccoglie informazioni sul target dell'oggetto intent utilizzando il metodo resolveIntent() sull'oggetto PackageManager, con i flag PackageManager.MATCH_DEFAULT_ONLY e PackageManager.GET_SHARED_LIBRARY_FILES utilizzati per impostazione predefinita.</li> <li>Salva le informazioni sul target nell'oggetto intent per evitare di ripetere questo passaggio.</li> <li>Verifica se l'utente ha privilegi sufficienti per richiamare il componente target dell'intent chiamando il metodo grantUriPermissionLocked().</li> <li>Se l'utente ha le autorizzazioni necessarie, l'ActivityManagerService verifica se l'attivit\u00e0 target richiede di essere avviata in un nuovo task, in base ai flag dell'Intent come FLAG_ACTIVITY_NEW_TASK e FLAG_ACTIVITY_CLEAR_TOP.</li> <li>Verifica se esiste gi\u00e0 un ProcessRecord per il processo. Se il ProcessRecord \u00e8 null, l'ActivityManager deve creare un nuovo processo per istanziare il componente target.</li> </ol> <p>L\u2019ASM crea un nuovo processo invocando il metodo startProcessLocked(), che invia argomenti al processo Zygote tramite la connessione socket. Zygote esegue un fork di se stesso e chiama ZygoteInit.main(), che a sua volta istanzia un oggetto ActivityThread e restituisce l'ID del processo appena creato. Ogni processo ottiene un thread per impostazione predefinita. Il thread principale ha un'istanza Looper per gestire i messaggi da una coda di messaggi e chiama Looper.loop() in ogni iterazione del suo metodo run(). Il Looper estrae i messaggi dalla coda e richiama i metodi corrispondenti per gestirli. ActivityThread avvia quindi il message loop chiamando Looper.prepareLoop() e successivamente Looper.loop().</p> <p>Il passo successivo consiste nell'associare questo processo appena creato a un'applicazione specifica. Ci\u00f2 avviene chiamando bindApplication() sull'oggetto thread. Questo metodo invia un messaggio BIND_APPLICATION alla coda dei messaggi. Questo messaggio viene recuperato dall'oggetto Handler, che quindi invoca il metodo handleMessage() per attivare l'azione specifica del messaggio: handleBindApplication(). Questo metodo invoca makeApplication(), che carica le classi specifiche dell'app in memoria.</p> <p></p> <p>Dopo il binding, il sistema contiene il processo responsabile dell'applicazione con le classi dell'applicazione caricate nella memoria privata del processo. Il processo effettivo di avvio inizia nel metodo realStartActivity(), che chiama scheduleLaunchActivity() sull'oggetto thread dell'applicazione. Questo metodo invia un messaggio LAUNCH_ACTIVITY alla coda dei messaggi. Il messaggio viene gestito dal metodo handleLaunchActivity(). L'Activity inizia il suo ciclo di vita .</p> <p></p>"},{"location":"30_Frameworks_Tools/Android/Content_Provider/","title":"CONTENET PROVIDER","text":"<p>Un Content Provider \u00e8 un componente di Android che gestisce l'accesso a un repository di dati. L'applicazione non ha bisogno di sapere dove o come i dati sono archiviati, formattati o acceduti.</p> <p></p> <p>Un Content Provider separa i dati dal codice dell'interfaccia utente dell'app, fornendo un modo standard per accedere ai dati. Rende possibile la condivisione di dati tra diverse applicazioni. (Pattern Adapter)</p> <p>Consente a pi\u00f9 applicazioni di accedere, utilizzare e modificare in modo sicuro una singola origine dati fornita dalla tua app.</p> <p>Per ottenere dati e interagire con un Content Provider, un'app utilizza un ContentResolver per inviare richieste al Content Provider. L'applicazione di un fornitore pu\u00f2 specificare le autorizzazioni che altre applicazioni devono avere per accedere ai dati del fornitore. Queste autorizzazioni consentono all'utente di sapere a quali dati un'applicazione tenta di accedere. In base ai requisiti del fornitore, altre applicazioni richiedono le autorizzazioni necessarie per accedere al fornitore. Gli utenti finali vedono le autorizzazioni richieste quando installano l'applicazione.</p> <p>Se l'applicazione di un provider non specifica alcuna autorizzazione, le altre applicazioni non avranno accesso ai dati del provider, a meno che il provider non venga esportato.</p> <p>Per rendere disponibile un ContentProvider all'interno di un'app Android, \u00e8 necessario dichiararlo esplicitamente nel file AndroidManifest.xml, all\u2019interno del tag  tramite l'elemento , che contiene una serie di attributi fondamentali. <ul> <li>android:name, che specifica il nome completo della classe che implementa il ContentProvider.</li> <li>android:authorities, che rappresenta un identificatore univoco del provider. Questo valore viene utilizzato dalle app per costruire gli URI di accesso al provider. Per esempio, se l\u2019authority \u00e8 com.miaapp.provider, l\u2019URI per accedere a una risorsa potrebbe essere content://com.miaapp.provider/risorse.</li> <li>android:exported. Questo valore determina se il provider pu\u00f2 essere accessibile da altre app. Se impostato su true, il provider potr\u00e0 essere utilizzato anche da app esterne, mentre se \u00e8 false, sar\u00e0 accessibile solo dall\u2019interno dell\u2019applicazione stessa. Questo \u00e8 un parametro importante per la sicurezza, specialmente se i dati gestiti sono sensibili.</li> </ul> <p>\u00c8 anche possibile specificare dei permessi di accesso per controllare quali app possono leggere o scrivere dati tramite il provider. Questo si fa aggiungendo gli attributi android:readPermission e android:writePermission, dove si indicano i nomi dei permessi richiesti. Le app che vogliono accedere al provider dovranno dichiarare nel proprio manifest questi permessi, e l\u2019utente li vedr\u00e0 al momento dell\u2019installazione.</p> <p>L'architettura di un Content Provider include i seguenti componenti:</p> <ul> <li>Data and Open Helper: Il repository dei dati. Comunemente i dati sono archiviati in un database SQLite, ma possono essere anche file, dati sul web o dati generati dinamicamente. Per i database SQLite, si utilizza spesso un SQLiteOpenHelper per l'accesso ai dati.</li> <li>Contract: Una classe pubblica che espone informazioni importanti sul Content Provider ad altre app. Include solitamente gli schemi URI, costanti importanti e la struttura dei dati restituiti. L'uso di un contract separa le informazioni pubbliche da quelle private e fornisce un unico punto di riferimento per le altre app.</li> <li>Content Provider: Una classe che estende ContentProvider e implementa i metodi query(), insert(), update() e delete() per accedere ai dati. Fornisce un'interfaccia pubblica e sicura ai dati.</li> <li>Content Resolver: Un oggetto utilizzato dalle app per inviare richieste al Content Provider e ottenere i dati. Fornisce i metodi query(), insert(), update() e delete() che rispecchiano quelli del Content Provider.</li> </ul> <p>Per implementare un Content Provider, \u00e8 necessario:</p> <ul> <li>Avere i dati e un modo per accedervi</li> <li>Dichiarare il Content Provider nel file AndroidManifest.xml per renderlo disponibile. \u00c8 importante impostare l'attributo android:exported=\"true\" se si desidera che altre app possano accedervi.</li> <li>Creare una sottoclasse di ContentProvider che implementi i metodi per l'accesso e la manipolazione dei dati (query(), insert(), delete(), update(), getType()).</li> <li>Definire una classe Contract pubblica che esponga l'URI scheme, i nomi delle tabelle, i tipi MIME e altre costanti importanti.</li> </ul>"},{"location":"30_Frameworks_Tools/Android/Content_Provider/#uri-e-tipi-mime","title":"URI e tipi MIME","text":"<p>Le app inviano richieste ai Content Provider utilizzando gli Uniform Resource Identifier (URI). Un content URI ha la forma generale scheme://authority/path/ID, dove lo scheme \u00e8 sempre content://, l'authority rappresenta il dominio del provider (solitamente il nome del package che termina con .provider), il path \u00e8 il percorso ai dati e l'ID identifica univocamente un set di dati. Il contract definisce costanti per l'AUTHORITY, il CONTENT_PATH e il CONTENT_URI.</p> <p>Il tipo MIME indica il tipo e il formato dei dati restituiti dal Content Provider. Per i Content URI che puntano a righe di una tabella, si utilizzano tipi MIME specifici del vendor Android, con il formato generale type.subtype/provider-specific-part. Il type \u00e8 vnd, il subtype \u00e8 android.cursor.item/ per una singola riga e android.cursor.dir/ per pi\u00f9 righe, e la parte specifica del provider include solitamente il nome del package e il nome della tabella. Il metodo getType() del Content Provider restituisce il tipo MIME dei dati per un dato URI.</p> <p>Il ContentResolver fornisce metodi (query(), insert(), delete(), update()) che corrispondono a quelli implementati nel ContentProvider.</p> <ul> <li>Il metodo query() viene utilizzato per recuperare dati e restituisce un oggetto Cursor, che \u00e8 un puntatore a una riga di dati strutturati in formato tabellare, simile a un risultato di una query SQL. La query pu\u00f2 includere una proiezione (le colonne da restituire), una clausola di selezione (il WHERE), gli argomenti di selezione e l'ordine di ordinamento (ORDER BY).</li> <li>I metodi insert(), delete() e update() vengono utilizzati per modificare i dati. Il metodo insert() riceve i valori da inserire come ContentValues e restituisce l'URI della nuova riga.</li> </ul> <p>\u00c8 buona pratica utilizzare un UriMatcher per gestire il matching degli URI all'interno del Content Provider, associando ogni URI supportato a un codice intero.</p>"},{"location":"30_Frameworks_Tools/Android/Gestione_UI_Android/","title":"INTERFACCIA UTENTE","text":"<p>Quando sviluppiamo un\u2019app Android, dobbiamo pensare all\u2019interfaccia grafica, ovvero a come gli elementi vengono organizzati sullo schermo.</p> <p>L'interfaccia utente (UI) di un'applicazione \u00e8 costruita attraverso una gerarchia di oggetti chiamati view. Ogni elemento visibile sullo schermo \u00e8 una view.</p> <p>Tutti i componenti visivi in Android discendono dalla classe Viewe vengono indicati genericamente come Views.</p> <p>La classe ViewGroup \u00e8 un'estensione di View che supporta l'aggiunta di visualizzazioni innestate che hanno la responsabilit\u00e0 di decidere le dimensioni della view di ogni figlio e di determinare la loroposizione.</p> <p>I ViewGroup che si concentrano principalmente sulla disposizione delle viste contenute sono indicati come layout. I ViewGroup sono visti quindi possono anche disegnare la propria interfaccia utente personalizzata e gestire le interazioni degli utenti.</p> <p>Layouts \u2192 definiscono la struttura e la disposizione degli elementi sulla schermata</p> <p>Views \u2192 Sono gli elementi base dell\u2019interfaccia utente</p> <p>Widgets \u2192 Sono particolari tipi di View con funzionalit\u00e0 specifiche</p> <p>Per creare e disporre le viste all'interno della UI si possono utilizzare risorse di layout XML per creare e costruire lo scheletro statico della UI di un Actvity da fare evolvere dinamicamente in modo programmatico.</p> <p>Questo approccio consente di specificare diversi layout ottimizzati per diverse configurazioni hardware, in particolare variazioni delle dimensioni dello schermo, potenzialmente anche modificandoli in fase di esecuzione in base a modifiche hardware (come i cambiamenti di orientamento).</p> <p>L\u2019interfaccia utente \u00e8 organizzata in una struttura ad albero gerarchico, chiamata albero delle View</p> <ul> <li>i nodi interni sono le ViewGroup</li> <li>le foglie sono le View effettive</li> </ul> <p>Quando apriamo un\u2019applicazione Android, una delle prime cose che il sistema fa \u00e8 costruire l\u2019interfaccia grafica dell\u2019Activity in base alla struttura definita nel file XML del layout. Questo processo avviene all\u2019interno del metodo onCreate(), dove viene caricato l\u2019albero delle View.</p> <p>Quando il metodo onCreate() viene eseguito, l\u2019Activity richiama setContentView(R.layout.activity_main), che ha il compito di leggere il file XML e tradurlo in un insieme di oggetti View e ViewGroup in memoria.</p> <p>Android calcola la disposizione degli elementi, assegna loro le dimensioni e infine li disegna sullo schermo.</p> <p>Android d\u00e0 la possibilit\u00e0 di modificare l\u2019albero delle View in tempo reale, aggiungendo, rimuovendo o modificando elementi dell\u2019interfaccia mentre l\u2019utente sta interagendo con l\u2019app, senza dover ricaricare l\u2019intera Activity</p>"},{"location":"30_Frameworks_Tools/Android/Gestione_UI_Android/#eventi","title":"EVENTI","text":"<p>Le view permettono di acquisire gli eventi dalla l'oggetto con cui interagisce l'utente. Per un'app Android, l'interazione in genere consiste nel toccare, premere, digitare o parlare e ascoltare.</p> <p>La View che ha il focus sar\u00e0 la componente che riceve l'input dell'utente.</p> <p>Il focus pu\u00f2 essere avviato dall'utente toccando una View. \u00c8 possibile definire un ordine di focus in cui l'utente viene guidato da un controllo UI a un altro controllo UI. Il focus pu\u00f2 anche essere controllato a livello di programmazione; un programmatore pu\u00f2 richiedereFocus() su qualsiasi View che \u00e8 focalizzabile.</p> <p>Un altro attributo di un controllo di input \u00e8 cliccabile. Se questo attributo \u00e8 true, allora la View pu\u00f2 reagire agli eventi di clic. Come per il focus, cliccabile pu\u00f2 essere controllato a livello di programmazione.</p> <p>La differenza tra cliccabile e focalizzabile \u00e8 che cliccabile significa che la view pu\u00f2 essere cliccata o toccata, mentre focalizzabile significa che alla view \u00e8 consentito ottenere il focus da un dispositivo di input come una tastiera. I dispositivi di input come le tastiere non possono determinare a quale view inviare i loro eventi di input, quindi li inviano alla view che ha il focus.</p> <p>per intercettarlo, devi estendere la classe e sostituire il metodo. Tuttavia, l'estensione di ogni oggetto View per gestire un evento del genere non sarebbe pratica. Per questo motivo la classe View contiene anche una raccolta di interfacce nidificate con callback che puoi definire molto pi\u00f9 facilmente. Un listener di eventi \u00e8 un'interfaccia della classe View che contiene un singolo di callback. Questi metodi verranno chiamati dal framework Android quando la view a cui il listener ha registrato viene attivato dall'interazione dell'utente con l'elemento nell'interfaccia utente.</p> <p>Le interfacce del listener di eventi includono i seguenti metodi di callback:</p> <p>onClick()da\u00a0View.OnClickListener. Questo viene chiamato quando l'utente tocca l'elemento. (in modalit\u00e0 touch) o si concentra sull'elemento con i tasti di navigazione o la trackball e preme il tasto \"Invio\" adatto o premi la trackball.</p> <p>onLongClick()da\u00a0View.OnLongClickListener. Questo viene chiamato quando l'utente tocca e tiene premuto l'elemento (in modalit\u00e0 tocco) o si concentra sull'elemento con i tasti di navigazione o la trackball e tiene premuto il pulsante \"Invio\" o tenere premuto sulla trackball (per un secondo).</p> <p>onFocusChange()Da\u00a0View.OnFocusChangeListener. Questo viene chiamato quando l'utente si avvicina o si allontana dall'elemento utilizzando i tasti di navigazione o la trackball.</p> <p>onKey()da\u00a0View.OnKeyListener. Viene chiamato quando l'utente si concentra sull'elemento e preme o rilascia un tasto hardware sul dispositivo.</p> <p>onTouch()da\u00a0View.OnTouchListener. Questo nome viene chiamato quando l'utente esegue un'azione qualificata come evento touch, ad esempio una stampa, un comunicato stampa o qualsiasi gesto di movimento sullo schermo (entro i limiti dell'elemento).</p> <p>onCreateContextMenu() da\u00a0View.OnCreateContextMenuListener. Questa operazione viene chiamata quando viene creato un menu contestuale (in seguito a un \"clic lungo\") prolungato.</p> <p>Un\u00a0gesto di tocco\u00a0si verifica quando un utente posiziona una o pi\u00f9 dita sul il touchscreen e l\u2019app interpreta questa sequenza di tocchi come un gesto. Il rilevamento dei gesti prevede due fasi:</p> <ol> <li>la raccolta di dati sugli eventi touch</li> <li>l\u2019interpretazione dei dati per determinare se soddisfano i gesti supportati dall\u2019app.</li> </ol> <p>Quando un utente posiziona una o pi\u00f9 dita sullo schermo, viene attivata la callbackonTouchEvent()sulla visualizzazione che riceve gli eventi touch. e per ogni sequenza di tocco viene memorizzata la posizione, pressione, dimensione, il numero di dita usate e altre info utili. Queste info vengono memorizzate nell\u2019oggetto MotionEvent. Il gesto inizia quando l'utente tocca per la prima volta lo schermo, poi continua mentre il sistema tiene traccia della posizione del dito o delle dita dell'utente e termina acquisire l'evento finale dell'ultimo dito dell'utente che lascia lo schermo.</p> <p>Gli eventi, in particolare gli eventi di input come i tocchi, possono essere propagati attraverso la gerarchia delle view. Una View pu\u00f2 consumare un evento o passarlo al suo parent ViewGroup per la gestione. Il sistema Android distribuisce (dispatch) questi eventi ai componenti appropriati per la gestione.</p> <p>Quando si verifica un evento di interazione, si propaga dall'activity andando fino alla view.</p> <p>Quindi a tutti i componenti della gerarchia viene data la possibilit\u00e0 di gestire l'evento, iniziando con la vista in alto e tornando all'attivit\u00e0. Quindi l'activity \u00e8 la prima a ricevere l'evento e l'ultima a cui viene data la possibilit\u00e0 di gestirlo.</p> <p>Se qualche ViewGroup vuole gestire immediatamente l'evento touch, pu\u00f2 restituire true nel suo onInterceptTouchEvent().</p> <p>Una Activity non ha onInterceptTouchEvent() ma pu\u00f2 sovrascrivere dispatchTouchEvent() per fare la stessa cosa.</p> <p>Se una vista (o un gruppo di viste) ha un OnTouchListener, l'evento tocco viene gestito da OnTouchListener.onTouch()</p> <p>Altrimenti \u00e8 gestito da onTouchEvent(). Se onTouchEvent () restituisce true per qualsiasi evento di tocco, la gestione si interrompe. Nessun altro ne ha la possibilit\u00e0.</p> <p>La classe GestureDetector pu\u00f2 essere utilizzata per interpretare sequenze di MotionEvent e dispatchare eventi di gesto specifici (come tap, swipe, fling) a un listener OnGestureListener</p>"},{"location":"30_Frameworks_Tools/Android/Gestione_UI_Android/#view-personalizzate","title":"VIEW PERSONALIZZATE","text":"<p>La creazione di nuove visualizzazioni d\u00e0 la possibilit\u00e0 di modellare l'aspetto e il funzionamento delle applicazioni. Creando i propri controlli, si pu\u00f2 creare una interfacce utente che si adatta in modo perfetto ai requisiti.</p> <p>Per creare nuovi controlli da un'area di disegno vuota, si usa la classe base View o SurfaceView.</p> <p>La classe View fornisce un oggetto Canvas con una serie di metodi di disegno e classi Paint. Servono per creare un'interfaccia visiva con bitmap e grafica raster. \u00c8 possibile catturare e sovrascrivere gli eventi utente, inclusi i tocchi dello schermo o la pressione dei tasti per fornire l'interattivit\u00e0.</p> <p>La classe SurfaceView fornisce un oggetto Surface che supporta il disegno da un thread in background e, facoltativamente, l'uso di OpenGL per implementare la grafica.</p> <p>Per creare una view custom dobbiamo fornire la classe:</p> <ol> <li>Costruttori    a. Uno a cui passiamo solo il contesto    b. Contesto e attributi    c. Contesto attributi e stile</li> <li>onMeasure() che viene chiamato quando la view deve essere disegnata. L\u2019incarico di disegnare la view spetta al genitore che chiede al figlio le sue dimensioni: altezza e larghezza, chiamando i metodi della classe del figlio.    a. Questa funzione viene chiamata ogni volta che la view viene invalidata.</li> <li>onDraw() che serve per fare effettivamente il disegno della view. Questa funzione viene chiamata frequentemente e o in modo sincrono in base alla frequenza di refresh impostata dal dispositivo. Se la frequenza di refresh \u00e8 minore del tempo con cui questa funzione viene chiamata si hanno dei problemi nel rendering.</li> </ol>"},{"location":"30_Frameworks_Tools/Android/Gestione_UI_Android/#rendering-pipeline","title":"RENDERING PIPELINE","text":"<p>Il processo di rendering \u00e8 sincronizzato con il segnale VSync (vertical synchronization) generato dall'hardware del display scandendo il ritmo del rendering, sincronizzando ogni frame con il refresh dello schermo. Android sfrutta questo segnale per organizzare il lavoro su tre livelli principali:</p> <ol> <li>UI Thread</li> <li>RenderThread</li> <li>Graphics Pipeline.</li> </ol> <p>Il UI Thread, \u00e8 responsabile della gestione degli eventi di input, dell\u2019aggiornamento dell\u2019interfaccia e delle animazioni. Quando il sistema riceve un segnale di VSync, il Choreographer, un componente di Android che orchestra il rendering, sveglia il UI Thread, che esegue una serie di operazioni:</p> <ol> <li>Input Handling \u2192 Il primo compito \u00e8 elaborare gli input dell\u2019utente, come tocchi, scroll o gesti. Se premiamo un pulsante, il sistema deve registrare l\u2019evento e prepararsi a cambiare la UI.</li> <li>Animations \u2192 Se ci sono animazioni in corso (ad esempio, un pulsante che si ingrandisce quando viene premuto), vengono aggiornate e interpolate. Android calcola la nuova posizione, opacit\u00e0 o dimensione dell\u2019elemento animato.</li> <li>Measure e Layout \u2192 Ora il sistema deve capire quanto spazio occupano le View e dove devono essere posizionate. Questo processo avviene in due fasi:    Measure \u2192 Ogni View calcola la propria dimensione basandosi sui suoi genitori e sul contenuto.    Layout \u2192 Una volta note le dimensioni, le View vengono posizionate nella finestra dell\u2019app.</li> <li>Draw \u2192 Dopo aver determinato le posizioni e le dimensioni delle View, il sistema esegue il disegno vero e proprio. Questo avviene nel metodo onDraw(Canvas canvas), che dipinge gli elementi grafici sullo schermo.</li> <li>Sync \u2192 Infine, il UI Thread invia i dati al RenderThread, il quale si occuper\u00e0 di trasformarli in qualcosa che la GPU pu\u00f2 elaborare.</li> </ol> <p>Se una propriet\u00e0 di una view cambia in modo da influire sul suo aspetto viene chiamato il metodo invalidate() sulla vista. Questa chiamata non causa un redraw immediato, ma marca la vista come \"sporca\" e segnala che deve essere ridisegnata. Una volta chiamato invalidate() su una vista, questa chiamata si propaga verso l'alto nella gerarchia delle viste, chiamando una serie di metodi, come invalidateChild(), sui suoi parent.</p> <p>Questo processo continua fino a raggiungere la radice della gerarchia delle viste, in particolare la ViewRootImpl.</p> <p>Quando la dimensione o la posizione di una vista deve cambiare viene chiamato requestLayout(). Questo \u00e8 simile all'invalidazione, ma innesca un processo di misurazione e layout per determinare le nuove dimensioni e posizioni delle viste coinvolte.</p> <p>Quando la chiamata invalidateChild() raggiunge il ViewRootImpl, quest'ultimo non esegue immediatamente il ridisegno ma chiama il metodo scheduleTraversals() con cui pianifica l'esecuzione del processo di traversal (misurazione, layout e disegno) in un momento successivo, tipicamente in sincronia con il prossimo segnale VSync gestito dal Coreoghaph.</p> <p>Per ottimizzare questo processo, Android utilizza un meccanismo chiamato Display List. Quando viene chiamato draw(), la vista (o i suoi antenati) ottiene (o rigenera) una display list tramite il metodo getDisplayList(). Una display list \u00e8 una registrazione di tutte le operazioni di disegno (ad esempio, drawBackground(), drawText()) che la vista deve eseguire per rendersi. L'intera gerarchia delle viste \u00e8 rappresentata da una gerarchia di display list.</p> <p>Dopo che l'UI thread ha completato il traversal (misura, layout e disegno) e ha generato la gerarchia delle Display List, queste informazioni vengono sincronizzate con il Render Thread.</p> <p>Per evitare di sovraccaricare il UI Thread, Android introduce il RenderThread, un thread separato che gestisce il disegno e l\u2019invio dei comandi alla GPU.</p> <p>Una volta che il UI Thread ha terminato il suo lavoro, il RenderThread prende in carico il frame e segue questi passaggi:</p> <ol> <li>Sync \u2192 Riceve i dati dal UI Thread e li sincronizza con lo stato attuale della grafica.</li> <li>Execute \u2192 Processa i comandi di rendering, preparando la scena da inviare alla GPU.</li> <li>Get Buffer \u2192 Recupera un buffer di rendering, ovvero un\u2019area di memoria in cui verr\u00e0 disegnato il frame.</li> <li>Issue \u2192 Converte i comandi in istruzioni per la GPU.</li> <li>Swap Buffer \u2192 Una volta che tutto \u00e8 pronto, il RenderThread invia il frame alla GPU e chiede il prossimo buffer per il frame successivo.</li> </ol> <p>Il Render Thread prende queste Display List, che sono una rappresentazione delle operazioni di disegno a livello Java, e le trasforma in qualcosa che pu\u00f2 effettivamente elaborare per la GPU. Queste rappresentazioni native delle operazioni di disegno sono chiamate Display List Operations (DL ops).</p> <p>Le DL ops sono quindi la forma in cui le intenzioni di disegno dell'applicazione, espresse tramite le API Canvas a livello Java, vengono tradotte in operazioni concrete che il Render Thread pu\u00f2 ottimizzare e inviare alla GPU.</p> <p>Un esempio di DL op \u00e8 una fill operation che corrisponde all'operazione di riempire una determinata area con un colore. Altre DL ops rappresenterebbero il disegno di testo, linee, bitmap, ecc..</p> <p>In sostanza, le DL ops sono un intermediario tra la rappresentazione astratta del disegno (Display List) e i comandi concreti inviati alla GPU.</p> <p>Le DL ops vengono ottimizzate tramite riordinamento (reordering) delle operazioni di disegno.</p> <p>L'obiettivo del riordinamento \u00e8 di raggruppare operazioni di disegno simili che non si sovrappongono per minimizzare i cambi di stato della GPU, che sono operazioni molto costose in termini di prestazioni.</p> <p>Attraverso il riordinamento, il Render Thread analizza le DL ops e, se possibile, le raggruppa. Quindi, tutte le operazioni di disegno dei rettangoli verrebbero eseguite insieme, seguite da tutte le operazioni di disegno del testo. In alcuni casi, operazioni simili possono anche essere batching (raggruppate) ulteriormente in una singola chiamata alla GPU per maggiore efficienza.</p> <p>Questa ottimizzazione pu\u00f2 portare a miglioramenti significativi nelle prestazioni del rendering, specialmente in scenari con molte operazioni di disegno simili, come ad esempio nel rendering di liste complesse.</p> <p>Il riordinamento non pu\u00f2 essere applicato se le operazioni di disegno si sovrappongono, poich\u00e9 in tal caso l'ordine \u00e8 cruciale per rispettare il blending e l'alpha blending.</p> <p>A questo punto, entra in gioco la Graphics Pipeline, ovvero la parte hardware responsabile del rendering finale. Il suo compito \u00e8 prendere i comandi ricevuti dal RenderThread e trasformarli in pixel sullo schermo.</p> <ol> <li>Get Buffer \u2192 La GPU recupera il buffer con i dati da disegnare.</li> <li>Swap Buffer \u2192 Il buffer contenente il nuovo frame viene inviato allo schermo.</li> <li>Composite \u2192 Infine, la GPU compone il frame con altri layer grafici e lo mostra all\u2019utente.</li> </ol> <p>A questo punto interviene il SurfaceFlinger \u00e8 un servizio di sistema responsabile della composizione di tutti i window (finestre) visibili sullo schermo.</p> <p>Ogni finestra ha associata una BufferQueue, una coda di buffer grafici dove risiedono i dati pixel prodotti dall'applicazione (o da altri servizi di sistema). La BufferQueue ha due estremit\u00e0: un produttore, il Window Manager che inserisce i buffer nella coda e un consumatore, l\u2019Activity Manager che li preleva.</p> <p>Quando il render thread chiama swapBuffers, accodando nel queue buffer il buffer renderizzato nella BufferQueue. SurfaceFlinger acquisisce questi buffer pronti per essere composti.</p> <p>SurfaceFlinger comunica con l'Hardware Composer (HWC), che \u00e8 un'astrazione hardware specifica del dispositivo in grado di comporre pi\u00f9 layer (bitmap) in modo molto efficiente, spesso senza utilizzare la GPU, per risparmiare energia. L'HWC decide come gestire ciascun layer:</p> <ul> <li>Se l'HWC supporta il formato pixel del layer e non ci sono troppe trasformazioni complesse, pu\u00f2 gestirlo come un overlay, componendolo direttamente sull'hardware.</li> <li>In alcuni casi, l'HWC potrebbe non essere in grado di gestire un layer come overlay, allora il SurfaceFlinger deve utilizzare la GPU per comporre questi layer in un frame buffer (un buffer di rendering temporaneo) tramite comandi OpenGL, un'API utilizzata in Android per il rendering 2D e 3D.</li> </ul> <p>Indipendentemente dal fatto che la composizione avvenga tramite HWC o GPU, SurfaceFlinger combina tutti i layer visibili (le finestre di tutte le applicazioni, la barra di stato, la barra di navigazione) e invia il risultato all'hardware del display per essere visualizzato.</p>"},{"location":"30_Frameworks_Tools/Android/Intent/","title":"INTENT","text":"<p>In Android, un Intent \u00e8 un meccanismo IPC per comunicare con il sistema operativo e fra le applicazioni. Gli Intent sono messaggi che effettuano una richiesta all'Android runtime per avviare un'activity o un altro componente dell'app o di un'altra app. Invece di avviare direttamente le activity, si costruiscono Intent con la classe Intent e si chiama il metodo startActivity() per inviare l'intent.</p> <p>Un Intent esplicito specifica l'activity (o un altro componente) ricevente tramite il suo nome di classe completo. Si utilizzano Intent espliciti per avviare componenti all'interno della propria applicazione. Per creare un Intent esplicito, si utilizza un Context e un oggetto Class. Il metodo newIntent() pu\u00f2 essere utilizzato per configurare correttamente un Intent esplicito con gli extra necessari. L'activity ricevente ottiene l'Intent con getIntent() e recupera i dati dagli extra. \u00c8 anche possibile avviare un'activity aspettandosi un risultato utilizzando startActivityForResult(Intent, requestCode). L'activity chiamata invier\u00e0 un risultato tramite un altro Intent, e l'activity chiamante ricever\u00e0 il risultato nel metodo onActivityResult(). Una Activity avviata tramite startActivity \u00e8 indipendente da quella chiamante e non fornir\u00e0 alcun dato di risposta alla chiusura.</p> <p>Laddove \u00e8 richiesto un feedback, \u00e8 possibile avviare un'attivit\u00e0 come subactivity che pu\u00f2 restituire irisultati al suo genitore. Per fare questi si utilizza startActivityForResult(). Quando la sub-activity \u00e8 pronta per essere restituita, si utilizza setResultprima della fine per restituire un risultato all'attivit\u00e0 chiamante.Il metodo setResultaccetta due parametri: il codice del risultato e i dati del risultato stesso, rappresentati come un Intent.</p> <p>Il codice del risultato indica il successo dell'esecuzione dell'attivit\u00e0 secondaria (RESULT_OK) o insuccesso (Activity.RESULT_CANCELED).</p> <p>Un Intent implicito non specifica un'activity o un altro componente specifico per ricevere l'intent. Invece, si dichiara un'azione generica da eseguire nell'intent. Il sistema Android abbina la richiesta a un'activity o a un altro componente in grado di gestire l'azione richiesta (late binding). Se pi\u00f9 activity corrispondono, all'utente viene presentata una finestra di dialogo di selezione dell'app. Le activity dichiarano la loro capacit\u00e0 di gestire Intent impliciti tramite i filtri di intent definiti nel file AndroidManifest.xml. Per inviare un Intent implicito, si crea un oggetto Intent specificando l'azione, i dati (se presenti) e il tipo MIME dei dati. Prima di chiamare un Intent implicito, \u00e8 buona pratica verificare se ci sono activity in grado di gestirlo chiamando resolveActivity(getPackageManager()). Se si desidera mostrare sempre all'utente un chooser di app quando pi\u00f9 app possono gestire l'intent, si pu\u00f2 utilizzare Intent.createChooser(Intent target, String title).</p> <p>Il passaggio da un'Activity ad un'altra coinvolge i cicli di vita di entrambe. La prima, quella messa a riposo, dovr\u00e0 passare almeno per onPause() e onStop() mentre la seconda percorrer\u00e0 la catena di creazione onCreate-onStart-onResume. La priorit\u00e0 del sistema \u00e8 il mantenimento della fluidit\u00e0 della user-experience, quindi:</p> <ul> <li>La prima Activity passa per onPause e viene fermata in stato Paused;</li> <li>La seconda Activity va in Running venendo attivata completamente. In tale maniera l'utente potr\u00e0 usarla al pi\u00f9 presto non subendo tempi di ritardo;</li> <li>a questo punto, mentre l'utente sta gi\u00e0 usando la seconda Activity, il sistema pu\u00f2 invocare\u00a0onStop sulla prima.</li> </ul>"},{"location":"30_Frameworks_Tools/Android/Intent/#filtri","title":"FILTRI","text":"<p>I filtri di intent sono dichiarazioni nel file manifest di un componente dell'app (solitamente un'attivit\u00e0, un servizio o un ricevitore di broadcast) che specificano i tipi di intent che il componente pu\u00f2 gestire.</p> <p>I filtri di intent sono fondamentali per il funzionamento degli intent impliciti. Quando un'applicazione invia un intent implicito, il sistema Android utilizza i filtri di intent dichiarati da tutte le app installate per determinare quale componente \u00e8 il pi\u00f9 adatto a gestire la richiesta.</p> <p>I filtri di intent sono dichiarati nel file AndroidManifest.xml all'interno dell'elemento ,  o  usando uno o pi\u00f9 elementi  che pu\u00f2 contenere tre tipi di elementi che corrispondono alle informazioni contenute in un oggetto Intent: <ul> <li>: Specifica l'azione generica che il componente pu\u00f2 eseguire. Le azioni sono definite come costanti nella classe Intent. Un intent implicito deve contenere un'azione che corrisponda ad almeno una delle azioni dichiarate nel filtro. \u00c8 possibile specificare pi\u00f9 azioni all'interno dello stesso filtro. <li>: Fornisce informazioni aggiuntive sulla categoria del componente che dovrebbe gestire l'intent. Le categorie sono definite come costanti nella classe Intent. Un intent deve corrispondere a tutte le categorie specificate in un filtro per passare. \u00c8 importante notare che tutte le attivit\u00e0 che intendono ricevere intent impliciti devono includere la categoria android.intent.category.DEFAULT, in quanto questa categoria viene aggiunta implicitamente a tutti gli oggetti Intent impliciti dal sistema Android. <li>: Specifica il tipo di dati che il componente pu\u00f2 gestire. Questo include il tipo MIME dei dati o altri attributi di un URI (come lo schema, l'host, la porta e il percorso). Un intent pu\u00f2 specificare un URI di dati e/o un tipo MIME. Il filtro pu\u00f2 dichiarare quali schemi URI e tipi MIME sono supportati. <p>Per un intent implicito affinch\u00e9 venga consegnato a un componente, l'intent deve superare i test di tutti e tre gli elementi (azione, categoria e dati) definiti in almeno uno dei filtri di intent dichiarati dal componente. Se un componente ha pi\u00f9 filtri di intent, un intent che non corrisponde a un filtro potrebbe comunque corrispondere a un altro.</p>"},{"location":"30_Frameworks_Tools/Android/Intent/#gli-extras","title":"GLI EXTRAS","text":"<p>Gli Intent \u00e8 che essi, nel recapitare questo messaggio, portano con se dati che possono essere letti dal destinatario. Questi valori condivisi mediante Intent vengono chiamati Extras e possono essere di varie tipologie, sia appartenenti a classi pi\u00f9 comuni che ad altre purch\u00e9 serializzabili. La gestione degli Extras negli Intent funziona in maniera simile ad una struttura dati HashMap: con dei metodi putviene inserito un valore etichettato con una chiave e con i corrispondenti metodi get viene prelevato il valore, richiedendolo mediante la chiave di riconoscimento.</p>"},{"location":"30_Frameworks_Tools/Android/Intent/#paramtri-intent","title":"PARAMTRI INTENT","text":"<p>Activity class (per Intent espliciti): il nome della classe dell'activity o del componente che dovrebbe ricevere l'intent.</p> <p>Intent action: l'azione generica che l'activity ricevente dovrebbe eseguire. Le azioni disponibili sono definite come costanti nella classe Intent e iniziano con ACTION_. Esempi includono ACTION_VIEW, ACTION_SEND e ACTION_PICK.</p> <p>Intent category: fornisce informazioni aggiuntive sulla categoria del componente che dovrebbe gestire l'intent. Le categorie sono opzionali e possono essere aggiunte con il metodo addCategory(). Esempi includono CATEGORY_LAUNCHER, CATEGORY_DEFAULT e CATEGORY_BROWSABLE. Per rispondere a Intent impliciti, un filtro di intent deve impostare esplicitamente la categoria DEFAULT, che viene aggiunta implicitamente a ogni Intent implicito.</p> <p>Intent data: contiene un riferimento ai dati su cui l'activity ricevente dovrebbe operare, come un oggetto Uri. Pu\u00f2 rappresentare un URL web, un numero di telefono o un percorso a un file. Il tipo di dati pu\u00f2 anche essere specificato con il metodo setType(), utilizzando un tipo MIME.</p> <p>Intent extras: coppie chiave-valore che trasportano informazioni aggiuntive richieste dall'activity ricevente. I valori possono essere tipi primitivi o oggetti che implementano l'interfaccia Parcelable. I metodi putExtra() vengono utilizzati per aggiungere extra a un Intent, e getIntent().getExtras() o metodi specifici come getStringExtra() o getIntExtra() vengono utilizzati per recuperarli nell'activity ricevente.</p> <p>Intent flags: metadati aggiuntivi che istruiscono il sistema Android su come avviare un'activity o come trattarla dopo l'avvio.</p>"},{"location":"30_Frameworks_Tools/Android/Intent/#tipi-di-intent","title":"TIPI DI INTENT","text":"<p>Un broadcast intent \u00e8 un tipo di intent che non avvia un'activity specifica, ma viene consegnato a tutti i broadcast receiver interessati registrati per tale intent. I broadcast receiver sono componenti che ascoltano specifici broadcast di sistema o personalizzati.</p> <p>Un PendingIntent \u00e8 un token che si concede a un'altra applicazione per utilizzare le autorizzazioni del proprio processo per eseguire un'azione in un secondo momento. Viene spesso utilizzato per le notifiche.</p> <p>Un IntentService \u00e8 una sottoclasse di Service che gestisce le richieste intent in background, una alla volta.</p>"},{"location":"30_Frameworks_Tools/Spring/Spring_MOC/","title":"\ud83d\uddfa\ufe0f Spring (MOC)","text":"<p>Stato: #seed | Collegamenti: [[index]]</p>"},{"location":"30_Frameworks_Tools/Spring/Spring_MOC/#indice-argomenti","title":"\ud83d\udccc Indice Argomenti","text":""},{"location":"40_Design_Patterns/Architecture_Overview/","title":"Architecture Overview","text":"<p>Stato: #seed</p>"},{"location":"40_Design_Patterns/Architecture_Overview/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"40_Design_Patterns/SOLID_Principles/","title":"SOLID Principles","text":"<p>Stato: #seed</p>"},{"location":"40_Design_Patterns/SOLID_Principles/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"40_Design_Patterns/Software%20Design%20Note/","title":"Software Design Note","text":"<p>SOFTWARE DESIGN</p> <p>Andare a definire il concetto di qualit\u00e0 per un software non \u00e8 proprio semplice, perch\u00e9 pe un software non \u00e8 possibile definire degli obiettivi precisi, questi dipendono da cosa ha bisogno chi richiede il software</p> <p>La qualit\u00e0 viene definita sulla base di alcune caratteristiche si possono attribuire al codice come:</p> <ul> <li>Funzionalit\u00e0</li> <li>Reliabulity</li> <li>Usabilit\u00e0</li> <li>Efficienza</li> <li>Manutenibilit\u00e0</li> <li>Portabilit\u00e0</li> <li>Component replacebility</li> </ul> <p>Partendo da queste caratteristiche si definiscono delle metriche per misurare queste, e sulla base di queste \u00e8 definita la qualit\u00e0 di un software. \u00c8 necesarrio capire quindi come aggregare queste misure.</p> <p>La progettazione del software (il processo) \u00e8 la costruzione di astrazioni di dati e calcolo e l'organizzazione di queste astrazioni in un'applicazione software funzionante - Martin P. Robillard</p> <p>Quindi questo vuol dire andare a definire che struttura dati usiamo per il contesto, come gestiamo le eccezione ecc. Si tratta di un processo euristico e iterativo guidato dalla conoscenza della materia e che porta a scrivere un codice che sia progettualmente pulito in modo da avere meno errori ed \u00e8 possibile modificare con pi\u00f9 semplicit\u00e0.</p> <p>L\u2019obiettivo del software design \u00e8 quello di andare a definire in modo chiaro il contesto che andiamo a modellare, definendo i requisiti e constraint del dominio.</p> <p>Il design pu\u00f2 essere inteso come un insieme di decisioni per modellare il problema e che ci permettono di catturare la conoscenza del dominio. Per poter fare questo le soluzione sono descritte tramite dei modelli che vengono chiamati design patter e che furono introdotti dalla GoF, i quattro cristi che hanno dato via e evoluto il movimento agile.</p> <p>Crearono un catalogo di 23 design patter, dando soluzioni a problemi ricorrenti.</p> <p>I pattern non sono implementazioni concrete, ma \u201cschemi che defiscono un certo modo d struttura il codice per poter rendere il codice pulito e comprensibile.</p> <p>DESIGN PATTER</p> <p>Un design pattern ha 4 componenti principali:</p> <ul> <li>nome del pattern, \u00e8 il modo con cui in una o due parole possiamo riferirci ad un problema, la sua soluzione e le conseguenze della sua applicazione.</li> <li>problema descrive quando \u00e8 possibile applicare il pattern. Esso cio\u00e8 esplicita il contesto.</li> </ul> <p>contestoinsieme di condizioni e situazioni in cui un pattern \u00e8 applicabile</p> <ul> <li>soluzione, descrive gli elementi che fanno parte del progetto, le loro relazioni, responsabilit\u00e0 e collaborazioni. Essa non descrive una specifica implementazione in quanto un pattern deve poter essere applicabile in diverse situazioni concrete.</li> <li>conseguenze, sono il risultato di trade-offs derivanti dall'applicazione del pattern. Esse sono di importanza critica nella valutazione di alternative di progetto e per la comprensione di costi e benefici relative all'applicazione del pattern.</li> </ul> <p>I pattern sono classificai sulla base del</p> <ul> <li>purpose, cosa fa</li> <li>scope, se si applica alle classi o agli oggetti</li> </ul> <p>Creational Patterns</p> <p>Gestiscono la creazione degli oggetti, cercando di astrarre il processo di istanziazione. Lo scopo \u00e8 rendere il sistema indipendente dalla modalit\u00e0 di creazione, composizione e rappresentazione degli oggetti.</p> <p>Structural Patterns</p> <p>Si occupano della composizione delle classi e degli oggetti, facilitando la creazione di strutture flessibili ed efficienti.</p> <p>Behavioral Patterns</p> <p>Si concentrano sugli algoritmi e sulla comunicazione tra oggetti, migliorando l'interazione e la responsabilit\u00e0 tra componenti.</p> <p>Principi della OOP alla Base dei Design Pattern</p> <p>I principali concetti su cui si basano i design pattern sono quattro: incapsulamento, astrazione, ereditariet\u00e0 e polimorfismo.</p> <p>Incapsulamento il principio secondo cui i dettagli interni di un oggetto devono essere nascosti (Information Hiding) al mondo esterno, esponendo solo ci\u00f2 che \u00e8 strettamente necessario attraverso un\u2019interfaccia pubblica. Questo consente di proteggere lo stato interno dell\u2019oggetto da modifiche non autorizzate e di mantenere sotto controllo la complessit\u00e0 del sistema.</p> <p>Astrazione permette di modellare concetti complessi nascondendone i dettagli non rilevanti, concentrandosi solo sulle caratteristiche fondamentali. Questo principio guida la progettazione di interfacce e classi astratte, che permettono di definire comportamenti generici che possono poi essere specializzati da classi concrete.</p> <p>Ereditariet\u00e0 consente di riutilizzare il codice definito in una classe base in una o pi\u00f9 classi derivate. Questo facilita la costruzione di gerarchie di classi in cui le specializzazioni si basano su un comportamento generico gi\u00e0 definito. Nei design pattern, questo principio \u00e8 spesso usato per delegare la responsabilit\u00e0 di alcune operazioni a sottoclassi.</p> <p>Polimorfismo consente di trattare oggetti di classi diverse come se appartenessero alla stessa interfaccia, sfruttando la possibilit\u00e0 di invocare metodi in modo dinamico a seconda del tipo reale dell\u2019oggetto.</p> <p>I Principi SOLID</p> <p>Oltre ai principi fondamentali dell\u2019OOP, molti design pattern si ispirano ai principi SOLID, un insieme di linee guida introdotte da Robert C. Martin (Uncle Bob) per facilitare la progettazione di software mantenibile ed estensibile:</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-single-responsibility-principle-srp-ogni-classe-o-metodo-dovrebbe-avere-una-sola-responsabilita-o-motivo-di-cambiamento","title":"1. Single Responsibility Principle (SRP) \u2013 Ogni classe o metodo dovrebbe avere una sola responsabilit\u00e0 o motivo di cambiamento.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-openclosed-principle-ocp-le-entita-software-dovrebbero-essere-aperte-allestensione-ma-chiuse-alla-modifica","title":"2. Open/Closed Principle (OCP) \u2013 Le entit\u00e0 software dovrebbero essere aperte all\u2019estensione ma chiuse alla modifica.","text":"<p>Le classi sono aperte alle estensioni tramite l\u2019implementazione di interfacce o l\u2019ereditariet\u00e0, ma chiuse alle modifiche, poich\u00e9 il comportamento esistente rimane inalterato. Favorisce la modularit\u00e0 del codice e la facilit\u00e0 di estensione del sistema. Possiamo aggiungere nuovi tipi di veicoli senza dover modificare il codice esistente, garantendo una maggiore stabilit\u00e0 e riducendo il rischio di introdurre nuovi bug.</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#3-liskov-substitution-principle-lsp-le-classi-derivate-devono-poter-sostituire-le-classi-base-senza-alterare-il-comportamento-previsto-questo-principio-e-fondamentale-per-garantire-che-luso-del-polimorfismo-sia-corretto-e-prevedibile","title":"3. Liskov Substitution Principle (LSP) \u2013 Le classi derivate devono poter sostituire le classi base senza alterare il comportamento previsto. Questo principio \u00e8 fondamentale per garantire che l\u2019uso del polimorfismo sia corretto e prevedibile.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#4-interface-segregation-principle-isp-e-meglio-avere-interfacce-specifiche-e-limitate-piuttosto-che-una-singola-interfaccia-generica-e-pesante","title":"4. Interface Segregation Principle (ISP) \u2013 \u00c8 meglio avere interfacce specifiche e limitate piuttosto che una singola interfaccia generica e pesante.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#5-dependency-inversion-principle-dip-le-classi-dovrebbero-dipendere-da-astrazioni-non-da-classi-concrete-riducendo-laccoppiamento-tra-le-componenti-del-sistema","title":"5. Dependency Inversion Principle (DIP) \u2013 Le classi dovrebbero dipendere da astrazioni, non da classi concrete riducendo l\u2019accoppiamento tra le componenti del sistema.","text":"<p>ANTIPATTER</p> <p>Come esistono le buone idee, esistono anche le idee di merda\u2026 i bad smells, o antipattern, soluzioni che sembrano ottime, ma fanno cagare.</p> <p>ENCAPSULATION</p> <p>Il PRIMITIVE OBSESSION \u00e8 un antipattern in cui si usa eccessivamente tipi primitivi (come stringhe, interi, booleani, ecc.) per rappresentare concetti complessi o entit\u00e0 del dominio del problema, invece di creare tipi o classi specifiche per quei concetti.</p> <p>Questo \u00e8 un problema perch\u00e9 ci\u00f2 rende il codice meno chiaro e meno espressivo, aumenta il rischio di errori perch\u00e9 non c\u2019\u00e8 nessuna validazione o comportamento incapsulato o controllo sui valori che pu\u00f2 assumere.</p> <p>Quindi quando dobbiamo rappresentare oggetti della realt\u00e0 nel codice conviene creare un classe che li modelli per avere pi\u00f9 controllo su di esso. Creando una classe incapsuliamo anche la logica e di funzionamento con tutte le informazioni ad essere relative.</p> <p>L\u2019Escaping References accade quando un oggetto \u201clascia scappare\u201d i riferimenti ai suoi dati interni, cio\u00e8 quando d\u00e0 accesso diretto a qualcosa che dovrebbe invece tenere nascosto e sotto controllo.</p> <p>Per esempio, immagina che una classe abbia una lista di cose importanti, tipo le transazioni di un conto bancario. Se questa lista viene restituita direttamente quando qualcuno la chiede, allora quella persona pu\u00f2 cambiarla a piacimento, anche senza passare dai metodi sicuri della classe.</p> <p>Questo \u00e8 un problema perch\u00e9 cos\u00ec perdi il controllo su cosa succede dentro l\u2019oggetto. La lista potrebbe essere modificata in modo sbagliato, causando errori o dati incoerenti.</p> <p>Non basta dichiarare una variabile di istanza privata per evitare l\u2019escape reference, perch\u00e9 anche usando i getter, potremmo degradare l\u2019incapsulamento. Avere una classe a cui si accede solo tramite i getter e i setter \u00e8 una debolezza delle progettazione, noto come INAPPROPRIATE INTIMACY, perch\u00e9 le classi passano troppo tempo a esplorare le parti private delle altre. BAH! Sono gli oggetti che dovrebbero interagire tra loro usando i metodi che hanno a disposizione.</p> <p>La soluzione? Non dare mai direttamente i tuoi dati \u201cinterni\u201d, ma invece restituisci una copia di quei dati. In questo modo chi riceve la lista pu\u00f2 modificarla quanto vuole, ma senza influenzare quella originale dentro l\u2019oggetto. Oppure, puoi usare metodi specifici per far fare le modifiche solo in modo controllato. Cos\u00ec, mantenere tutto sotto controllo diventa pi\u00f9 facile e il codice rimane pi\u00f9 robusto.</p> <p>Un\u2019altra soluzione \u00e8 l\u2019immutabilit\u00e0 in modo da rendere le classi immodificabili nel loro stato interno, se non tramite i suoi metodi.</p> <p>Design by Contract, \u00e8 un approccio in cui ogni componente software \u00e8 visto come un contratto e stabilisce cosa ogni parte deve garantire e cosa si aspetta in cambio.Un contratto, nel contesto del software, si basa su tre elementi:</p> <ul> <li>Precondizioni: sono le condizioni che devono essere vere prima che un\u2019operazione venga eseguita. Il chiamante ha la responsabilit\u00e0 di assicurarsi che queste condizioni siano soddisfatte. Se le precondizioni non sono rispettate, il comportamento del metodo \u00e8 indefinito.</li> <li>Postcondizioni: sono le condizioni che il metodo garantisce al termine della sua esecuzione, a patto che le precondizioni fossero vere. Se il metodo ha completato correttamente, allora queste condizioni devono sempre risultare vere.</li> <li>Invarianti: sono condizioni che devono rimanere sempre vere durante l\u2019intera vita di un oggetto. Esse definiscono lo stato valido dell\u2019oggetto e aiutano a mantenere la coerenza interna indipendentemente dalle operazioni eseguite.</li> </ul> <p>TYPES E INTERFACE</p> <p>Sappiamo che cos\u2019\u00e8 un interfaccia nella OOP. Un particolarit\u00e0 di queste sottovalutata \u00e8 la possibilit\u00e0 di gestire il polimorfismo e anche l\u2019ereditariet\u00e0 multipla che in java non \u00e8 permessa.</p> <p>Nelle classi che progettiamo il fatto di mettere i metodi direttamente nella classe, causa il problema dell\u2019accoppiamento con la sua definizione. Un principio importante di progettazione \u00e8 il disaccoppiamento del comportamento dalla definizione della classe per rendere il tutto pi\u00f9 indipendente dal tipo di servizio che deve essere implementato. L\u2019interfaccia permette di definire un tipo, obv con la caratteristica che l\u2019interfaccia non si pu\u00f2 instanziare, ma le sue classi concrete s\u00ec. La relazione che si viene a creare fra l\u2019interfaccia e la sua classe concreta, \u00e8 una relazione polimorfica di sottotipo, quindi \u00e8 possibile assegnare ad una variabile definita come tipo interfaccia, una qualunque classe concreta che implementa l\u2019interfaccia.</p> <p>Il polimorfismo permette:</p> <ul> <li>l\u2019accoppiamento debole, perch\u00e9 il codice che utilizza un insieme di metodi vincolato ad una specifica implementazione, si definisce a runtime, quindi si possono chiamare solo i metodi in essa definiti</li> <li>l\u2019estensibilit\u00e0 perch\u00e9 possiamo facilmente aggiungere nuove implementazioni</li> </ul> <p>L\u2019interfaccia pu\u00f2 servire anche a definire un comportamento per le classi che le implementano. Tipo Comparable. Per rispettare il principio ISP le interfacce devono implementare pochi metodi, e in questo cosa per definire i comportamenti solo uno. <p>Se non usassimo una interfaccia dovremmo modificare in modo pesante il codice, questo antipattern \u00e8 noto come SWITCH STATEMENT. La soluzione \u00e8 quella di creare una classe che implementa l\u2019interfaccia e un certo comportamento. Queste sono dette anche function object che solo classi con solo funzioni. Tutto ci\u00f2 pu\u00f2 essere evitato con:</p> <ul> <li>nested class, si definisce la classe nello scope di un\u02bcaltra</li> <li>anonymous class, una classe senza nome che viene definita e istanziata direttamente nel punto in cui serve</li> <li>lambda expression, una forma compatta di scrivere funzioni anonime, usata per implementare interfacce funzionali, cio\u00e8 interfacce con un solo metodo astratto.</li> </ul> <p>Queste possono essere passate ad altre funzione, che oltre a prendere dati prendono funzioni, comportamenti diversi che vengono applicati sui dati, in modo che venga eseguita a un certo punto.</p> <p>Questo viola l\u2019incapsulamento perch\u00e9 usano il costruttore o gli altri modi mostriamo lo stato della classe. Un modo per rafforzarlo \u00e8 lo STATIC FACTORY METHOD che nasconde la logica di creazione. Consiste nell\u2019implementare un metodo statico che restituisce un\u2019istanza di quella classe.</p> <ul> <li>I metodi factory statici possono restituire lo stesso tipo che implementa il metodo, un sottotipo e anche primitive, offrendo una gamma pi\u00f9 flessibile di tipi restituiti</li> <li>I metodi factory statici possono essere metodi a istanziazione controllata, con il pattern Singleton, lo Strategy.</li> <li>Il factory method possono essre usati per creare oggetti immutabili, impedendo la modifica dello stato dopo la creazione. Questo rinforza ulteriormente l\u2019incapsulamento.</li> </ul> <p>STRATEGY PATTER</p> <p>Il fatto che alle objects function possiamo passare comportamenti simili, ma diversi, \u00e8 possibile grazie allo strategy pattern che permette di fornire una famiglia di algoritmi che implementa la stessa interfaccia, ma hanno un\u2019implementazione diversa. La scelta dell\u2019algoritmo dipende dal contesto che viene passato del client, quindi \u00e8 determinato a runtime.</p> <p></p> <p>ITERATOR PATTERN</p> <p>Un requisito di design per la progettazione delle strutture dati \u00e8 l\u2019accesso ai dati che contiene, ma senza violare il principio dell\u2019information hiding. Una soluzione migliore di ritornare una copia della collezione \u00e8 quella di fornire un metodo di accesso a questi dati, un iteratore che nasconde la struttura interna di come sono memorizzati i dati. Questo fortifica l\u2019incapsulamente, tranne nel caso ci siamo il metodo remove(). L\u2019iterator pattern fa proprio questo.</p> <p></p> <p>DEPENDENCY INJECTION</p> <p>Quando creiamo delle classi questi possono avere bisogno di oggetti di altre classi, quindi nel costruttore creiamo un\u2019istanza dell\u2019oggetto che ci server per completare la classe. SI viene a creare un dipendenza. (Pure le classi si drogano\u2026bha). Questo \u00e8 un problema perch\u00e9 lo leghiamo alla classe che viene iniettata e se questa cambia comportamento, definizione ecc, dobbiamo modificare ogni classe che ha una sua istanza. E pensa che palle.</p> <p>Una soluzione pu\u00f2 essere quella di usare le lambda, ma ci sono gli stessi problemi. Allora dobbiamo cercare di disaccoppiare le classi e lo si pu\u00f2 fare iniettando la dipendenza nella classe. (Ora la droghiamo noi). Lo si pu\u00f2 fare facendo stabile al client cosa usare. Ci sono anche altre soluzioni [VEDI DOPO]</p> <p>OBJECT STATE</p> <p>Si pu\u00f2 avere una visione duplice dello stato di un programma.</p> <p>statica, che avviene a compile-time, dove il codice viene analizzato e tradotto in un formato eseguibile. In questa fase, il compilatore conosce le dichiarazioni delle classi, i metodi disponibili, le gerarchie di ereditariet\u00e0 e i tipi associati alle variabili.</p> <p>dinamica, che avviene a run-time, in cui il comportamento effettivo del programma dipende da molti fattori che non sono visibili durante la compilazione, come i dati di input, le condizioni che si verificano nei vari rami del codice, lo stato interno degli oggetti e, soprattutto, il tipo reale degli oggetti creati in memoria.</p> <p>Queste due non \u00e8 detto che coincidano sempre. Questo \u00e8 dovuto al fatto al polimorfismo. Possiamo usare per rappresentare i possibili stati di un oggetto con i sequence, state e object diagrams.</p> <p>Importante \u00e8 definire l\u2019object state che si pu\u00f2 avere di un oggetto. Possiamo dire che un oggetto avr\u00e0 uno stato concreto, cio\u00e8 i valori che possono assumere le variabili che definiscono una classa. Bisogna considerare anche il suo state space, che rappresenta tutti i possibili valori che pu\u00f2 assumere. Ovviamente non sempre \u00e8 possibile rappresentarli tutti allora ci \u00e8 utile definire un sottoinsieme di queste, lo abstract space. Questo deve essere significato e deve cogliere gli aspetti importanti di come lo stato cambia e quali sono i suoi possibili passaggi di stato.</p> <p>Lo state diagram pu\u00f2 aiutare a fare questo e ci mostra il ciclo di vita di un oggetto.</p> <p>PRINCIPIO DI DESIGN evitare cicli di vita troppo complessi e minimizzare</p> <p>Lo spazio degli statti un oggetto</p> <p>Alcuni stati nello spazio degli stati potrebbero essere una conseguenza di come un oggetto \u00e8 progettato o implementato, senza che ci sia utilit\u00e0 per un oggetto in quello stato in un dato sistema software. In questi casi, eliminare alcuni stati dal ciclo di vita di un oggetto pu\u00f2 sembrare una buona idea, ma se se un giorno ne avessimo bisogno? Si cade nell\u2019antipattern della SPECULATIVE GENERALITY, cio\u00e8 ci preoccupiamo del futuro, ma non serve, se serviranno verranno aggiunte in seguito, mo pensa al presente.</p> <p>Sbagliato \u00e8 anche cachare informazioni nelle variabili di istanza, ma in realt\u00e0 dipende da situazione a situazione. Se usiamo un metodo per accedere a quello stato, ma si sa che quella informazione non verr\u00e0 mai modificato, allora la si pu\u00f2 storare nella classe. Se pu\u00f2 essere modificata nel corso del ciclo di vita dell\u2019oggetto allora teniamo il metodo per accedere a quello stato. \u00c8 un trade-off che dobbiamo tenere conto, se risparmiare un po' di tempo a costo di un po' di memoria extra, o viceversa. Il principio generale \u00e8 che le informazioni non dovrebbero essere memorizzate in un oggetto a meno che non contribuiscano in modo univoco al valore intrinseco rappresentato dall'oggetto, questo antipattern \u00e8 il TEMPORARY FIELD.</p> <p>I campi temporanei e tutto il codice che li gestisce possono essere inseriti in una classe separata tramite Extract Class. In altre parole, si crea una classe che ha quella informazione e si usa un metodo per poter accedere a quelle informazioni.</p> <p></p> <p>Questo metodo di refactoring contribuir\u00e0 a mantenere l'aderenza al principio di responsabilit\u00e0 unica.</p> <p>Introdurre NULL OBJECT e integrarlo al posto del codice condizionale utilizzato per verificare l'esistenza dei valori dei campi temporanei. Ma prima parliamo della nullability, la possibilit\u00e0 di assegnare valori null alle variabili per indicare l\u2019assenza di valore. Prima non si poteva, fu introdotto da Tony Hoare, con l\u2019obiettivo di rendere i riferimenti pi\u00f9 sicuro. Ma \u00e8 stata una idea del cazzo, perch\u00e9 ha introdotto altri problemi come, NullPointerException, SegmentationFault, difficolt\u00e0 nella verifica ecc\u2026</p> <p>Per evitare di ampliare lo spazio di stato di un oggetto con riferimenti nulli, una buona pratica consigliata \u00e8 progettare le classi in modo che i riferimenti nulli non vengano utilizzati. Ci sono vari modi per farlo.</p> <ul> <li>Assegnare i valori nel costruttore</li> <li>Verificare se i valori sono nulli e nel caso lanciare exception</li> <li>Design by contract</li> <li>modi migliori\u2026</li> </ul> <p>Gli optional type, sono delle classi wrapper che contengono un istanza del tipo che wrappiamo oppure non lo contengono. Come il gatto di Schr\u00f6dinger, non sai cosa contiene finch\u00e8 non unwrappi. Quindi il programmatore vedendo un costrutto del genere fa pi\u00f9 attenzione a fare controlli ecc.</p> <p>Un problema di questa soluzione e che perdiamo il tipo delle variabili, quindi dovremmo creare dei metodi per ottenere i tipi effettivi.</p> <p>Ritornando al NULL OBJECT, permette di risolvere questo problema e la nullability, prevedendo un oggetto che rappresenta il valore null per quella classe. Anche questo si basa sul polimorfismo.</p> <p>Consiste nell\u2019aggiungere un metodo per determinare su un oggetto \u00e8 nullo o meno e a secondo della condizione restituire o null o no. Oppure implementare una factory che nasconde tutto il funzionamento</p> <p>Per minimizzare ancora di pi\u00f9 lo spazio degli stati, possiamo oltre ad usare una classe Enumerate, stabilire anche un vincolo sul numero di volte che una variabile pu\u00f2 essere modificata. In java si pu\u00f2 usare final, per dire che il campo una volta assegnato non pu\u00f2 essere pi\u00f9 modificato e se si provasse a farlo avremmo un errore a compilation time. Da notare che la variabile final, contine un riferimento, ed \u00e8 questo che non pu\u00f2 essere modificato, ma lo stato dell\u2019oggetto riferito s\u00ec. I campi final per\u00f2 non rendono immutabili gli oggetti referenziati. A volte si usa la parola chiave final per chiarire che una variabile non deve essere modificata dopo la sua inizializzazione. Questo pu\u00f2 aiutare a rendere il codice pi\u00f9 leggibile, specialmente quando ci si trova in contesti pi\u00f9 lunghi o complessi dove il rischio di errore o confusione \u00e8 maggiore. Ma questo non dovrebbe essere mai fatto per via dell\u2019antipattern LONG METHOD che stabilisce che i metodi lunghi devono essere evitati.</p> <p>Tre concetti da tenere a mente quando si progettano i cicli di vita degli oggetti sono quelli di identit\u00e0, uguaglianza e unicit\u00e0.</p> <p>L'identit\u00e0 si riferisce al fatto che ci si riferisce a un oggetto specifico, anche se questo non si trova in una variabile, cio\u00e8 l'identit\u00e0 di un oggetto si riferisce solitamente alla sua posizione di memoria o riferimento/puntatore.</p> <p>L'uguaglianza tra due oggetti deve essere definita dal programmatore perch\u00e9 il significato dell'uguaglianza non pu\u00f2 sempre essere dedotto dalla progettazione della classe dell'oggetto</p> <p>L\u2019unicit\u00e0, il fatto di avere una solo istanziazione per quella classe. Se si pu\u00f2 garantire che gli oggetti di una classe siano unici, non \u00e8 pi\u00f9 necessario definire l'uguaglianza, perch\u00e9 in questo caso specifico, l'uguaglianza diventa equivalente all'identit\u00e0 e possiamo confrontare gli oggetti utilizzando l'operatore ==. Garanzie di unicit\u00e0 sono quasi impossibili da ottenere in Java a causa di meccanismi come la metaprogrammazione e la serializzazione.</p> <p>FLYWEIGHT PATTER</p> <p>Il Flyweight consiste nel condividere parti comuni dello stato tra oggetti, evitando di duplicare dati che possono essere riutilizzati. Gli oggetti flyweight sono spesso immutabili e leggeri, e servono a rappresentare solo lo stato intrinseco, mentre lo stato estrinseco viene passato dall\u2019esterno quando serve. Invece di creare milioni di oggetti simili, si condividono quelli uguali per risparmiare memoria.</p> <p>Per gestire la creazione di oggetti di una classe, si crea una classe flyweight. Le cui istanze sono chiamate oggetti flyweight. I tre componenti principali necessari per realizzare questo vincolo sono:</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-un-costruttore-privato-per-la-classe-flyweight-in-modo-che-i-client-non-possano-controllare-la-creazione-di-oggetti-della-classe","title":"1. Un costruttore privato per la classe flyweight, in modo che i client non possano controllare la creazione di oggetti della classe;","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-un-archivio-statico-di-oggetti-flyweight-che-conserva-una-collezione-di-oggetti-flyweight","title":"2. Un archivio statico di oggetti flyweight che conserva una collezione di oggetti flyweight;","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#3-un-metodo-di-accesso-statico-che-restituisce-loggetto-flyweight-univoco-corrispondente-a-una-chiave-di-identificazione-il-metodo-di-accesso-in-genere-verifica-se-loggetto-flyweight-richiesto-esiste-gia-nellarchivio-lo-crea-se-non-esiste-gia-e-restituisce-loggetto-univoco","title":"3. Un metodo di accesso statico che restituisce l'oggetto flyweight univoco corrispondente a una chiave di identificazione. Il metodo di accesso in genere verifica se l'oggetto flyweight richiesto esiste gi\u00e0 nell'archivio, lo crea se non esiste gi\u00e0 e restituisce l'oggetto univoco.","text":"<p>Quando lo spazio degli stati di una variabile \u00e8 limitato e ben definito, \u00e8 possibile inizializzare gli oggetti tramiteun blocco statico, che viene eseguito al primo caricamento della classe. In alternativa, si pu\u00f2 usare una struttura dati statica. Questo approccio \u00e8 statico perch\u00e9 l\u2019archivio dei flyweight \u00e8 condiviso a livello di classe, e non ha senso dover accedere a un oggetto tramite un'altra istanza dello stesso tipo. Questa combinazione di archivio statico e metodo di accesso viene spesso chiamata flyweight factory.</p> <p>Per facilitare l'accesso ai vari oggetti flyweight, si pu\u00f2 implementare un metodo factory che gestisce un pool di istanze esistenti. Il metodo accetta lo stato intrinseco richiesto, cerca un oggetto corrispondente nel pool e, se lo trova, lo restituisce; altrimenti, crea una nuova istanza, la aggiunge al pool e poi la restituisce.Questo metodo factory pu\u00f2 essere collocato in vari posti, a seconda del contesto:</p> <ul> <li>In un contenitore di flyweight dedicato</li> <li>In una classe factory separata</li> <li>Oppure come metodo statico all\u2019interno della stessa classe flyweight</li> </ul> <p>Un aspetto importante da considerare nell'implementazione del pattern FLYWEIGHT \u00e8 se pre-inizializzare l'archivio flyweight o se farlo in modo lazy, creando oggetti man mano che vengono richiesti tramite il metodo di accesso. Dipende dal contesto. Il pattern FLYWEIGHT \u00e8 utile quando si devono gestire oggetti flyweight immutabili, anche se ci possono essere errori se implementato in modo scorretto.</p> <p></p> <p>SINGLETON PATTERN</p> <p>Il Singleton viene utilizzato quando si desidera che una determinata classe abbia una sola istanza durante tutta l'esecuzione del programma, e che tale istanza sia facilmente accessibile da qualsiasi punto del codice.</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-un-costruttore-privato-per-la-classe-singleton-in-modo-che-i-client-non-possano-creare-piu-oggetti","title":"1. Un costruttore privato per la classe singleton, in modo che i client non possano creare pi\u00f9 oggetti;","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-una-variabile-globale-per-contenere-un-riferimento-alla-singola-istanza-delloggetto-singleton","title":"2. Una variabile globale per contenere un riferimento alla singola istanza dell'oggetto singleton.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#3-un-metodo-di-accesso-solitamente-chiamato-instance-che-restituisce-il-singleton-in-istanza-il-metodo-di-accesso-e-facoltativo-poiche-e-anche-possibile-implementare-il-pattern-dichiarando-listanza-globale-come-costante-pubblica","title":"3. Un metodo di accesso, solitamente chiamato instance(), che restituisce il singleton in istanza. Il metodo di accesso \u00e8 facoltativo, poich\u00e9 \u00e8 anche possibile implementare il pattern dichiarando l'istanza globale come costante pubblica.","text":"<p>Il pattern SINGLETON differisce da FLYWEIGHT in quanto cerca di garantire che esista una singola istanza di una classe, anzich\u00e9 istanze uniche di una classe. Gli oggetti Singleton sono tipicamente con stato e mutabili, mentre gli oggetti flyweight sono immutabili.</p> <p>Un errore tipico nell'implementazione del pattern SINGLETON \u00e8 quello di memorizzare un riferimento a un'istanza della classe in un campo statico chiamato INSTANCE o qualcosa di simile, senza prestare la dovuta attenzione a impedire al codice client di creare autonomamente nuovi oggetti. In questo caso, l'uso del nome Singleton \u00e8 pericolosamente fuorviante, poich\u00e9 gli utenti del codice potrebbero fare affidamento sul fatto che la classe produca una singola istanza quando in realt\u00e0 non \u00e8 cos\u00ec.</p> <p>Il modo classico per impedire l'istanziazione \u00e8 rendere privato il costruttore della classe.</p> <p>Bloch propone un trucco controverso, ovvero l'utilizzo di un tipo enumerato. Questo funziona perch\u00e9 il compilatore impedisce l'istanziazione di tipi enumerati. \u00c8 un po' confusionario, meglio attenersi a un costruttore privato per garantire il vincolo di singola istanza.</p> <p>Il SINGLETON, \u00e8 controverso, perch\u00e9 ci sono pi\u00f9 svantaggio che vantaggi.Un singleton \u00e8 un'istanza globale accessibile da qualsiasi punto del programma, ma questo lo rende facile da abusare, causando dipendenze nascoste e codice difficile da mantenere. Inoltre, essendo responsabile del proprio ciclo di vita, \u00e8 difficile da testare.</p> <p>Un\u2019alternativa migliore \u00e8 spesso l\u2019iniezione di dipendenza, che consente di passare un\u2019unica istanza ai componenti che ne hanno bisogno. Tuttavia, non impedisce la creazione di pi\u00f9 istanze: questo va garantito con attenzione progettuale e buona documentazione. L'iniezione, per\u00f2, aiuta a gestire e propagare in modo controllato la stessa istanza.</p> <p>Un problema particolare nella gestione dello stato \u00e8 dovuto dall'uso di classi annidate in Java. Le classi annidate possono essere suddivise in</p> <ul> <li>classi annidate statiche, una classe definita all\u2019interno di un\u2019altra classe con la parola chiave static. Non ha un riferimento implicito all\u2019istanza della classe esterna e pu\u00f2 essere usata senza creare un oggetto della classe esterna.</li> <li>classi interne, una classe definita all\u2019interno di un\u2019altra classe senza la parola chiave static e questo la lega ad ogni istanza della istanza della classe esterna potendo accedere direttamente alle sue variabili. A loro si suddividono in:</li> <li>classi anonime</li> <li>classi locali.</li> </ul> <p>Le classi locali sono classi che si definiscono all\u2019interno di un metodo di una classe esterna. La loro visibilit\u00e0 \u00e8 limitata proprio a quel metodo, quindi non possono essere usate al di fuori di esso. Un\u2019altra caratteristica importante \u00e8 che queste classi possono accedere ai parametri del metodo che le contiene, purch\u00e9 questi parametri siano dichiarati come final .</p> <p>Un caso particolare di classi locali sono le classi anonime. Queste sono classi locali senza un nome, definite direttamente all\u2019interno di un\u2019espressione. Vengono spesso usate quando si vuole creare rapidamente un\u2019implementazione di un\u2019interfaccia o di una classe astratta, senza dover scrivere una nuova classe con un nome specifico.</p> <p>Alernativa per implementare le function object \u00e8 usare questi costrutti. Spesso si vuole definire un comportamento che dipende da qualche valore locale al momento della sua creazione.</p> <p>\"Ma se il metodo finisce, quella variabile non dovrebbe sparire?\"</p> <p>Esiste un concetto chiamato closure una funzione che pu\u00f2 ricordare e usare le variabili del contesto in cui \u00e8 stata creata, anche dopo che quel contesto \u00e8 scomparso. In Java, quando usiamo classi anonime che fanno riferimento a variabili locali del metodo esterno, il compilatore salva automaticamente quelle variabili come campi interni nell\u2019oggetto che viene creato.</p> <p>COMPOSITION</p> <p>Nella OOP i vari costrutti possono relazionarsi fra loro o tramite composizione o tramite l\u2019ereditariet\u00e0. Queste due tecniche servono a stabilire come le parti di un software interagisco fra loro.</p> <p>La composizione si riferisce alla relazione parte di tra classi in cui il ciclo di vita degli oggetti contenuti \u00e8 strettamente associato al ciclo di vita dell'oggetto contenitore. La composizione \u00e8 un tipo di associazione in cui una classe contiene il riferimento ad un'altra. La composizione \u00e8 diversa dall\u2019aggregazione con cui si intende un insieme di oggetti (liste\u2026). La composizione \u00e8 utile per segmentare un classe che altrimenti sarebbe troppo complessa e ci\u00f2 violerebbe il principio della separazione delle responsabilit\u00e0. Si incorre in un anti pattern detto GOD CLASS, una classe che fa tutto, sa tutto degli altri oggetti ecc, ma questo \u00e8 sbagliato perch\u00e9 saremo constretti ad usare sempre questa classe per ogni cosa e ci\u00f2 incrementa le dipendeze che ci sono nel programma essendo che non la si pu\u00f2 estendere, creare un interfaccia ecc..</p> <p>Viola anche la</p> <p>Law of Demeter (LoD) \u2013 \"Principio del minimo contatto\"</p> <p>Violazione: Una God Class spesso accede direttamente a molte parti del sistema, diventando un nodo centrale che conosce troppo del resto dell'applicazione.</p> <p>Per evitare tutto ci\u00f2 si usa il meccanismo delle delega, cio\u00e8 si delegano ad altri oggetti le azioni che si devono fare, essendo loro specializzati ad operare su quell\u2019oggetto per quella azione. In questo modo si evita che un oggetto assuma troppe responsabilit\u00e0 ed \u00e8 possibile implementare strategie, comportamenti o operazioni intercambiabili.</p> <p>Una propriet\u00e0 della composizione \u00e8 la transitivit\u00e0, cio\u00e8 un oggetto composto da altri oggetti pu\u00f2, a sua volta, essere un componente o un delegato di un altro oggetto padre.</p> <p>Quando si lavora con queste gerarchie non \u00e8 importante sapere si si una la composizione come tale o come delega, perch\u00e9 essendo strutture ricorsive possono essere viste in entrambi i modi: come una relazione strutturale (composizione) oppure come una relazione comportamentale (delegazione). Ci\u00f2 che conta \u00e8 la responsabilit\u00e0 che ciascun oggetto si assume e il grado di accoppiamento che si instaura tra le varie componenti del sistema.</p> <p>COMPOSITE PATTERN</p> <p>Per poter creare una composizione esiste un design pattern, COMPOSITE PATTERN, che permette di trattare gruppi di oggetti come se fossero un oggetto singolo.</p> <p>Un modo per realizzarla \u00e8 quella di creare un interfaccia comune e di farla estendere da tutte le possibili implementazioni e di sfruttare le interfaccia e il polimorfismi, ma un problema \u00e8 che il numero di implementazioni pu\u00f2 esplodere e si dovrebbero avere gi\u00e0 tutte le implementazioni disponibili essendo definite staticamente e non a runtime. Una soluzione migliore \u00e8 stabilita dal COMPOSITE PATTERN.</p> <p>Il pattern presenta tre elementi/ruoli, componente, composito e foglia. L'elemento composito ha due caratteristiche:</p> <ul> <li>Aggrega diversi oggetti di tipo componente. L'utilizzo del tipo di interfaccia componente \u00e8 importante, poich\u00e9 consente composite per comporre qualsiasi altro tipo di elemento, inclusi altri compositi.</li> <li>Implementa l'interfaccia del componente. Questo \u00e8 ci\u00f2 che consente agli oggetti compositi di essere trattati dal resto del codice esattamente allo stesso modo degli elementi foglia.</li> </ul> <p>Il codice client dovrebbe dipendere principalmente dal tipo di componente e non manipolare direttamente i tipi concreti, per poter trattare tutti gli oggetti nello stesso modo.</p> <p></p> <p>L\u2019implementazione del metodo dell\u2019interfaccia permette di iterare, navigare attraverso l\u2019albero delle componenti e questo avviene perch\u00e9 i composite implementano anch\u2019essi l\u2019interfaccia Component e delegano il comportamento ai loro figli.</p> <p>Un problema di implementazione da considerare \u00e8 come aggiungere al composite le istanze del componente che compone, pu\u00f2 essere fatto in due modi principali.</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-avere-un-metodo-nel-composite-che-prenvede-laggiunto-del-figlio-eventualmente-anche-la-modifica-il-getchild-e-la-rimozione-ma-s-deve-includere-il-metodo-add-nel-componente-no-allora","title":"1. Avere un metodo nel composite che prenvede l\u2019aggiunto del figlio (eventualmente anche la modifica, il getChild e la rimozione), ma s deve includere il metodo add nel componente?. No allora","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-li-si-inserisce-nel-composite-tramite-il-costruttore-lista","title":"2. Li si inserisce nel composite tramite il costruttore (lista \u2026).","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#a-usiamo-il-costruttore-di-copia-per-evitare-la-perdita-di-un-riferimento-alla-struttura-della-collezione-privata","title":"a. Usiamo il costruttore di copia per evitare la perdita di un riferimento alla struttura della collezione privata.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#b-o-utilizzare-il-meccanismo-varargs-di-java-per-elencare-singolarmente-ogni-sorgente-di-carta","title":"b. O utilizzare il meccanismo varargs di Java per elencare singolarmente ogni sorgente di carta.","text":"<p>Si preferisce il metodo add perch\u00e9 pu\u00f2 essere necessario modificare lo stato del composite in fase di esecuzione.</p> <p>Questo aggiunge complessit\u00e0 al codice perch\u00e9 \u00e8 necessario gestire un ciclo di vita pi\u00f9 complesso per l'oggetto composite e la differenza tra l'interfaccia del componente (che non ha il metodo add) e quella del composito (che ce l'ha).</p> <p>Se la modifica del composito in fase di esecuzione non \u00e8 necessaria, \u00e8 probabilmente meglio inizializzarlo una volta e lasciarlo cos\u00ec com'\u00e8.</p> <p>Alcuni aspetti pratici relativi all'utilizzo del pattern sono indipendenti dalla struttura del pattern stesso, la soluzione dipender\u00e0 dal problema di progettazione specifico in questione. (sequence diagram).</p> <p>DECORATOR PATTER</p> <p>In certe situazioni \u00e8 necessario avere oggetti che svolto una stessa azione, ma in modo diverso o che hanno particolari caratteristiche. Quindi possiamo creare una classe specializzato per poter fare questo. Questo lo si pu\u00f2 fare tramite ereditariet\u00e0 estendo la classe, ma non darebbe flessibilit\u00e0 al codice perch\u00e9 crea un legame statico fra le classi, ed \u00e8 difficile poi cambiare comportamento a runtime. (Strategy)</p> <p>Una soluzione pu\u00f2 essere quella di avere una classe multimodale, che sulla base del \u201cenum\u201d assegnato svolge l\u2019azione in un determinato modo Anche questa soluzione non ci piace perch\u00e9 potremmo non prevedere tutti i comportamenti ed andremmo ad accrescere lo spazio degli stati. Inoltre cadremmo un\u2019altra volta nella GOD CLASS, Ah shit, here we go again, e anche nell\u2019antipatten SWITCH STATEMENT.</p> <p>Allora ci soccorre, per fortuna, il DECORATOR PATTERN che aggiungere dinamicamente funzionalit\u00e0 o comportamenti a un oggetto senza modificarne la struttura o creare tante sottoclassi.</p> <p></p> <p>Questo si basa sul COMPOSITE, tranne che per il fatte che il composite \u00e8 un decorator base. Ogni decoratore delegata l'esecuzione al componente interno e pu\u00f2 combinarsi con altri decoratori, rendendo semplice la composizione di funzionalit\u00e0.</p> <ul> <li>Le decorazioni devono essere indipendenti e additive, non devono rimuovere comportamenti per rispettare i principi della progettazione orientata agli oggetti.</li> <li>In Java, \u00e8 buona pratica rendere il riferimento all\u2019oggetto decorato final e inizializzarlo nel costruttore, poich\u00e9 si assume che non cambi durante la vita del decoratore.</li> <li>Un oggetto decorato non \u00e8 uguale al componente originale: ha una nuova identit\u00e0 dovuta alla decorazione.</li> </ul> <p>COPIA POLIMORFICA</p> <p>Un problema di lavorare con grafi di oggetti, oltre all\u2019identit\u00e0, \u00e8 la copia. Potremmo usare il costruttore della classe, ma questo \u00e8 statico e non va bene avendo una struttura che sfrutta il polimorfismo tramite le interfaccie, quindi non possiamo sapere che tipo abbiamo a runtime. E mo? La copia polimorfica risolve tutti nostri guai, perch\u00e9 permette di fare copie senza saper il tipo concreto dell\u2019oggetto. Questo concetto \u00e8 detto anche clonazione.Implementare il medo di copy() in strutture ricorsive \u00e8 complesso.</p> <p>Java d\u00e0 la possibilit\u00e0 di utilizzare il tipo di ritorno covariante cio\u00e8 permette a un metodo sovrascritto in una sottoclasse di restituire un tipo pi\u00f9 specifico rispetto a quello dichiarato nel metodo della superclasse o dell\u2019interfaccia. Si tratta di una funzionalit\u00e0 molto utile, perch\u00e9 consente di evitare il ricorso a downcast espliciti.</p> <p></p> <p>Questo meccanismo si rivela ancora pi\u00f9 importante nel contesto di strutture ricorsive, come ad esempio collezioni o oggetti che contengono al loro interno riferimenti ad altri oggetti dello stesso tipo. In questi casi, \u00e8 fondamentale che la copia effettuata sia profonda (deep copy), cio\u00e8 che non si limiti a copiare i riferimenti, ma replichi realmente anche le componenti interne.</p> <p>PROTOTYPE PATTERN</p> <p>COMMAND PATTERN</p> <p>In certe situazioni vogliamo svolgere delle azioni che possono essere svolte in modi diversi, o invocate in modo diverso. Potremmo usar l\u2019ereditariet\u00e0, ma per i classici motivi non ci va bene. Allora una soluzione, basata sul principio di separazione delle responsabilit\u00e0 \u00e8 di trasformare l\u2019azione, o meglio il metodo che in generale \u00e8 una propriet\u00e0 di una classe in un oggetto, in modo di applicargli delle propriet\u00e0 diverse. Per farlo esiste il COMMAND PATTERN che sfrutta sempre il polimorfismo tramite le interfacce, che in questo caso contengono il metodo per svolgere l\u2019azione.</p> <p>Il COMMAND separa l\u2019oggetto che invoca l\u2019operazione (Invoker) da quello che la esegue (Receiver), permettendo di trattare le richieste come oggetti riutilizzabili, componibili e serializzabili.</p> <p></p> <p>LAW OF DEMETER</p> <p>Nella progettazione di tutto ci\u00f2, possiamo andare a creare una lunga catena di delegazione fra gli oggetti. Questo ci va bene, ma fino ad un certo punto perch\u00e9 secondo la legge di Demeter si devono limitare le dipendenze tra le classi per rendere il codice pi\u00f9 modulare, facile da mantenere e meno fragile di fronte ai cambiamenti. Ci\u00f2 vuol direche un oggetto dovrebbe interagire solo con pochi amici stretti . Cadremmo nll\u2019antipattern del MESSAGE CHAIN che espone dettagli interni degli oggetti che dovrebbero invece rimanere nascosti, violando l\u2019information hiding.</p> <p></p> <p>Questa \"legge\" stabilisce che il codice di un metodo dovrebbe accedere solo a:</p> <ul> <li>le variabili di istanza del suo parametro implicito;</li> <li>gli argomenti passati al metodo;</li> <li>qualsiasi nuovo oggetto creato all'interno del metodo;</li> <li>oggetti disponibili globalmente.</li> </ul> <p>Per rispettare questa linea guida, diventa necessario fornire servizi aggiuntivi nelle classi che occupano una posizione intermedia in una catena di aggregazione/delega, in modo che i client non debbano manipolare gli oggetti interni incapsulati da questi oggetti.</p> <p>INVERSION OF DEPENDACY</p> <p>Il principio di inversione delle dipendenze afferma che i moduli di alto livello non dovrebbero dipendere da moduli di basso livello. Invece, entrambi dovrebbero dipendere dalle astrazioni, e le astrazioni non dovrebbero dipendere dai dettagli; I dettagli dovrebbero dipendere dalle astrazioni.</p> <p>Questo principio ha lo scopo di ridurre l\u2019accoppiamento tra moduli e aumentare la flessibilit\u00e0 del sistema, facilitando l\u2019estensione e la manutenzione.</p> <p>Un antipattern in cui si cade \u00e8 PAIRWISE DEPENDECIES cio\u00e8 si creano relazioni dirette fra due componenti o moduli in un sistema. Ogni dipendenza rappresenta un legame che pu\u00f2 introdurre accoppiamento e potenziali problemi di manutenzione.</p> <p>Quando molte dipendenze si accumulano fra moduli, si crea una rete complessa che rende il sistema rigido e difficile da modificare. Si decve cercare di ridurre il numero e la forza di queste dipendenze.</p> <p>Introducendo un livello di astrazione, invece di dipendere direttamente da una classe concreta (dipendenza forte), si dipende da un\u2019interfaccia, riducendo cos\u00ec il coupling. In questo modo:</p> <ul> <li>Le modifiche in una classe concreta hanno meno impatto sugli altri moduli.</li> <li>Il sistema diventa pi\u00f9 modulare, flessibile e testabile.</li> </ul> <p>Un pattern per risolvere questo \u00e8 il [[MVC]] MODEL-VIEW-CONTROLL un pattern architetturale che separa le responsabilit\u00e0 in tre componenti :</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-model-rappresenta-la-parte-che-gestisce-i-dati-la-logica-di-business-e-lo-stato-dellapplicazione-il-modello-non-si-preoccupa-di-come-i-dati-vengono-mostrati-allutente-ma-solo-di-gestirli-aggiornarli-e-fornirli","title":"1. Model: Rappresenta la parte che gestisce i dati, la logica di business e lo stato dell\u2019applicazione. Il modello non si preoccupa di come i dati vengono mostrati all\u2019utente, ma solo di gestirli, aggiornarli e fornirli.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-view-e-responsabile-della-presentazione-delle-informazioni-allutente-la-vista-prende-i-dati-dal-modello-e-li-mostra-in-modo-appropriato-ad-esempio-sotto-forma-di-pagine-web-finestre-grafiche-o-altro-non-contiene-logica-di-business-solo-logica-di-visualizzazione","title":"2. View: \u00c8 responsabile della presentazione delle informazioni all\u2019utente. La vista prende i dati dal modello e li mostra in modo appropriato, ad esempio sotto forma di pagine web, finestre grafiche, o altro. Non contiene logica di business, solo logica di visualizzazione.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#3-controller-fa-da-intermediario-tra-lutente-e-il-sistema-riceve-gli-input-dellutente-clic-comandi-dati-inseriti-li-interpreta-e-decide-come-modificare-il-modello-o-quale-vista-mostrare-in-pratica-coordina-il-flusso-dellapplicazione","title":"3. Controller: Fa da intermediario tra l\u2019utente e il sistema. Riceve gli input dell\u2019utente (clic, comandi, dati inseriti), li interpreta e decide come modificare il modello o quale vista mostrare. In pratica coordina il flusso dell\u2019applicazione.","text":"<p>Questo \u00e8 il concetto generale, ma ci sono molti modi di implementarlo, un esempio \u00e8</p> <p>OBSERVER PATTERN</p> <p>Il pattern OBSERVER consiste nell'archiviare i dati in un oggetto specializzato e consentire ad altri oggetti di osservarli. Questo oggetto, detto subject (MODEL), mantiene una lista di altri oggetti, detti observers, che vogliono essere informati quando qualcosa cambia nello stato del soggetto. Quindi deve avere i metodi per la registrazione e deregistrazione degli observer.</p> <p>Il soggetto notifica automaticamente tutti gli osservatori ogni volta che il suo stato cambia, senza che gli osservatori debbano controllare continuamente (polling).</p> <p></p> <p>DATA FLOW</p> <p>Come fanno gli osservatori a sapere che c'\u00e8 un cambiamento nello stato del modello di cui hanno bisogno? Sono spioni\u2026</p> <p>Ogni volta che si verifica un cambiamento nello stato del modello il modello lo comunica agli osservatori scorrendo l'elenco degli osservatori e chiamando il metodo notify(). Questo metodo \u00e8 una callback per il DIP perch\u00e9 per ottenere informazioni dal modello, gli osservatori non chiamano un metodo sul modello, ma aspettano che il modello li richiami. Poi ovviamente l\u2019observer ha bisogno di un metodo per poter aggiornare lo stato delle sue variabili.</p> <p>Per garantire che il modello notifichi gli osservatori ogni volta che si verifica un cambiamento di stato, e che ci sia consistenza fra i dati, sono possibili due strategie:</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-una-chiamata-al-metodo-di-notifica-deve-essere-inserita-in-ogni-metodo-che-modifica-lo-stato-in-questo-caso-il-metodo-puo-essere-dichiarato-privato","title":"1. una chiamata al metodo di notifica deve essere inserita in ogni metodo che modifica lo stato; in questo caso il metodo pu\u00f2 essere dichiarato privato;","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-e-necessario-fornire-una-documentazione-chiara-che-indichi-agli-utenti-della-classe-modello-di-chiamare-il-metodo-di-notifica-ogni-volta-che-il-modello-deve-informare-gli-osservatori-in-questo-caso-i-metodi-di-notifica-devono-essere-non-privati","title":"2. \u00c8 necessario fornire una documentazione chiara che indichi agli utenti della classe modello di chiamare il metodo di notifica ogni volta che il modello deve informare gli osservatori. In questo caso, i metodi di notifica devono essere non privati.","text":"<p>CONTROLL FLOW</p> <p>Come accedono gli osservatori alle informazioni che devono conoscere dal modello?</p> <p>Si possono rendere disponibili le informazioni di interesse tramite uno o pi\u00f9 parametri del callback. Questa strategia \u00e8 anche nota come strategia push data flow, poich\u00e9 il modello invia esplicitamente i dati di una struttura agli osservatori. Applicando questa strategia, potremmo definire il metodo di callback in modo che includa un parametro che rappresenti l\u2019informazione memorizzata pi\u00f9 di recente nel modello.</p> <p>Questa strategia parte dal presupposto che sappiamo in anticipo quale tipo di dati del modello richiederanno gli osservatori.</p> <p>Tuttavia, questo non \u00e8 il caso generale. Una strategia pi\u00f9 flessibile consiste nel consentire agli osservatori di estrarre i dati desiderati dal modello utilizzando i metodi di query definiti nel modello. Questo approccio \u00e8 noto come strategia pull data-flow. Per implementare la strategia di flusso di dati pull, gli osservatori devono avere un riferimento al modello, ma questo riferimento non deve essere necessariamente fornito come argomento al metodo di callback. Un'altra opzione \u00e8 inizializzare gli oggetti osservatori con un riferimento al modello (memorizzato come campo) e fare riferimento a tale campo se necessario.</p> <p>Pu\u00f2 sembrare che questa strategia introduca una dipendenza circolare tra un modello e i suoi osservatori, dato che entrambi dipendono l'uno dall'altro, ma non \u00e8 cos\u00ec perch\u00e9 il modello non conosce il tipo concreto dei suoi osservatori. Attraverso la segregazione delle interfacce, l'unica porzione di comportamento che il modello richiede dagli osservatori viene specificata tramite il loro metodo di callback. Anche se per\u00f2, aumenta l'accoppiamento tra osservatori e modello.</p> <p>ADAPTER PATTERN</p> <p>L'ADAPTER PATTER \u00e8 un modello di progettazione strutturale che consente la collaborazione di oggetti con interfacce incompatibili. Si tratta di un oggetto speciale che converte l'interfaccia di un oggetto in modo che un altro oggetto possa comprenderlo.</p> <p>Un adattatore esegue il wrapping di uno degli oggetti per nascondere la complessit\u00e0 della conversione che avviene dietro le quinte. L'oggetto avvolto non \u00e8 nemmeno a conoscenza dell'adattatore.</p> <p>Gli adattatori non solo possono convertire i dati in vari formati, ma possono anche aiutare gli oggetti con interfacce diverse a collaborare. Ecco come funziona:</p>"},{"location":"40_Design_Patterns/Software%20Design%20Note/#1-ladattatore-ottiene-uninterfaccia-compatibile-con-uno-degli-oggetti-esistenti","title":"1. L'adattatore ottiene un'interfaccia compatibile con uno degli oggetti esistenti.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#2-utilizzando-questa-interfaccia-loggetto-esistente-puo-chiamare-in-modo-sicuro-i-metodi-delladapter","title":"2. Utilizzando questa interfaccia, l'oggetto esistente pu\u00f2 chiamare in modo sicuro i metodi dell'adapter.","text":""},{"location":"40_Design_Patterns/Software%20Design%20Note/#3-alla-ricezione-di-una-chiamata-ladapter-passa-la-richiesta-al-secondo-oggetto-ma-nel-formato-e-nellordine-previsti-dal-secondo-oggetto","title":"3. Alla ricezione di una chiamata, l'adapter passa la richiesta al secondo oggetto, ma nel formato e nell'ordine previsti dal secondo oggetto.","text":"<p>A volte \u00e8 anche possibile creare un adattatore bidirezionale in grado di convertire le chiamate in entrambe le direzioni.</p> <p></p>"},{"location":"50_Project_Journal/2026_Learning_Log/","title":"2026 Learning Log","text":"<p>Stato: #seed</p>"},{"location":"50_Project_Journal/2026_Learning_Log/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"},{"location":"99_Meta/Templates/Technical_Note_Template/","title":"Technical Note Template","text":"<p>Stato: #seed</p>"},{"location":"99_Meta/Templates/Technical_Note_Template/#note","title":"Note","text":"<ul> <li>Inizia a scrivere qui...</li> </ul>"}]}