[
  {
    "sid": "/1-single-responsibility-principle-srp--ogni-classe-o-metodo-dovrebbe-avere-una-sola-responsabilità-o-motivo-di-cambiamento",
    "title": "1. Single Responsibility Principle (SRP) – Ogni classe o metodo dovrebbe avere una sola responsabilità o motivo di cambiamento.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-openclosed-principle-ocp--le-entità-software-dovrebbero-essere-aperte-allestensione-ma-chiuse-alla-modifica",
    "title": "2. Open/Closed Principle (OCP) – Le entità software dovrebbero essere aperte all’estensione ma chiuse alla modifica.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-liskov-substitution-principle-lsp--le-classi-derivate-devono-poter-sostituire-le-classi-base-senza-alterare-il-comportamento-previsto-questo-principio-è-fondamentale-per-garantire-che-luso-del-polimorfismo-sia-corretto-e-prevedibile",
    "title": "3. Liskov Substitution Principle (LSP) – Le classi derivate devono poter sostituire le classi base senza alterare il comportamento previsto. Questo principio è fondamentale per garantire che l’uso del polimorfismo sia corretto e prevedibile.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/4-interface-segregation-principle-isp--è-meglio-avere-interfacce-specifiche-e-limitate-piuttosto-che-una-singola-interfaccia-generica-e-pesante",
    "title": "4. Interface Segregation Principle (ISP) – È meglio avere interfacce specifiche e limitate piuttosto che una singola interfaccia generica e pesante.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/5-dependency-inversion-principle-dip--le-classi-dovrebbero-dipendere-da-astrazioni-non-da-classi-concrete-riducendo-laccoppiamento-tra-le-componenti-del-sistema",
    "title": "5. Dependency Inversion Principle (DIP) – Le classi dovrebbero dipendere da astrazioni, non da classi concrete riducendo l’accoppiamento tra le componenti del sistema.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-un-costruttore-privato-per-la-classe-flyweight-in-modo-che-i-client-non-possano-controllare-la-creazione-di-oggetti-della-classe",
    "title": "1. Un costruttore privato per la classe flyweight, in modo che i client non possano controllare la creazione di oggetti della classe;",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-un-archivio-statico-di-oggetti-flyweight-che-conserva-una-collezione-di-oggetti-flyweight",
    "title": "2. Un archivio statico di oggetti flyweight che conserva una collezione di oggetti flyweight;",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-un-metodo-di-accesso-statico-che-restituisce-loggetto-flyweight-univoco-corrispondente-a-una-chiave-di-identificazione-il-metodo-di-accesso-in-genere-verifica-se-loggetto-flyweight-richiesto-esiste-già-nellarchivio-lo-crea-se-non-esiste-già-e-restituisce-loggetto-univoco",
    "title": "3. Un metodo di accesso statico che restituisce l'oggetto flyweight univoco corrispondente a una chiave di identificazione. Il metodo di accesso in genere verifica se l'oggetto flyweight richiesto esiste già nell'archivio, lo crea se non esiste già e restituisce l'oggetto univoco.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-un-costruttore-privato-per-la-classe-singleton-in-modo-che-i-client-non-possano-creare-più-oggetti",
    "title": "1. Un costruttore privato per la classe singleton, in modo che i client non possano creare più oggetti;",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-una-variabile-globale-per-contenere-un-riferimento-alla-singola-istanza-delloggetto-singleton",
    "title": "2. Una variabile globale per contenere un riferimento alla singola istanza dell'oggetto singleton.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-un-metodo-di-accesso-solitamente-chiamato-instance-che-restituisce-il-singleton-in-istanza-il-metodo-di-accesso-è-facoltativo-poiché-è-anche-possibile-implementare-il-pattern-dichiarando-listanza-globale-come-costante-pubblica",
    "title": "3. Un metodo di accesso, solitamente chiamato instance(), che restituisce il singleton in istanza. Il metodo di accesso è facoltativo, poiché è anche possibile implementare il pattern dichiarando l'istanza globale come costante pubblica.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-avere-un-metodo-nel-composite-che-prenvede-laggiunto-del-figlio-eventualmente-anche-la-modifica-il-getchild-e-la-rimozione-ma-s-deve-includere-il-metodo-add-nel-componente-no-allora",
    "title": "1. Avere un metodo nel composite che prenvede l’aggiunto del figlio (eventualmente anche la modifica, il getChild e la rimozione), ma s deve includere il metodo add nel componente?. No allora",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-li-si-inserisce-nel-composite-tramite-il-costruttore-lista-",
    "title": "2. Li si inserisce nel composite tramite il costruttore (lista …).",
    "level": 1,
    "children": [
      {
        "sid": "/a-usiamo-il-costruttore-di-copia-per-evitare-la-perdita-di-un-riferimento-alla-struttura-della-collezione-privata",
        "title": "a. Usiamo il costruttore di copia per evitare la perdita di un riferimento alla struttura della collezione privata.",
        "level": 2,
        "parent": "/2-li-si-inserisce-nel-composite-tramite-il-costruttore-lista-",
        "children": []
      },
      {
        "sid": "/b-o-utilizzare-il-meccanismo-varargs-di-java-per-elencare-singolarmente-ogni-sorgente-di-carta",
        "title": "b. O utilizzare il meccanismo varargs di Java per elencare singolarmente ogni sorgente di carta.",
        "level": 2,
        "parent": "/2-li-si-inserisce-nel-composite-tramite-il-costruttore-lista-",
        "children": []
      }
    ]
  },
  {
    "sid": "/1-model-rappresenta-la-parte-che-gestisce-i-dati-la-logica-di-business-e-lo-stato-dellapplicazione-il-modello-non-si-preoccupa-di-come-i-dati-vengono-mostrati-allutente-ma-solo-di-gestirli-aggiornarli-e-fornirli",
    "title": "1. Model: Rappresenta la parte che gestisce i dati, la logica di business e lo stato dell’applicazione. Il modello non si preoccupa di come i dati vengono mostrati all’utente, ma solo di gestirli, aggiornarli e fornirli.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-view-è-responsabile-della-presentazione-delle-informazioni-allutente-la-vista-prende-i-dati-dal-modello-e-li-mostra-in-modo-appropriato-ad-esempio-sotto-forma-di-pagine-web-finestre-grafiche-o-altro-non-contiene-logica-di-business-solo-logica-di-visualizzazione",
    "title": "2. View: È responsabile della presentazione delle informazioni all’utente. La vista prende i dati dal modello e li mostra in modo appropriato, ad esempio sotto forma di pagine web, finestre grafiche, o altro. Non contiene logica di business, solo logica di visualizzazione.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-controller-fa-da-intermediario-tra-lutente-e-il-sistema-riceve-gli-input-dellutente-clic-comandi-dati-inseriti-li-interpreta-e-decide-come-modificare-il-modello-o-quale-vista-mostrare-in-pratica-coordina-il-flusso-dellapplicazione",
    "title": "3. Controller: Fa da intermediario tra l’utente e il sistema. Riceve gli input dell’utente (clic, comandi, dati inseriti), li interpreta e decide come modificare il modello o quale vista mostrare. In pratica coordina il flusso dell’applicazione.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-una-chiamata-al-metodo-di-notifica-deve-essere-inserita-in-ogni-metodo-che-modifica-lo-stato-in-questo-caso-il-metodo-può-essere-dichiarato-privato",
    "title": "1. una chiamata al metodo di notifica deve essere inserita in ogni metodo che modifica lo stato; in questo caso il metodo può essere dichiarato privato;",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-è-necessario-fornire-una-documentazione-chiara-che-indichi-agli-utenti-della-classe-modello-di-chiamare-il-metodo-di-notifica-ogni-volta-che-il-modello-deve-informare-gli-osservatori-in-questo-caso-i-metodi-di-notifica-devono-essere-non-privati",
    "title": "2. È necessario fornire una documentazione chiara che indichi agli utenti della classe modello di chiamare il metodo di notifica ogni volta che il modello deve informare gli osservatori. In questo caso, i metodi di notifica devono essere non privati.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-ladattatore-ottiene-uninterfaccia-compatibile-con-uno-degli-oggetti-esistenti",
    "title": "1. L'adattatore ottiene un'interfaccia compatibile con uno degli oggetti esistenti.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-utilizzando-questa-interfaccia-loggetto-esistente-può-chiamare-in-modo-sicuro-i-metodi-delladapter",
    "title": "2. Utilizzando questa interfaccia, l'oggetto esistente può chiamare in modo sicuro i metodi dell'adapter.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-alla-ricezione-di-una-chiamata-ladapter-passa-la-richiesta-al-secondo-oggetto-ma-nel-formato-e-nellordine-previsti-dal-secondo-oggetto",
    "title": "3. Alla ricezione di una chiamata, l'adapter passa la richiesta al secondo oggetto, ma nel formato e nell'ordine previsti dal secondo oggetto.",
    "level": 1,
    "children": []
  }
]