
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../../../20_Languages/Python/Python_MOC/">
      
      
        <link rel="next" href="../Android_MOC/">
      
      
        
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>Android - Computer Engineering KB</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#computazione-pervasiva" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Computer Engineering KB" class="md-header__button md-logo" aria-label="Computer Engineering KB" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Computer Engineering KB
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Android
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="Share" aria-label="Share" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
  
    
  
  üß† Engineering Knowledge Base

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../00_Inbox/" class="md-tabs__link">
          
  
  
  00 Inbox

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../10_Theory/Algorithms/Complexity_Basics/" class="md-tabs__link">
          
  
  
  10 Theory

        </a>
      </li>
    
  

    
  

      
        
  
  
  
  
    
    
      
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../20_Languages/Java/Java_MOC/" class="md-tabs__link">
          
  
  
  20 Languages

        </a>
      </li>
    
  

    
  

      
        
  
  
  
    
  
  
    
    
      
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="./" class="md-tabs__link">
          
  
  
  30 Frameworks Tools

        </a>
      </li>
    
  

    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../40_Design_Patterns/Architecture_Overview/" class="md-tabs__link">
          
  
  
  40 Design Patterns

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../50_Project_Journal/2026_Learning_Log/" class="md-tabs__link">
          
  
  
  50 Project Journal

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../99_Meta/Templates/Technical_Note_Template/" class="md-tabs__link">
          
  
  
  99 Meta

        </a>
      </li>
    
  

    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Computer Engineering KB" class="md-nav__button md-logo" aria-label="Computer Engineering KB" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Computer Engineering KB
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    üß† Engineering Knowledge Base
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    00 Inbox
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    00 Inbox
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../00_Inbox/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    README
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    10 Theory
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    10 Theory
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Algorithms
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Algorithms
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../10_Theory/Algorithms/Complexity_Basics/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Complexity Basics
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Data Structures
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Data Structures
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../10_Theory/Data_Structures/Trees_and_Graphs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Trees and Graphs
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    20 Languages
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    20 Languages
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1" >
        
          
          <label class="md-nav__link" for="__nav_4_1" id="__nav_4_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Java
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Java
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../20_Languages/Java/Java_MOC/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    üó∫Ô∏è Java (MOC)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2" >
        
          
          <label class="md-nav__link" for="__nav_4_2" id="__nav_4_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Python
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Python
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../20_Languages/Python/Python_MOC/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Python MOC
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" checked>
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    
  
    30 Frameworks Tools
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            
  
    30 Frameworks Tools
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_1" checked>
        
          
          <label class="md-nav__link" for="__nav_5_1" id="__nav_5_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Android
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_5_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Android
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    Android
  

    
  </span>
  
  

      </a>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Android_MOC/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Android MOC
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2" >
        
          
          <label class="md-nav__link" for="__nav_5_2" id="__nav_5_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Spring
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Spring
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Spring/Spring_MOC/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    üó∫Ô∏è Spring (MOC)
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    40 Design Patterns
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            
  
    40 Design Patterns
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../40_Design_Patterns/Architecture_Overview/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Architecture Overview
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../40_Design_Patterns/SOLID_Principles/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    SOLID Principles
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../40_Design_Patterns/Software%20Design%20Note/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Software Design Note
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    50 Project Journal
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            
  
    50 Project Journal
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../50_Project_Journal/2026_Learning_Log/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2026 Learning Log
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    99 Meta
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            
  
    99 Meta
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_1" >
        
          
          <label class="md-nav__link" for="__nav_8_1" id="__nav_8_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Templates
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Templates
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../99_Meta/Templates/Technical_Note_Template/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Technical Note Template
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<p><img alt="A flat, minimalist Android logo centered on a solid blue background. It shows a green, semi-circular robot head with two short antennas and two circular eyes above the lowercase word &quot;android&quot; in black. The design is simple, geometric, and centered in the image." src="./Android_images/image_001.png" /></p>
<h1 id="computazione-pervasiva"><strong>COMPUTAZIONE PERVASIVA</strong></h1>
<p>Con lo sviluppo delle nuove tecnologie che ha portato alla nascita dei dispositivi di compilazione portabili √® nata una nuova forma di computazione, quella <strong>pervasiva</strong>.</p>
<p>Essendo i dispositivo mobili e non pi√π fissi si √® dovuto cercare un nuovo modo di far comunicare i vari dispositivi per via delle connessioni precarie e in continuo cambiamento. Si cerca di progettare anche un software che sia in grado di utilizzare meno risorse possibili e che abbiano una potenza di calcolo minore per evitare di esaurire le risorse del dispositivo punto di tutto questo si occupa l'anno mobile computing. Questi dispositivi pervasivi sono sistemi distribuiti e quindi questi problemi dei sistemi distribuiti e mobile fanno parte del pervasive computing a cui si aggiungono altri problemi come la scalabilit√† invisibilit√† la comunicazione remota ecc.</p>
<p>Non tutti gli obiettivi del pervasive computer sono stati realizzati infatti creare uno <strong>smartplace</strong>, uno spazio in cui ci sono dispositivi di calcoli in modo da calcolare il mondo fisico e cyber fisico √® ancora difficile da realizzare, ma non perch√© non possediamo le tecnologie adeguate ma perch√© dobbiamo migliorare i collegamenti.</p>
<p>√à necessario rendere questi dispositivi <strong>invisibili</strong>, l'uomo non si deve accorgere che ci sono in modo che il mondo fisico e il cyber fisico si fondono in un solo spazio. Un altro problema √® dovuto al numero sempre crescendo i dispositivi che si connettono tra loro quindi si cerca di realizzare la <strong>scalabilit√† localizzata</strong> cio√® di mantenere le stesse qualit√† di servizi ma man mano che aumentano i nuovi dispositivi.</p>
<p>S√¨ cerca di mascherare le <strong>condizioni di non uniformit√†</strong> dovute diversi dispositivi presenti che possono impedire di collaborare fra loro cercando di creare un sistema per nascondere alle domande e questi problemi.</p>
<p>La computazione pervasiva ha modificato anche il modo in cui ci interfacciamo col software perch√© prima era necessario l'intervento umano per far svolgere qualcosa la macchina mentre oggi il computer √® in grado di comunicare con tende anche in maniera asincrona.</p>
<p>Questo √® stato reso possibile grazie al fatto che prendono informazioni nel mondo reale tramite i sensori sono in grado di elaborarli e notificare all'uomo qualcosa.</p>
<p>Oggi sia una architettura ed Edge cloudcentrica in cui tutti i dispositivi sono connessi tra loro tramite il cloud in cui le risorse informatiche sono regate attraverso la rete internet ospitate e gestite da server remoti.</p>
<p>Si provvede di avere un architettura ed internet centrica con cui internet il centro delle connessioni fra i dispositivi e i server. In questo modo l'elaborazione avviene in modo distribuita ai margini della rete contrariamente a come accade in quelle precedenti in cui le elaborazione avviene in economia i server.</p>
<p>Nell'architettura di calcolo distribuita ci sono tre segmenti che rappresentano muri diversi di elaborare e archiviare dati a seconda delle distanze dal punto di generazione</p>
<p><strong>üìç Edge Computing</strong> Alla base di tutto troviamo l‚Äô<strong>Edge</strong>, ovvero il bordo della rete. I dati vengono elaborati <strong>il pi√π vicino possibile alla fonte che li genera</strong>, spesso direttamente all‚Äôinterno del dispositivo stesso. I dati vengono elaborati in tempo reale, senza dover prima inviare i dati a un server esterno.</p>
<p>Questo approccio √® ideale per situazioni in cui la velocit√† √® fondamentale, come nelle auto a guida autonoma o nei dispositivi medici. Riduce la latenza, cio√® il tempo che passa tra l‚Äôinput e la risposta, e limita il traffico di rete.</p>
<p><strong>üå´Ô∏è Fog Computing</strong> Salendo di un livello, troviamo il <strong>Fog Computing</strong>, un modello pensato per distribuire l‚Äôelaborazione pi√π vicino alla rete, ma non necessariamente sul dispositivo.</p>
<p>Nel fog computing, i dati vengono inviati a <strong>nodi</strong> local, un router o un server che li elaborano e, solo se necessario, li inoltrano al cloud. Questo modello √® utile quando bisogna elaborare rapidamente grandi quantit√† di dati provenienti da pi√π dispositivi, ma non si ha la necessit√† di farlo in tempo reale estremo.</p>
<p><strong>‚òÅÔ∏è Cloud Computing</strong> Infine, abbiamo il <strong>Cloud</strong>, che rappresenta l‚Äôapproccio centralizzato. I dati vengono inviati a server remoti, spesso situati in data center geograficamente lontani. Qui possono essere elaborati con grande potenza computazionale, salvati per lungo tempo o usati per addestrare algoritmi complessi di intelligenza artificiale.</p>
<p>Il cloud √® perfetto per elaborazioni intensive. Tuttavia, presenta limiti in termini di latenza e dipendenza dalla connessione internet.</p>
<p>Edge, Fog e Cloud non si escludono a vicenda: <strong>collaborano</strong>. In un sistema moderno ed efficiente, i dati vengono prima processati localmente (edge), poi aggregati e raffinati in una rete vicina (fog), e infine archiviati o ulteriormente analizzati nel cloud.</p>
<div class="page-break"></div>
<div class="page-break"></div>
<h1 id="hci"><strong>HCI</strong></h1>
<p>La <strong>Human computer interaction HCI</strong> Eh lo studio dell‚Äôinterazione uomo computer per la progettazione di sistemi informatici che siano usabili e affidabili. Il loro scopo √® quello di semplificare l‚Äôattivit√† umane e non di ostacolarle. Se hai il computer che le persone offrono diversi modi di interagire fra loro e l‚Äôinterazione pu√≤ essere</p>
<ul>
<li>diretta cio√® tramite l‚Äôuso del dispositivo e di risposte da parte del calcolatore ;</li>
<li>indiretta tramite sensori se analizzano il mondo esterno e danno dei feedback per svolgere azioni</li>
</ul>
<p>La HCI √® una materia multidisciplinare che coinvolge</p>
<p><img alt="An infographic showing &quot;HCI&quot; (Human‚ÄìComputer Interaction) in a large central circle surrounded by overlapping colored circles, each naming a related discipline: - Computer science - Ergonomics &amp; human factors - Engineering - Design - Sociology &amp; social psychology - Ethnography - Cognitive science - Psychology - Information security - Speech‚Äëlanguage pathology" src="./Android_images/image_002.png" /></p>
<p>Il principio base della disciplina √®</p>
<p><strong>usabilit√†</strong> cio√® la facilit√† con il quale l'utente pu√≤ interagire con la macchina per raggiungere obiettivi con efficacia, efficienza e soddisfazione per un certo contesto</p>
<p>‚â†</p>
<p><strong>accessibilit√†</strong> che indica se un sistema informatico pu√≤ essere usato da tutti compreso chi ha disabilit√†</p>
<p><strong>Interazione umana</strong></p>
<p>L'uomo √® colui che usa i calcolatori e devono essere progettati per assisterlo. Qui entrano in gioco le scienze cognitive che devono capire le capacit√† e le limitazioni per progettare in modo corretto un sistema informatico</p>
<p>Interazione processo con il quale l'utente fornisce la macchina in un input e la macchina lo processa restituendo un output o viceversa</p>
<p>Per la macchina si sono molte forme di IO, ma per l'essere umano sono principalmente i cinque sensi e pi√π in particolare la vista l'udito e il tatto. Interagiamo con la macchina principalmente con il tatto, le dita fungono da cursore. Solo recentemente siamo in grado di interagire anche con la voce per fornire un input.</p>
<p><img alt="- Photo of an older person with short white hair (face blurred). - Wearing a light blue patterned sweater over a white collared shirt. - Seated against a warm yellow background, with one hand up near the face. - A dark object (likely a laptop or book) is visible in the lower right." src="./Android_images/image_003.png" />
<strong>Vista</strong> La vista √® il principale mezzo con il quale otteniamo informazioni. La percezione visiva si pu√≤ dividere in due fasi</p>
<ol>
<li>ricezione fisica dello stimolo</li>
<li>elaborazione e un'interpretazione dello stimolo</li>
</ol>
<p>Dobbiamo capire come funziona l'occhio e come la mente interpreta gli stimoli per progettare sistemi informatici. La prima cosa da capire √® cosa l'utente vede punto la vista umana tende ad avere una visione centrale dove l‚Äôutente di attento e nota le cose; √® una visione centrale che trascura le cose che sono fuori da quella centrale.</p>
<p>Capire questo ci permette di realizzare un design utile all‚Äôutente</p>
<p>ü°™ le info importanti devono essere al centro del campo</p>
<p>ü°™ le info meno importanti devono essere pi√π all'esterno</p>
<p>Importante √® capire anche come percepiamo i colori, dimensioni, e profondit√† per una buona progettazione delle interfaccia visive.
Bisogna definire il contesto in cui gli oggetti si trovano perch√© diamo sulla base di esso o un'interpretazione diversa dovuta al fatto che possiamo gi√† conoscere il contesto e le info relative da conoscenze passate.
Definiamo correttamente il contesto permette all'utente di capire subito di cosa si tratta ed evita le illusioni ottiche che lo portano in disabilit√† quindi bisogna definire correttamente le dimensioni degli oggetti dove posizionarli e cos√¨ via per poter sviluppare una buona interfaccia utente.</p>
<p><strong>Udito</strong> Un altro canale di output per l'uomo pu√≤ essere il canale uditivo grazie al quale siamo in grado di riconoscere i suoni in quanto il nostro sistema filtro i suoni che ascoltiamo per concentrarci sulle informazioni importanti il suono √® spesso usato nelle interfacce grafiche ad esempio per dare informazioni sullo stato di qualcosa, focalizzare l'attenzione ecc.. quindi per notificare/rafforzare l'idea dell'utente.</p>
<p><strong>Tatto</strong> Il tatto ci d√† informazioni sull'ambiente circostante e specialmente nei sistemi informatici √® la fonte di input ma anche di output. In questo modo siamo in grado di interagire con gli aggettivi fuori dagli smartphone in modo da svolgere determinati compiti. Anche i movimenti importanti perch√© comporta un elaborazione di informazioni in seguito a uno stimolo ricevuto toccando qualcosa. Ogni movimento richiede tempo che dipende dalle persone dall'et√† eccetera eccetera. In movimento si valuta con accuratezza cio√® la precisione del movimento che dipende anche dalla velocit√† con il quale si reagisce. Quanto si progetta un‚Äôinterfaccia e bisogna considerare queste caratteristiche del movimento per progettare i bottoni che siano facilmente raggiungibili e premibili. (Pubblicit√† ingannevole)</p>
<p>Il tempo impiegato per colpire un bersaglio √® una funzione della dimensione del bersaglio della distanza da percorrere</p>
<p><strong>Legge di Fitts</strong></p>
<p><strong>Dispositivi</strong> Il progettista dell'interfaccia deve essere a conoscenza delle propriet√† del dispositivo e di tutti i fattori che influenzano il comportamento dell'interfaccia perch√© influenzano la natura dell‚Äôinterazione.</p>
<p>Donald Norman da una definizione di interazione HC stabilimento che si tratta di un ciclo che si compone di due fasi</p>
<ol>
<li>Esecuzione</li>
<li>Valutazione
|
V</li>
</ol>
<p>L'utente stabilisce l'obiettivo, formula l'intenzione c'√® l'obiettivo che deve realizzare, esegue le azioni sul dispositivo e percepisce lo stato del sistema e lo interpreta per capire il posto suggestivo per raggiungere l'obiettivo</p>
<p>√à importante che l'utente capisca cosa fare per completare le loro azioni e le interfacce non devono essere di un tralcio anzi devono semplificare il raggiungimento dell'obiettivo.</p>
<p><strong>DESIGN SBAGLIATO</strong> ü°™<strong>lapsus</strong> cio√® quando comprendiamo il sistema ma si fanno</p>
<p>| errori di distrazione
V</p>
<p><strong>errori</strong> quando si sbaglia perch√© non si √® capito il sistema e quindi cosa deve fare per raggiungere l‚Äôobiettivo</p>
<p><strong>Ergonomia</strong> L‚Äôergonomia √® lo studio delle caratteristiche fisiche dell‚Äôinterazione quindi come progettare i controlli layout dei dispositivi ecc.</p>
<p>L'obiettivo √® di migliorare come l‚Äôutente usi dispositivi per dare migliori prestazioni sull'uso di questi punto questo si riflette anche sul design, su come posizionare gli elementi sulla base dell'utilit√† del contesto ecc.</p>
<p>Quando progettiamo l'interfaccia dobbiamo tenere conto anche di come gli utenti usano i dispositivi infatti secondo studi la maggior parte delle persone usano il dispositivo con una mano sola e usano il pollice per toccare lo schermo, oppure con la seconda mano lo fissiamo oppure usano entrambe le mani quindi in base a come viene utilizzato progettiamo il design mettendo gli elementi importanti nelle parti dello schermo pi√π facilmente raggiungibili in base alle modalit√† di uso mentre gli elementi meno utili o di uso frequente nelle parti pi√π esterne un design corretto porta ad avere una pessima esperienza d'uso per l'utente finale</p>
<h1 id="android-e-struttura-app"><strong>ANDROID E STRUTTURA APP</strong></h1>
<p>Android √® un sistema operativo sviluppato da Google basato su Linux e progettato per dispositivi mobile √® un sistema operativo open source . Quindi il suo codice sorgente √® pubblico e pu√≤ essere modificato da sviluppatori e produttori di hardware per creare la propria versione di Android e adattarlo a loro dispositivo, Il problema di questo √® che ci√≤ porta a una frammentazione eccessiva delle versioni e questo causa problemi quando dobbiamo sviluppare delle applicazioni, perch√© dobbiamo individuare il numero di dispositivi compatibili con la versione che dovremo sviluppare.
 Android cerca di risolvere il problema di compatibilit√† creando degli appositi librerie che si possono utilizzare con andiamo a sviluppare il codice</p>
<p>Google gestisce il rilascio delle nuove versioni di Android sia per i propri dispositivi, la cui distribuzione avviene in maniera abbastanza rapida sia per gli altri dispositivi di altri produttori. Il sistema operativo di questi seguire. Deve seguire un <strong>processo di qualifica</strong> da parte di Google. Questo vuol dire che ogni qualvolta che Google rilascia un aggiornamento ogni produttore deve adattarlo al proprio hardware del dispositivo e questo richiede molto tempo perch√© modificano anche l‚Äôinterfaccia. Una volta che hanno effettuato queste modifiche la versione deve essere approvata da Google per garantire che soddisfi standard di qualit√† compatibilit√† e sicurezza se si superano questi test al loro i produttori potranno rilasciare il loro aggiornamento per i loro dispositivi.</p>
<h2 id="architettura"><strong>ARCHITETTURA</strong></h2>
<p>Il sistema Android √® interamente sviluppato sopra al kernel Linux. Il motivo di questa scelta √® dovuto al fatto che non sarebbero mai stati in grado di sviluppare un sistema completamente funzionante in tempi rapidi per poter entrare nel mercato. Linux era gi√† un sistema operativo pienamente funzionante sotto ogni aspetto e che funzionava in modo molto efficiente e quindi l‚Äôidea di Google fu quello di estendere il sistema operativo Linux per adattarlo ai dispositivi mobile.</p>
<h3 id="linux-kernel"><strong>Linux Kernel</strong></h3>
<p>Questo livello fornisce i servizi di gestione dell'hardware. A questo livello, viene applicato uno schema di protezione per limitare l'accesso ai dati e alle risorse e consentirlo solo ai processi che posseggono l'adeguato livello di autorizzazione. Vi sono i moduli per la gestione della memoria, dei processi, del sistema di archiviazione e della comunicazione sulla rete. Vi sono i driver per la gestione dell'hardware in dotazione al dispositivo, ad esempio la memoria ausiliaria, la radio, la fotocamera. Oltre ai servizi offerti dal nucleo del sistema operativo, il kernel di Android include alcuni componenti particolari, quali ad esempio il sistema di risparmio energetico, il sistema di gestione e condivisione della memoria, un meccanismo di comunicazione tra processi chiamato <strong>binder</strong>, che permette ai processi di condividere dati e servizi.</p>
<p><img alt="A colorful layered diagram of the Android software stack, top-to-bottom: - Top row: System Apps (Dialer, Email, Calendar, Camera, ...). - Java API Framework (green): Content Providers, View System, and Managers (Activity, Location, Package, Notification, Resource, Telephony, Window). - Native C/C++ Libraries (purple): WebKit, OpenMAX AL, Libc, Media Framework, OpenGL ES, etc. - Android Runtime (yellow): Android Runtime (ART) and Core Libraries. - Hardware Abstraction Layer (teal): HAL modules (Audio, Bluetooth, Camera, Sensors, ...). - Linux Kernel (orange/red): Drivers (Audio, Binder (IPC), Display, Keypad, Bluetooth, Camera, Shared Memory, USB, WIFI) and Power Management. Each layer is shown as a horizontal band of boxes indicating responsibilities and components." src="./Android_images/image_004.png" /></p>
<h3 id="hardware-abstraction-level"><strong>Hardware Abstraction Level</strong></h3>
<p>Sopra al kernel troviamo HAL che fornisce interfacce standard per esporre le funzionalit√† hardware del dispositivo al framework API di livello superiore. HAL √® formato da pi√π moduli, ognuno dei quali implementa un‚Äôinterfaccia per un tipo di componente hardware Linux . quando il framework fa una chiamata per accedere all‚Äôhardware del dispositivo Android carica il modulo di libreria di quella componente. I moduli sono scritti dal produttore.</p>
<h3 id="android-runtime"><strong>Android RunTime</strong></h3>
<p>L‚ÄôAndroid Runtime √® composto dalla macchina virtuale <strong>ART</strong> (che ha sostituito Dalvik) e dalle librerie principali del sistema. ART √® un ambiente di esecuzione in cui ogni app viene eseguita nel proprio processo, con una propria istanza di ART.</p>
<p>ART traduce il codice scritto in Java o Kotlin in bytecode, che viene poi convertito in codice nativo comprensibile dal processore del dispositivo. Utilizza principalmente un approccio di compilazione <strong>Ahead-of-Time (AOT)</strong>: quando si installa una nuova app, questa viene compilata in codice nativo gi√† durante la fase di installazione, migliorando cos√¨ le performance in fase di esecuzione.</p>
<p>Inoltre, ART pu√≤ usare la modalit√† <strong>Just-In-Time (JIT)</strong> per compilare dinamicamente solo alcune parti del codice durante l‚Äôesecuzione dell‚Äôapp, migliorando la reattivit√† e riducendo i tempi di compilazione iniziale.</p>
<h3 id="native-cc-library-ndk"><strong>Native C/C++ Library NDK</strong></h3>
<p>Sempre sopra ad HAL troviamo le NDK strumenti per sviluppare app in C/C++. Sono utili per implementare funzionalit√† che richiedono altre performance o se dobbiamo implementare parte di codice che devono comunicare direttamente con l‚Äôhardware.</p>
<h3 id="java-api-framework"><strong>Java API Framework</strong></h3>
<p>Sopra ai livelli di Android Runtime e HAL troviamo il <strong>Java API Framework</strong>, un insieme di librerie, classi e interfacce scritte in Java/Kotlin che permettono di interagire facilmente con le funzionalit√† hardware e software del dispositivo.</p>
<p>Questo livello √® progettato per semplificare lo sviluppo delle app, fornendo un accesso ad alto livello alle componenti del sistema operativo Android</p>
<p>Le API mettono a disposizione implementazioni predefinite delle componenti fondamentali del sistema, che possono essere estese e personalizzate dagli sviluppatori per costruire le funzionalit√† specifiche dell'app.</p>
<h3 id="applicazioni"><strong>Applicazioni</strong></h3>
<p>Sopra questo livello troviamo le applicazioni dell‚Äôutente.</p>
<h2 id="android-sdk"><strong>Android SDK</strong></h2>
<p>L‚Äô<strong>android software development kit ASDK</strong> √® un set di librerie e strumenti per sviluppare un app android. I tool si dividono in;</p>
<ul>
<li>SDK platform, tools platform dependent. Una nuova versione di queste √® rilasciata ad ogni versione di android e include librerie, codici sorgenti ecc</li>
<li>SDK tools che sono platform indipendent. Sono strumenti usati per sviluppare , farete bugno a disposizione un emulatore per simulate un dispositivo mobile. Ha un android Debug Brigde che permette di comunicare con il dispositivo per eseguire operazioni varie per fare testing e debug.</li>
</ul>
<h2 id="compilazione-app-android"><strong>COMPILAZIONE APP ANDROID</strong></h2>
<p>Per quanto riguarda la compilazione di un app android prima di generare il bytecode, le risorse usate nel processo vengono analizzate indicizzate e compilate in bytecode, ottimizzato per la piattaforma punto la componente. La componente che si occupa di fare questo √® <strong>AAPT2</strong> che opera il modo <strong>incrementale</strong> cio√® compila le risorse e linka tutti i file intermedi generati dalla compilazione. Produce la classe <strong>R.java</strong> che contiene tutte le risorse compilate a cui sono associate un ID con il quale si pu√≤ far riferimento alla risorsa.</p>
<p>Viene generato il bytecode del codice Java/Kotlin.</p>
<p>La componente <strong>AIDL</strong> definisce l‚Äôinterfaccia di programmazione concordata dal client e server per comunicare fra loro usando IPC. Il motivo di ci√≤ √® che ogni app, anche se viene eseguita sullo stesso dispositivo, e un processo separato e quindi pu√≤ accedere solo alle zone di memoria che le sono state riservate.</p>
<p>Android usa un meccanismo nativo chiamato <strong>Binder</strong> per gestire la comunicazione tra processi. √à una tecnologia di basso livello, integrata nel kernel di Linux, che permette a un processo di:</p>
<ul>
<li>Fare richieste a un altro processo</li>
<li>Ricevere risposte come se fossero normali chiamate di funzione</li>
</ul>
<p>Con tutte queste parti si viene a creare il .class cio√® il file bytecode Java che per√≤ non pu√≤ essere ancora utilizzato ma deve essere ottimizzato dalla componente <strong>DEX/ART</strong> creando un file .dex eseguibile su ART VM.</p>
<p>Una volta pronti i file .dex e le risorse, lo strumento <strong>apkbuilder</strong> li unisce per creare il file .apk, cio√® il pacchetto installabile dell‚Äôapp Android. Dentro questo .apk troviamo:</p>
<ul>
<li>I file .dex</li>
<li>Le risorse compilate (.arsc)</li>
<li>I file non compilati (come asset, immagini, XML di layout)</li>
<li>Il file AndroidManifest.xml</li>
</ul>
<p>Prima che un'app venga installata su un dispositivo, <strong>deve essere firmata digitalmente</strong>. Questo garantisce due cose fondamentali:</p>
<ul>
<li>Autenticit√†: conferma che l‚Äôapp √® stata creata da chi dice di averla creata.</li>
<li>Integrit√†: assicura che il file non sia stato modificato dopo la firma.</li>
</ul>
<p><strong>a) Firma con jarsigner</strong></p>
<p>La firma avviene usando uno <strong>keystore</strong>, ovvero un contenitore sicuro di chiavi crittografiche. Con jarsigner, il pacchetto .apk viene firmato utilizzando una <strong>chiave privata</strong>.</p>
<ul>
<li>Si calcola un hash del contenuto dell‚Äôapp.</li>
<li>Questo hash viene poi cifrato con la chiave privata ‚Üí questo √® ci√≤ che chiamiamo firma digitale.</li>
<li>La firma viene allegata all‚Äôapp.</li>
</ul>
<p><strong>b) Allineamento con zipalign</strong></p>
<p>Dopo la firma, si utilizza lo strumento zipalign per <strong>ottimizzare l‚Äôaccesso alle risorse</strong> del pacchetto. Questo √® un passo importante, soprattutto per app in produzione, perch√© migliora le prestazioni e riduce il consumo di memoria.</p>
<p>Quando un dispositivo Android riceve un‚Äôapp firmata, esegue la <strong>verifica della firma</strong>:</p>
<ul>
<li>Estrae l‚Äôhash dal file firmato.</li>
<li>Ricalcola l‚Äôhash con il contenuto dell‚Äôapp.</li>
<li>Usa la chiave pubblica per verificare che la firma corrisponda all‚Äôhash originale.</li>
</ul>
<p>Se i due hash corrispondono, l‚Äôapp √® autentica e non √® stata manomessa ‚Üí viene installata. Se <strong>non combaciano</strong>, il sistema rifiuta l‚Äôinstallazione.</p>
<ul>
<li>Durante lo sviluppo, Android Studio firma automaticamente l‚Äôapp con una chiave debug.</li>
<li>Per pubblicare l‚Äôapp sul Play Store, devi firmarla con una chiave di release generata da te. √à fondamentale non perdere questa chiave, perch√© ti servir√† per aggiornare l‚Äôapp in futuro.</li>
</ul>
<p><img alt="The image is a multipart diagram showing the Android build, packaging and signing process plus how digital signing/verification works. - Top row (overview): Android Project ‚Üí Compilation &amp; Packaging ‚Üí Android Package (.apk) (contains .dex files, resources, uncompiled resources, AndroidManifest.xml) ‚Üí Signing ‚Üí Device or Emulator (ADB). - Left panel (detailed build flow): - Inputs: application resources, .aidl files, Java/R.java and other Java source. - Java compiler ‚Üí .class files; aidl generates Java interfaces. - .class files + 3rd-party libs ‚Üí dx (or DEX tool) ‚Üí .dex files. - aapt / apkbuilder combine compiled resources and .dex into Android package (.apk). - jarsigner signs the APK ‚Üí zipalign (release mode) ‚Üí signed &amp; aligned .apk. - Right panel (signing &amp; verification): - Signing: data file ‚Üí hash function produces digest ‚Üí private key creates digital signature ‚Üí digitally signed data file. - Verification: receiver hashes data file, uses public key to recover signature hash, compares hashes to verify integrity and authenticity." src="./Android_images/image_005.png" /></p>
<h2 id="avvio-di-un-applicazione-android"><strong>AVVIO DI UN APPLICAZIONE ANDROID</strong></h2>
<p>Il processo di avvio di un'applicazione Android inizia quando l'utente o un altro componente di sistema richiede l'esecuzione di un componente dell‚Äôapp. Se l'applicazione non √® gi√† in esecuzione, il sistema Android avvia un nuovo processo per essa.</p>
<p>Ogni app Android viene eseguita nel proprio processo Android, che √® un processo Linux con un thread di esecuzione iniziale.</p>
<p>Il processo di avvio del sistema include l'avvio dell'<strong>init process</strong>, che a sua volta genera processi Linux di basso livello chiamati <strong>daemon</strong>. L'init process avvia un processo chiamato <strong>Zygote</strong> che inizializza la prima istanza della Dalvik Virtual Machine e precarica tutte le classi comuni utilizzate dal framework Android e dalle varie app installate.
In questo modo, si prepara a essere replicato e inizia ad ascoltare su un'interfaccia socket per richieste future di generare nuove macchine virtuali per i processi delle nuove applicazioni. Quando riceve una nuova richiesta, Zygote effettua un fork di se stesso per creare un nuovo processo che ottiene un'istanza VM pre-inizializzata. Dopo Zygote, l'init avvia il <strong>runtime process,</strong> e Zygote esegue un fork per avviare un processo ben gestito chiamato <strong>system server</strong>. Il system server avvia tutti i servizi principali della piattaforma, come l'Activity Manager Service e i servizi hardware, nel proprio contesto.</p>
<p><img alt="- A cartoon-style illustration. - On the right, a person in a yellow tank top raises both arms upward as if shooting or tossing something. - In the upper-left, a smiling baby in a diaper is airborne. - Plain dark background." src="./Android_images/image_006.png" /></p>
<p>A questo punto, lo stack completo √® pronto per avviare il primo processo dell'app: l'app Home, nota anche come <strong>Launcher</strong>.</p>
<p>Quando un utente fa clic sull'icona di un'app nel Launcher, l'evento di clic viene tradotto in <em>startActivity(intent)</em> e viene indirizzato all'<strong>ActivityManagerService</strong> tramite Binder IPC. L'ActivityManagerService esegue diverse operazioni:</p>
<ol>
<li>Raccoglie informazioni sul target dell'oggetto intent utilizzando il metodo resolveIntent() sull'oggetto PackageManager, con i flag PackageManager.MATCH_DEFAULT_ONLY e PackageManager.GET_SHARED_LIBRARY_FILES utilizzati per impostazione predefinita.</li>
<li>Salva le informazioni sul target nell'oggetto intent per evitare di ripetere questo passaggio.</li>
<li>Verifica se l'utente ha privilegi sufficienti per richiamare il componente target dell'intent chiamando il metodo grantUriPermissionLocked().</li>
<li>Se l'utente ha le autorizzazioni necessarie, l'ActivityManagerService verifica se l'attivit√† target richiede di essere avviata in un nuovo task, in base ai flag dell'Intent come FLAG_ACTIVITY_NEW_TASK e FLAG_ACTIVITY_CLEAR_TOP.</li>
<li>Verifica se esiste gi√† un ProcessRecord per il processo. Se il ProcessRecord √® null, l'ActivityManager deve creare un nuovo processo per istanziare il componente target.</li>
</ol>
<p>L‚ÄôASM crea un nuovo processo invocando il metodo startProcessLocked(), che invia argomenti al processo Zygote tramite la connessione socket. Zygote esegue un fork di se stesso e chiama ZygoteInit.main(), che a sua volta istanzia un oggetto ActivityThread e restituisce l'ID del processo appena creato. Ogni processo ottiene un thread per impostazione predefinita. Il thread principale ha un'istanza <strong>Looper</strong> per gestire i messaggi da una coda di messaggi e chiama Looper.loop() in ogni iterazione del suo metodo run(). Il Looper estrae i messaggi dalla coda e richiama i metodi corrispondenti per gestirli. ActivityThread avvia quindi il message loop chiamando Looper.prepareLoop() e successivamente Looper.loop().</p>
<p>Il passo successivo consiste nell'associare questo processo appena creato a un'applicazione specifica. Ci√≤ avviene chiamando bindApplication() sull'oggetto thread. Questo metodo invia un messaggio BIND_APPLICATION alla coda dei messaggi. Questo messaggio viene recuperato dall'oggetto <strong>Handler</strong>, che quindi invoca il metodo handleMessage() per attivare l'azione specifica del messaggio: handleBindApplication(). Questo metodo invoca makeApplication(), che carica le classi specifiche dell'app in memoria.</p>
<p><img alt="This is a high-level flow diagram of an Android application launch sequence. Key components and steps shown: - Click event -&gt; Launcher (UI) - Launcher issues a binder IPC call: startActivity(intent) to Activity Manager Service (AMS) - AMS performs intent resolution, permission checks, new-task/launch tests - AMS may request process start (Process.start / pid) from Zygote - Zygote forks a new Linux process - AMS sends 1 BIND_APPLICATION to the new process so the app runtime (Activity Thread / Dalvik VM) loads the App class into RAM - AMS sends 2 LAUNCH_ACTIVITY to create the UI component (New Activity) - Activity lifecycle callbacks: 2.1 onCreate(), 2.2 onStart() (shown) - The Activity Thread runs inside the Dalvik VM and uses a Looper (Looper.loop()) to handle the main event loop The diagram labels the IPC actions, lifecycle calls, and shows the ordering of process creation, binding, class loading, and activity launch." src="./Android_images/image_009.png" /></p>
<p>Dopo il binding, il sistema contiene il processo responsabile dell'applicazione con le classi dell'applicazione caricate nella memoria privata del processo. Il processo effettivo di avvio inizia nel metodo realStartActivity(), che chiama scheduleLaunchActivity() sull'oggetto thread dell'applicazione. Questo metodo invia un messaggio LAUNCH_ACTIVITY alla coda dei messaggi. Il messaggio viene gestito dal metodo handleLaunchActivity(). L'<strong>Activity</strong> inizia il suo ciclo di vita .</p>
<p><img alt="A block diagram of the Android boot and app-launch sequence, showing components and control flow: - Bootloader ‚Üí CPU ‚Üí Kernel - Bootloader: initialize RAM, put hardware in quiescent state, load kernel and ramdisk, jump to kernel. - Kernel: init environment for C code, init subsystems and drivers, mount root FS, start the &quot;init&quot; process. - init process - Sets up environment variables, mounts filesystems, sets permissions and OOM adjustments, starts native daemons. - Native daemons (examples listed) - servicemanager, vold, netd, debugged, rild, mediaserver, bootanimation, bluetoothd, installd, keystore, adbd, and app_process -Xzygote (Zygote). - Zygote and Android runtime - Zygote: registers zygote socket, preloads Java classes and resources, starts SystemServer, opens socket and listens for connections. - Android Runtime: starts a Dalvik/ART VM and calls Zygote main. - SystemServer and services - SystemServer: initializes core services, registers with Service Manager, starts ActivityManager (and other services). - App launch flow (interaction with UI) - Launcher: initializes, registers click/onClick handlers (user Click). - Click ‚Üí Launcher calls startActivity() ‚Üí ActivityManager handles intent (e.g., CATEGORY_HOME for launcher). - ActivityManager may request Zygote to create an app process (startViaZygote / fork()). - Zygote forks to produce new app process(es) (New app instances). Red arrows in the diagram highlight the dynamic calls: startViaZygote(), startActivity(), and fork() that produce new application processes." src="./Android_images/image_008.png" /></p>
<h2 id="activity"><strong>ACTIVITY</strong></h2>
<p>Un'<strong>Activity</strong> √® una componente visibile di un'applicazione Android che permette agli utenti di interagire con essa. Un'app pu√≤ essere composta da pi√π Activity, ciascuna delle quali svolge un compito specifico ed √® indipendente dalle altre. Ogni Activity √® formata da una serie di View, ovvero gli elementi dell'interfaccia utente</p>
<h3 id="ciclo-di-vita"><strong>CICLO DI VITA</strong></h3>
<p>Il sistema operativo Android gestisce il ciclo di vita di un'Activity, determinando quando questa viene creata, avviata, arrestata o distrutta. La classe Activity fornisce diversi metodi di callback che permettono agli sviluppatori di definire il comportamento dell'applicazione nei vari stati dell'Activity.</p>
<p><img alt="A flowchart of the Android Activity lifecycle showing states and callbacks: - Top: &quot;Activity launched&quot; - Sequence: onCreate() ‚Üí onStart() ‚Üí onResume() ‚Üí Activity running (green) - When another activity comes to foreground: onPause() ‚Üí onStop() (activity no longer visible) - If the activity finishes or is destroyed: onDestroy() ‚Üí Activity shut down (orange) - Return/navigation paths: - From onPause() user returns ‚Üí onResume() - From onStop() user navigates back ‚Üí onRestart() ‚Üí onStart() ‚Üí onResume() - If system reclaims memory while stopped: app process killed (orange) - Small annotations explain each callback (e.g., onPause: another activity comes into foreground; onStop: activity is no longer visible; onDestroy: finishing or being destroyed by system)." src="./Android_images/image_010.png" /></p>
<p>L‚Äôactivity pu√≤ essere avviata dall‚Äôutente che preme sull‚Äôicona dell‚Äôapplicazione, oppure da un‚Äôaltra activity tramite un intent.</p>
<p>Quando un'app viene avviata Zygote <strong>clona</strong> se stesso per creare un nuovo processo, riducendo il tempo di avvio. Questo nuovo processo eredita le classi e le librerie gi√† caricate, ottimizzando l'esecuzione.</p>
<p>L'<strong>ActivityManagerService (AMS)</strong> √® il componente principale che gestisce il ciclo di vita delle <strong>Activity</strong> e coordina le transizioni tra di esse.</p>
<ul>
<li>Riceve la richiesta di avvio dell'app.</li>
<li>Controlla se il processo dell‚Äôapp √® gi√† in esecuzione o se deve essere creato.</li>
<li>Comunica con il Zygote per avviare un nuovo processo se necessario.</li>
</ul>
<p>Dopo l‚Äôavvio dell‚Äôapp, vengono chiamate tre metodi per creare un activity.</p>
<ol>
<li>onCreate() in questo momento l‚Äôactivity viene effetivamente creata e in questa fase si inizializzano tutte le risorse necessarie. Viene carocato in memoria l‚Äôalbero delle views che formano l‚Äôactivity. 
    La onCreate() di un'Activity non deve essere bloccante perch√© viene eseguita nel Main Thread, lo UI Thread. Questo thread √® responsabile della gestione dell‚Äôinterfaccia utente e dell‚Äôinterazione con l‚Äôutente. Se il codice in onCreate() √® troppo pesante Android termina forzatamente le app che bloccano il Main Thread.</li>
<li>Subito dopo, Android chiama il metodo onStart() che permette all‚ÄôActivity di essere visibile all‚Äôutente, ma non √® ancora interattiva. L‚Äôinterfaccia viene renderizzata visualizzando le componenti che formano l‚Äôactivity.</li>
<li>Con l‚Äôinvocazione di onResume() l‚ÄôActivity diventa pienamente attiva e interattiva e l‚Äôutente pu√≤ effetti interagire con le componenti dell‚Äôappliczione. Gli event generati vengono catturati dal looper e fa cambiare stato all‚Äôactivity. Durante questa fase, l‚ÄôActivity √® in primo piano e qualsiasi altra Activity aperta in precedenza √® stata messa in pausa o nascosta.</li>
</ol>
<p>Dopo queste tre operazioni l‚Äôapplicazione si trova nello stato di running e l‚Äôutente pu√≤ interagire. Se l'utente non interagisce l‚Äôactivity passa in uno stato di <strong>onPause()</strong>, che indica che l‚Äôactivity non √® pi√π in primo piano, ma questo non vuol dire che debba essere distrutta.</p>
<p>Quando la tua attivit√† non √® pi√π visibile all'utente, ma √® ancora in memoria viene invocata la chiamata <strong>onStop()</strong> e da qui inizia il ciclo di distruzione e rilascio delle risorse dell‚Äôactivity.</p>
<p>La differenza tra <strong>onStop()</strong> e <strong>onPause()</strong> √® che nella <strong>onPause()</strong> il lavoro relativo all'interfaccia utente continua anche se l'utente sta visualizzando la tua attivit√† in modalit√† multi-finestra.</p>
<p>Con la <strong>onRestart()</strong> tato transitorio si verifica solo se un'Activity fermata viene riavviata. onRestart() viene chiamato tra onStop() e onStart().
<strong>onDestroy()</strong> viene chiamato prima che l'Activity venga distrutta. Questo pu√≤ avvenire perch√© l'Activity sta terminando, perch√© il sistema sta distruggendo l'Activity per risparmiare risorse, o a causa di un cambiamento di configurazione. √à importante eseguire qui la pulizia finale delle risorse. Tuttavia, non si dovrebbe fare affidamento su onDestroy() per salvare dati importanti, in quanto potrebbe non essere sempre chiamato.</p>
<h3 id="back-stack-e-navigazione-fra-le-activity"><strong>BACK STACK E NAVIGAZIONE FRA LE ACTIVITY</strong></h3>
<p>In Android, le Activity sono gestite attraverso uno stack di Activity, il <strong>back stack</strong>, gestito in modo FIFO.</p>
<p>Il back stack √® un insieme di Activity che l'utente ha visitato e a cui pu√≤ tornare premendo il pulsante Indietro del dispositivo. Una <strong>task</strong> √® un insieme di Activity correlate all'applicazione o ad una specifica interazione dell'utente e ha il suo back stack e che possiamo gestire insieme.</p>
<p>Quando si avvia una nuova Activity, essa viene <strong>inserita in cima</strong> al back stack e prende il focus dell'utente. L'Activity precedente viene fermata ma rimane disponibile nel back stack, conservando il suo stato attuale. Quando l'utente preme il pulsante Indietro, l'Activity in cima allo stack viene <strong>rimossa</strong> (e distrutta), e l'Activity precedente riprende.</p>
<p>Alla base dello stack sta il launcher e da questo si iniziano ad impilare le activity. Android non rimuover√† mai le activity tranne se si trova in situazioni critiche del sistema e allora rimuove prima le activity che si trovano in fondo allo stack, evitando di rimuove l‚Äôactivity attiva.</p>
<p>Il back stack <strong>non √® specifico di una singola applicazione</strong>; pu√≤ contenere Activity di diverse applicazioni lanciate dall'utente in ordine cronologico inverso. Ci√≤ significa che premendo il pulsante Indietro, l'utente potrebbe ritrovarsi in un'Activity di un'altra app se l'ha avviata precedentemente.</p>
<p><img alt="A diagram of an Android task/back-stack flow showing three steps: - Left: a single foreground activity (Activity 1) with Activity 1 on the back stack. - Middle-left: user starts Activity 2 ‚Äî Activity 2 is pushed on top, Activity 1 remains below in the stack. - Middle-right: user starts Activity 3 ‚Äî Activity 3 is now on top, with Activity 2 and Activity 1 beneath (stack top ‚Üí bottom: Activity 3, Activity 2, Activity 1). - Right: user navigates back from Activity 3 ‚Äî Activity 3 is destroyed and removed, returning to Activity 2 in the foreground with Activity 1 still below." src="./Android_images/image_011.png" />
Un‚Äôactivity pu√≤ spostarsi¬†in<strong>background</strong>¬†quando un utente avvia una nuova attivit√† o passa alla schermata Home. In background, tutte le attivit√† dell'attivit√† vengono arrestate, ma lo stack precedente dell'attivit√† rimane intatto, perde l'attenzione mentre √® in corso un'altra attivit√†. R l'attivit√† pu√≤ tornare in primo piano per consentire agli utenti di riprendere da dove hanno interrotto disattivata.</p>
<p>Le activity nel back-stack non vengono mai riorganizzate, ma √® possibili modificare questo andamento lineare dello stack perch√© in certe situazioni questa gestione non va bene. Esistono cinque modalit√† di lancio che si possono assegnare all'attributo¬†launchMode:</p>
<ol>
<li>StandardLa modalit√† predefinita. Il sistema crea una nuova istanza dell'attivit√† nell'attivit√† da cui √® stato avviato e instrada l'intent a quest'ultimo. L'attivit√† pu√≤ essere creata pi√π volte, ogni istanza pu√≤ appartenere ad attivit√† diverse un'attivit√† pu√≤ avere pi√π istanze.</li>
<li>SingleTopSe nella parte superiore dell'attivit√† corrente esiste gi√† un'istanza dell'attivit√†, il sistema instrada l'intent a quell'istanza tramite una chiamata alla sua¬†onNewIntent()¬†anzich√© creare una nuova istanza dell'attivit√†. L'attivit√† √® creata pi√π volte, ogni istanza pu√≤ appartenere ad attivit√† diverse e un'attivit√† pu√≤ avere pi√π istanze (ma solo se l'attivit√† in alto dello stack posteriore¬†non¬†√® un'istanza esistente dell'attivit√†).</li>
<li>singleTaskIl sistema crea l'attivit√† alla base di una nuova attivit√† o individua la su un'attivit√† esistente con la stessa affinit√†. Se un'istanza del componente esiste gi√† un'attivit√†, il sistema instrada all'istanza esistente tramite una chiamata alla sua onNewIntent() anzich√© creare una nuova istanza. Nel frattempo, tutti gli altri vengono distrutte.</li>
<li>singleInstanceIl comportamento √® lo stesso di¬†"singleTask", ad eccezione del fatto che il sistema non avvia nessun altro delle attivit√† nell'attivit√† che contiene l'istanza. L'attivit√† √® sempre l'unico e unico membro della sua attivit√†. Tutte le attivit√† iniziate da questa si aprono tra per un'attivit√† a parte.</li>
<li>singleInstancePerTaskL'attivit√† pu√≤ essere eseguita solo come attivit√† principale dell'attivit√†, la prima all'attivit√† che ha creato l'attivit√†, perci√≤ pu√≤ esserci una sola istanza di questa attivit√† in un'attivit√†. A differenza della modalit√† di avvio di¬†singleTask, questa l'attivit√† pu√≤ essere avviata in pi√π istanze in diverse attivit√† se¬†FLAG_ACTIVITY_MULTIPLE_TASK¬†o¬†FLAG_ACTIVITY_NEW_DOCUMENT¬†√® stato impostato.</li>
</ol>
<p><strong>SingleTask</strong> e <strong>SingleInstancePerTask</strong>¬†rimuovono tutte le attivit√† superiori all'attivit√† iniziale dell'attivit√†.</p>
<p>I <strong>cambiamenti di configurazione</strong>, come la rotazione dello schermo, comportano la distruzione dell'Activity corrente e la creazione di una nuova Activity per adattarsi alla nuova configurazione. Per evitare la perdita di dati durante questi cambiamenti, √® possibile <strong>salvare lo stato dell'istanza dell'Activity.</strong>
1. sovrascrivendo il metodo onSaveInstanceState(Bundle). Lo stato viene salvato come una serie di coppie chiave/valore in un oggetto Bundle che viene passato a onCreate() quando l'Activity viene ricreata. √à anche possibile utilizzare il callback onRestoreInstanceState() per ripristinare lo stato.
2. Oppure con il model-view-controller</p>
<h2 id="fragment"><strong>FRAGMENT</strong></h2>
<p>Un <strong>Fragment</strong> √® un componente utilizzato per dividere l'interfaccia utente in parti pi√π piccole. Un Fragment rappresenta una porzione di UI o di comportamento che vive all‚Äôinterno di un‚ÄôActivity, e pu√≤ essere riutilizzato o sostituito dinamicamente. Un Fragment riceve i propri eventi di input e ha una propria vista che viene composta da un file di layout apposito. I Fragment possono esistere solo all'interno di un'Activity. Un'attivit√† pu√≤ <strong>delegare</strong> a un fragment l'esecuzione di compiti.</p>
<p>Le Activity fungono da <strong>host</strong> per i Fragment queste devono conoscere i dettagli di come ospitare i loro Fragment, ma i Fragment non devono conoscere i dettagli delle Activity che le ospitano (<strong>loosely couple</strong>). Come le attivit√†, i fragment sono "attivi" quando appartengono ad una activity focalizzata e in primo piano.</p>
<p>Quando un'attivit√† viene messa in pausa o interrotta, anche i frammenti che contiene vengono messi in pausa e arrestati e anche i frammenti contenuti in un'attivit√† inattiva sono inattivi.</p>
<p>Quando un'attivit√† viene finalmente distrutta, ogni Fragment che contiene viene ugualmente distrutto. Poich√© il gestore della memoria Android chiude regolarmente le applicazioni per liberare risorse, anche i frammenti all'interno di tali attivit√† vengono distrutti.</p>
<p>Non dovrebbe esserci alcuna differenza nel passaggio di un frammento da uno stato scollegato, in pausa, interrotto o inattivo allo stato attivo, quindi √® importante salvare tutto lo stato dell'interfaccia utente e conservare tutti i dati</p>
<p>quando un frammento viene sospeso o interrotto. Come un'activity, quando un frammento diventa di nuovo attivo, dovrebbe ripristinare lo stato salvato.</p>
<p><img alt="The diagram shows two activity stacks (tasks): - Left (solid box, labeled &quot;Foreground activity&quot;): Task B contains two stacked activities ‚Äî Activity Z (top, highlighted as the current/foreground) above Activity Y. - Right (dashed box, labeled &quot;Background&quot;): Task A contains Activity Y above Activity X, shown as a background task. Dashed outlines indicate the background task; the highlighted/top activity (Activity Z) is the active foreground." src="./Android_images/image_012.png" /></p>
<p><strong>AUF, Always Use Fragments</strong></p>
<p><strong><img alt="A blocky, pixelated Minecraft wolf/dog: gray and white voxel-style body with a square muzzle, rectangular ears, a red collar, and cube-like legs and tail, shown in a mid-run pose." src="./Android_images/image_013.png" />
</strong>I Fragment hanno anche un proprio <strong>ciclo di vita</strong> che √® simile a quello di un'attivit√†. Questo √® importante perch√©, visto che un fragment lavora per conto di un'attivit√†, il suo stato dovrebbe riflettere lo stato dell'attivit√†. Pertanto, ha bisogno di metodi del ciclo di vita corrispondenti per gestire il lavoro dell'attivit√†.</p>
<p>I callback del ciclo di vita di un Fragment includono</p>
<ul>
<li>onCreateView(): il valore restituito di questo metodo deve essere un'istanza di View affinch√© il Fragment abbia un'interfaccia utente visibile</li>
<li>onDestroyView(): Ci sono anche callback per onActivityCreated e callback che vengono attivati quando un Fragment viene aggiunto (onAttached) a o rimosso (onDetached) dall'UI utilizzando i metodi di FragmentTransaction.</li>
<li>I metodi onAttach(Activity), onCreate(Bundle) e onCreateView(...) vengono chiamati quando si aggiunge il fragment al FragmentManager.</li>
<li>Il metodo onActivityCreated(...) viene chiamato dopo che il metodo onCreate(...) dell'attivit√† ospitante √® stato eseguito.</li>
<li>Il FragmentManager di un'attivit√† √® responsabile della chiamata dei metodi del ciclo di vita dei fragment nella sua lista.</li>
</ul>
<p>La vista di un fragment viene generalmente inflata nel metodo onCreateView().</p>
<p>Per aggiungere un fragment a un'attivit√† nel codice, si effettuano chiamate esplicite al <strong>FragmentManager</strong> dell'attivit√† che √® responsabile della gestione dei fragment e dell'aggiunta delle loro viste alla gerarchia delle viste dell'attivit√†.</p>
<p>Il FragmentManager gestisce due cose:</p>
<ul>
<li>un elenco di fragment</li>
<li>stack di back delle transazioni di fragment.</li>
</ul>
<p>Per ottenere il FragmentManager, si usa</p>
<ul>
<li>getSupportFragmentManager(), se si estende AppCompatActivity o FragmentActivity;</li>
<li>getFragmentManager(), se si estende Activity e il fragment estende android.app.Fragment o PreferenceFragment).</li>
</ul>
<p>Le <strong>FragmentTransaction</strong> vengono utilizzate per aggiungere, rimuovere, allegare, staccare o sostituire i fragment nell'elenco dei fragment in fase di runtime. Il FragmentManager mantiene uno stack di back delle transazioni di fragment su cui √® possibile navigare.</p>
<p>Il metodo FragmentManager.beginTransaction() crea e restituisce un'istanza di <strong>FragmentTransaction</strong>. La classe FragmentTransaction utilizza una <strong>fluent interface</strong>: i metodi che configurano FragmentTransaction restituiscono un FragmentTransaction invece di void, il che consente di concatenarli.</p>
<ul>
<li>Il metodo add() della FragmentTransaction ha due parametri: un ID del container view e il newFragment. L'ID del container view √® l'ID risorsa del FrameLayout definito nel layout dell'attivit√†. Un ID del container view ha indica al FragmentManager dove nella vista dell'attivit√† dovrebbe apparire la vista del fragment e viene utilizzato come identificatore univoco per un fragment nell'elenco del FragmentManager.</li>
</ul>
<p>Quando √® necessario recuperare il Fragment dal FragmentManager, lo si richiede tramite l'ID del container view utilizzando fm.findFragmentById(R.id.fragment_container).</p>
<p>√à prassi comune aggiungere un <strong>metodo statico newInstance()</strong> alla classe Fragment. Questo metodo crea l'istanza del fragment, raggruppa e imposta i suoi argomenti.</p>
<h3 id="stato-di-un-fragment"><strong>Stato di un Fragment</strong></h3>
<p>Ogni istanza di fragment pu√≤ avere un oggetto Bundle allegato. Questo bundle contiene coppie chiave-valore,</p>
<p>Per creare gli argomenti di un fragment, si crea prima un oggetto Bundle. Quindi, si utilizzano i metodi "put" specifici del tipo di Bundle (simili a quelli di Intent) per aggiungere argomenti al bundle.</p>
<p>Per allegare il bundle degli argomenti a un fragment, si chiama Fragment.setArguments(Bundle). L'allegamento degli argomenti a un fragment deve essere fatto dopo che il fragment √® stato creato ma prima che venga aggiunto a un'attivit√†.</p>
<p>Quando un fragment deve accedere ai suoi argomenti, chiama il metodo getArguments() del Fragment e quindi uno dei metodi "get" specifici del tipo di Bundle.</p>
<h3 id="comunicazione-tra-activity-e-fragment"><strong>Comunicazione tra Activity e Fragment</strong></h3>
<p>Per delegare funzionalit√† all'attivit√† ospitante, un fragment definisce in genere un'<strong>interfaccia di callback</strong> denominata Callbacks. Questa interfaccia definisce il lavoro che il fragment deve far svolgere all'attivit√† ospitante. Qualsiasi attivit√† che ospiter√† il fragment deve implementare questa interfaccia.</p>
<p>Con un'interfaccia di callback, un fragment √® in grado di chiamare metodi sulla sua attivit√† ospitante senza dover sapere nulla di quale attivit√† lo stia ospitando.</p>
<p>L'attivit√† viene assegnata nel metodo del ciclo di vita del Fragment: onAttach(Activity activity). Questo metodo viene chiamato quando un fragment viene collegato a un'attivit√†, sia che sia stato conservato o meno.</p>
<p>Allo stesso modo, la variabile viene impostata su null nel corrispondente metodo del ciclo di vita in diminuzione: onDetach(). La variabile viene impostata su null qui perch√© in seguito non √® possibile accedere all'attivit√† o contare sulla sua continua esistenza.</p>
<h3 id="conservazione-dei-fragment"><strong>Conservazione dei Fragment</strong></h3>
<p>Per impostazione predefinita, la propriet√† retainInstance di un fragment √® false. Ci√≤ significa che non viene conservato e viene distrutto e ricreato alla rotazione insieme all'attivit√† che lo ospita. La chiamata a setRetainInstance(true) conserva il fragment. Quando un fragment viene conservato, il fragment non viene distrutto con l'attivit√†. Invece, viene preservato e passato intatto alla nuova attivit√†.</p>
<p>Quando si conserva un fragment, si pu√≤ contare sul fatto che tutte le sue variabili d'istanza mantengano gli stessi valori.</p>
<p>Un fragment conservato non viene distrutto, ma viene <strong>staccato dall'attivit√† morente</strong>. Questo mette il fragment in uno <strong>stato di conservazione</strong>. Il fragment esiste ancora, ma non √® ospitato da alcuna attivit√†. Lo stato di conservazione viene raggiunto solo quando si verificano due condizioni:
 1. setRetainInstance(true) √® stato chiamato sul fragment
 2. l'attivit√† ospitante viene distrutta per un cambio di configurazione</p>
<p>Ricever√† l'evento <strong>onDetach</strong> quando l'attivit√† padre viene distrutta, seguito dagli eventi <strong>onAttach</strong>, <strong>onCreateView</strong> e <strong>onActivityCreated</strong> quando  viene creata un'istanza della nuova attivit√† padre.</p>
<h2 id="service"><strong>SERVICE</strong></h2>
<p>Un <strong>service</strong> in Android √® un componente applicativo che esegue operazioni a lunga esecuzione, solitamente in background, senza fornire un'interfaccia utente (UI).
Un'applicazione pu√≤ avviare un service anche se non √® in primo piano e un service pu√≤ continuare a essere eseguito anche dopo che l'attivit√† che lo ha avviato √® stata distrutta.</p>
<p>Un service pu√≤ essere <strong>avviato</strong>, <strong>collegato</strong> (bound), o <strong>entrambi</strong>.</p>
<ul>
<li>Un service avviato √® quello che un componente applicativo (come un'activity) avvia chiamando startService(). I service avviati vengono utilizzati per eseguire task in background che possono durare a lungo o per eseguire lavoro per processi remoti. Una volta avviato, un service pu√≤ continuare a funzionare indefinitamente, anche se il componente che lo ha avviato viene distrutto. Solitamente, un service avviato esegue una singola operazione e non restituisce un risultato al chiamante. Quando l'operazione √® completata, il service dovrebbe fermarsi da solo chiamando stopSelf(), oppure un altro componente pu√≤ fermarlo chiamando stopService().</li>
<li>Un service collegato (bound) √® un service a cui un componente applicativo si connette chiamando bindService(). I service collegati forniscono un'interfaccia client-server che permette ai componenti di interagire con il service, inviare richieste e ottenere risultati, a volte utilizzando la comunicazione interprocesso (IPC). Un service collegato √® in esecuzione solo finch√© un altro componente applicativo √® collegato ad esso. Pi√π componenti possono collegarsi allo stesso service contemporaneamente, ma quando tutti si disconnettono, il service viene distrutto. Un service collegato generalmente non consente ai componenti di avviarlo chiamando startService().</li>
</ul>
<h3 id="ciclo-di-vita-di-un-service"><strong>CICLO DI VITA DI UN SERVICE</strong></h3>
<p>Il ciclo di vita di un service √® pi√π semplice di quello di un'activity. Tuttavia, √® fondamentale prestare attenzione a come un service viene creato e distrutto, poich√© un service senza UI pu√≤ continuare a funzionare in background senza che l'utente ne sia a conoscenza, consumando risorse e batteria.</p>
<p>Come un'activity, un service ha dei <strong>metodi di callback del ciclo di vita</strong> che √® possibile implementare per monitorare i cambiamenti nello stato del service ed eseguire operazioni nei momenti appropriati.</p>
<p><strong><img alt="A simple vertical flowchart of four rounded rectangular boxes connected by downward arrows, showing the sequence of Android Fragment lifecycle callbacks (top to bottom): - onAttach() - onCreate() - onCreateView() - onActivityCreated() Each box has a light gradient background and bold text; arrows point from each callback to the next." src="./Android_images/image_015.png" />onCreate()</strong>: Questo metodo viene chiamato quando il service viene creato per la prima volta. Viene chiamato una sola volta per la durata del service. Qui √® dove si dovrebbero eseguire le inizializzazioni di base, come la creazione di thread o la registrazione di listener.</p>
<p><strong>onStartCommand(Intent intent, int flags, int startId)</strong>: Questo metodo viene chiamato ogni volta che un componente avvia il service chiamando startService(). Riceve l'Intent fornito dal client (il componente che ha chiamato startService()) e due interi: flags, che forniscono informazioni aggiuntive sulla richiesta di avvio, e startId, un identificatore univoco per questa particolare richiesta di avvio. √à in questo metodo che il service esegue il lavoro richiesto dall'Intent. Il valore restituito da onStartCommand() indica al sistema come dovrebbe comportarsi se il service viene interrotto inaspettatamente.</p>
<p><strong>onBind(Intent intent)</strong>: Questo metodo viene chiamato quando un client desidera collegarsi al service chiamando bindService(). Restituisce un oggetto IBinder che il client utilizza per comunicare con il service. I service che intendono essere collegati devono implementare questo metodo; tuttavia, un service pu√≤ essere sia avviato che collegato (in tal caso implementer√† sia onStartCommand() che onBind()). Un service collegato generalmente non implementa onStartCommand().</p>
<ul>
<li>onUnbind(Intent intent): Questo metodo viene chiamato quando tutti i client collegati al service si sono disconnessi (hanno chiamato unbindService()). Il valore booleano restituito indica se onRebind() debba essere chiamato quando un nuovo client si collega al service.</li>
<li>onRebind(Intent intent): Questo metodo viene chiamato quando un nuovo client si collega al service dopo che onUnbind() √® gi√† stato chiamato. Viene chiamato se onUnbind() ha restituito true.</li>
<li>onDestroy(): Questo metodo viene chiamato quando il service non √® pi√π in uso e sta per essere distrutto. Questo pu√≤ avvenire quando il service si ferma da solo chiamando stopSelf() o quando un altro componente chiama stopService(), oppure quando tutti i client collegati si disconnettono (per i service collegati). √à qui che si dovrebbero rilasciare tutte le risorse utilizzate dal service (come thread, listener, ecc.).</li>
</ul>
<p>√à importante notare che i service avviati continuano la loro esecuzione indipendentemente dal componente che li ha avviati e devono essere fermati esplicitamente. I service collegati, invece, esistono solo per servire il componente applicativo che √® collegato ad essi e vengono distrutti quando non ci sono pi√π componenti collegati.</p>
<p>Come le activity e altri componenti, <strong>tutti i service devono essere dichiarati nel file manifest</strong> dell'applicazione. Per dichiarare un service, √® necessario aggiungere un elemento <service> come figlio dell'elemento <application>.</p>
<p>Comprendere il ciclo di vita e le diverse tipologie di service √® fondamentale per sviluppare applicazioni Android efficienti che eseguono operazioni in background in modo appropriato, senza impattare negativamente sull'esperienza utente o sulle risorse del dispositivo.</p>
<p>Quando un servizio √® in esecuzione, pu√≤ notificare gli eventi all'utente utilizzando le <strong>notifiche snackbar</strong> o le <strong>notifiche della barra di stato</strong>.</p>
<p>Una notifica nella barra di app √® un messaggio che viene visualizzato sulla superficie della finestra corrente solo per un breve istante prima di scomparire. Una notifica nella barra di stato fornisce un'icona con un messaggio, che l'utente pu√≤ selezionare per eseguire un'azione (ad esempio avviare un'attivit√†).</p>
<p>In genere, una notifica nella barra di stato √® la tecnica migliore da utilizzare quando un'operazione in background, come il download di un file, √® stata completata e l'utente pu√≤ ora intervenire. Quando l'utente seleziona la notifica dalla visualizzazione espansa, la notifica pu√≤ avviare un'attivit√† (ad esempio per</p>
<p>visualizzare il file scaricato).</p>
<h2 id="broadcast-receiver"><strong>BROADCAST RECEIVER</strong></h2>
<p>Un <strong>Broadcast Receiver</strong> √® un componente Android progettato per <strong>rispondere a</strong> messaggi provenienti da altre applicazioni o dal sistema operativo. Per implementare un broadcast receiver si estende la classe BroadcastReceiver e implementare il metodo onReceive(Context context, Intent intent) dal quale estraiamo l‚Äôevento di intent, i dati ecc.</p>
<p>Questi messaggi sono incapsulati negli intent per poter attraversare le applicazioni. Le app possono registrarsi per ascoltare specifici tipi di intent broadcast; quando un intent di quel tipo viene inviato, il sistema notifica il receiver in modo che possa eseguire un'azione.</p>
<p>Gli <strong>intent broadcast</strong> non sono indirizzati a destinatari specifici, ma a tutte le app interessate che hanno registrato un receiver per quel tipo di intent lo riceveranno. Le app anche in background possono ricevere messaggi dai broadcast receiver e svolgere delle attivit√†.</p>
<p>Esistono due tipi di intent broadcast: quelli <strong>inviati dal sistema (system broadcast intents)</strong> e quelli <strong>inviati dalla tua app (custom broadcast intents)</strong>.</p>
<ol>
<li>Gli intent broadcast di sistema vengono inviati quando si verifica un evento di sistema che potrebbe interessare la tua app, come l'avvio del dispositivi, la connessione o disconnessione dall'alimentazione ecc.</li>
<li>Gli intent broadcast personalizzati vengono utilizzati quando vuoi che la tua app esegua un'azione senza avviare un'attivit√†, ad esempio per informare altre app che sono stati scaricati dei dati.</li>
</ol>
<p>Ci sono due modi per registrare un broadcast receiver:</p>
<ol>
<li>staticamente nel file manifest aggiungendo un elemento \<receiver> al file AndroidManifest.xml e usare il percorso della tua sottoclasse BroadcastReceiver come attributo android:name.
    I receiver registrati staticamente possono essere attivati anche se il processo della tua app non √® in esecuzione e pu√≤ accedere ad ogni eventi di sistema.</li>
</ol>
<p>Infatti Android si accorse che questo causava problemi di sicurezza, visto che potevano essere inseriti dei malware quando si verificavano deteminati eventi di sistema. Allora definirono una registrazione</p>
<ol>
<li>dinamica sulla base del contesto con cui si chiamava il broadcast receiver. La registrazione avviene chiamando il metodo registerReceiver() e passando un oggetto BroadcastReceiver e un IntentFilter. I receiver registrati dinamicamente sono legati al ciclo di vita del componente in cui sono registrati, infatti √® necessario gestire anche la loro cancellazione perch√© potrebbero contenere dati che sprecherebbero risorse</li>
</ol>
<p><img alt="This is a flowchart of the Android Fragment lifecycle. Key steps in order: - onAttach - onCreate - onCreateView - onActivityCreated - onStart - onResume (Visible ‚Üí Active) Then the teardown path (when leaving): - onPause - onStop - onDestroyView - onDestroy - onDetach The diagram also shows a return arrow between onDestroyView and onCreateView labeled &quot;Fragment returns to the layout from the backstack,&quot; and a dotted divider indicating the visible/active transition." src="./Android_images/image_016.png" /><img alt="The image is a side-by-side flowchart comparing two Android Service lifecycles: - Left (Started/unbound service): - Call to startService() (blue) - onCreate() (gray) - onStartCommand() (gray) - Service running (green) ‚Äî active lifetime (yellow background) - The service is stopped by itself or a client - onDestroy() (gray) - Service shut down (orange) ‚Äî labeled &quot;Unbounded service&quot; - Right (Bound/bound service): - Call to bindService() (blue) - onCreate() (gray) - onBind() (gray) - Clients are bound to service (green) ‚Äî active lifetime (yellow background) - All clients unbind by calling unbindService() - onUnbind() (gray) - onDestroy() (gray) - Service shut down (orange) ‚Äî labeled &quot;Bounded service&quot; Shapes are color-coded (blue calls, gray lifecycle callbacks, green running state, orange shutdown) and a yellow region marks the active lifetime." src="./Android_images/image_017.png" /></p>
<p>Il pattern che viene usato √® l‚Äô<strong>observer con tassonomia ad eventi</strong></p>
<h3 id="modalita-di-invio-dei-broadcast"><strong>MODALIT√Ä DI INVIO DEI BROADCAST</strong></h3>
<p><strong>Broadcast Normali</strong>, con cui il broadcast intente √® prodotto da un singolo produce e viene inviato a tutti i receiver contemporaneamente. Essendo che vengono mandati sul thread principale, i receiver non vengono eseguiti in parallelo, quindi non √® possibile fare affidamento su un ordine di esecuzione particolare n√© sapere quando tutti i receiver hanno completato l'esecuzione.</p>
<p>Vengono inviati tramite il metodo sendBroadcast(). I receiver sono indipendenti fra loro e quindi non possono scambiarsi informazioni fra loro.</p>
<p><strong>Broadcast Ordinati</strong>, sono principalmente eventi di sistema, e questi sono mandati ad una sequenza di broadcast che quandi ricevono l‚Äôintent verificano se lo possono risolvere o se ne hanno autorizzazione a risolvelo, altrimenti viene mandato al broadcast successivo fino ad arrivare alla fine della sequenza dove viene lanciata un‚Äôeccezione per segnalare che non √® stato possibile risolverlo.</p>
<p>E possibile anche assegnare delle priorit√†, tramite android:priority per modificare l‚Äôordine di esecuzione. Conviene nella catena mettere sempre quelli pi√π specifici per quello che si deve fare. Questo implementa il <strong>pattern di catena di responsabilit√†</strong>.</p>
<p><img alt="A high-level component/flow diagram for an observer-based MVP-like architecture: - Top-left: &quot;View 1&quot; sends requests (processing/data) to &quot;Presenter 1 - Observer&quot; and receives UI updates back. - Center: &quot;Presenter 1 - Observer&quot; acts as the observer/controller. It calls methods on models and registers a BroadcastReceiver. - Bottom-center (Models box): contains &quot;Model 1&quot;, &quot;BroadcastReceiver&quot;, and &quot;Model 2&quot;. The presenter calls methods on Model 1 and Model 2 and registers the BroadcastReceiver there. - Right: &quot;Observable&quot; receives updated values from the Models layer and exposes updates back to the Presenter. - Arrows show the runtime flow: Models update the Observable -&gt; Observable provides updated value to the Presenter (calls update method / get updated value) -&gt; Presenter updates the View. - The BroadcastReceiver is shown as part of the Models block and connects into the Observable update flow (it receives broadcasts and contributes to model/observable updates)." src="./Android_images/image_018.png" /></p>
<p><strong>LocalBroadcastManager</strong> Questi rimangono nell‚Äôapp e quindi non hanno bisogno di intent e n√© della registrazione nel manifest. Si ottiene un'istanza singleton chiamando getInstance(context), che √® thread-safe. Per inviare un broadcast locale si usa il suo metodo sendBroadcast(), e per registrare un receiver si usa registerReceiver(). I receiver locali devono essere registrati dinamicamente nel codice; la registrazione statica nel manifest non √® disponibile per LocalBroadcastManager. √à importante annullare la registrazione del receiver locale quando non √® pi√π necessario per evitare memory leak.</p>
<p><strong>Custom Broadcast</strong> sia il producer che il receiver devono avere lo stesso nome e devono avere un URI di riferimenti che deve essere univoco, infatti si usa il FQN del package in cui si trova</p>
<h3 id="restizione-dei-broadcast"><strong>RESTIZIONE DEI BROADCAST</strong></h3>
<p>Bisogna evitare che altre applicazione estraggano dati dei broadcast. Infatti il sistema Android non √® multiutente, ma per dare maggiori sicurezza android definisce delle linee guida per evitare minacce alla sicurezza. √à necessario creare un sistema di permessi valido, implementando setpackage() per far consumare i messaggi broadcast solo da package specifici. I permessi che devono essere richiesti all‚Äôutente devono esser specificati nel manifest e non si possono mandare messaggi non confinati, l‚Äôunico che pu√≤ √® Android, che pu√≤ mandare permessi null, cio√® non confinati.</p>
<p>√à possibile imporre permessi per il ricevente e lo si fa con registerReceiver() e nel manifest dobbiamo specificare nel BroadcastReceiver android:permission con i permessi di cui ha bisogno. Quando si hanno bisogno dei permessi, si chiede all‚Äôutente di darli o meno. Se l‚Äôutente accetta, allora il BroadcastReceiver sar√† registrato. Non si devono fare operazioni long run perch√© impegneremmo troppo il sistema, quindi una volta che abbiamo acquisito i dati nella onReceiver(), liberiamo la callback e poi elaboriamo in modo asincrono. (code)</p>
<h2 id="contenet-provider"><strong>CONTENET PROVIDER</strong></h2>
<p>Un <strong>Content Provider</strong> √® un componente di Android che gestisce l'accesso a un repository di dati. L'applicazione non ha bisogno di sapere dove o come i dati sono archiviati, formattati o acceduti.</p>
<p><img alt="The diagram shows how an Android BroadcastReceiver works: - Top: &quot;Android system&quot; (Android robot in a cloud). - Bottom: &quot;Broadcast receiver&quot; (Android robot). - Step 1 (arrow from receiver to system): &quot;Register for Broadcast intent.&quot; - Step 2 (arrow from system to receiver): &quot;onReceive()&quot; ‚Äî the system delivers the broadcast to the receiver. - Dotted lines and radiating signal icon indicate the broadcast flow between the system and the receiver." src="./Android_images/image_019.png" />Un Content Provider separa i dati dal codice dell'interfaccia utente dell'app, fornendo un <strong>modo standard</strong> per accedere ai dati. Rende possibile la condivisione di dati tra diverse applicazioni. (Pattern Adapter)</p>
<p>Consente a pi√π applicazioni di accedere, utilizzare e modificare in modo sicuro una singola origine dati fornita dalla tua app.</p>
<p>Per ottenere dati e interagire con un Content Provider, un'app utilizza un <strong>ContentResolver</strong> per inviare richieste al Content Provider.
L'applicazione di un fornitore pu√≤ specificare le autorizzazioni che altre applicazioni devono avere per accedere ai dati del fornitore. Queste autorizzazioni consentono all'utente di sapere a quali dati un'applicazione tenta di accedere. In base ai requisiti del fornitore, altre applicazioni richiedono le autorizzazioni necessarie per accedere al fornitore. Gli utenti finali vedono le autorizzazioni richieste quando installano l'applicazione.</p>
<p>Se l'applicazione di un provider non specifica alcuna autorizzazione, le altre applicazioni non avranno accesso ai dati del provider, a meno che il provider non venga esportato.</p>
<p>Per rendere disponibile un ContentProvider all'interno di un'app Android, √® necessario <strong>dichiararlo esplicitamente</strong> nel file AndroidManifest.xml, all‚Äôinterno del tag <application> tramite l'elemento <provider>, che contiene una serie di attributi fondamentali.</p>
<ul>
<li>android:name, che specifica il nome completo della classe che implementa il ContentProvider.</li>
<li>android:authorities, che rappresenta un identificatore univoco del provider. Questo valore viene utilizzato dalle app per costruire gli URI di accesso al provider. Per esempio, se l‚Äôauthority √® com.miaapp.provider, l‚ÄôURI per accedere a una risorsa potrebbe essere content://com.miaapp.provider/risorse.</li>
<li>android:exported. Questo valore determina se il provider pu√≤ essere accessibile da altre app. Se impostato su true, il provider potr√† essere utilizzato anche da app esterne, mentre se √® false, sar√† accessibile solo dall‚Äôinterno dell‚Äôapplicazione stessa. Questo √® un parametro importante per la sicurezza, specialmente se i dati gestiti sono sensibili.</li>
</ul>
<p>√à anche possibile specificare dei <strong>permessi di accesso</strong> per controllare quali app possono leggere o scrivere dati tramite il provider. Questo si fa aggiungendo gli attributi android:readPermission e android:writePermission, dove si indicano i nomi dei permessi richiesti. Le app che vogliono accedere al provider dovranno dichiarare nel proprio manifest questi permessi, e l‚Äôutente li vedr√† al momento dell‚Äôinstallazione.</p>
<p>L'architettura di un Content Provider include i seguenti componenti:</p>
<ul>
<li>Data and Open Helper: Il repository dei dati. Comunemente i dati sono archiviati in un database SQLite, ma possono essere anche file, dati sul web o dati generati dinamicamente. Per i database SQLite, si utilizza spesso un SQLiteOpenHelper per l'accesso ai dati.</li>
<li>Contract: Una classe pubblica che espone informazioni importanti sul Content Provider ad altre app. Include solitamente gli schemi URI, costanti importanti e la struttura dei dati restituiti. L'uso di un contract separa le informazioni pubbliche da quelle private e fornisce un unico punto di riferimento per le altre app.</li>
<li>Content Provider: Una classe che estende ContentProvider e implementa i metodi query(), insert(), update() e delete() per accedere ai dati. Fornisce un'interfaccia pubblica e sicura ai dati.</li>
<li>Content Resolver: Un oggetto utilizzato dalle app per inviare richieste al Content Provider e ottenere i dati. Fornisce i metodi query(), insert(), update() e delete() che rispecchiano quelli del Content Provider.</li>
</ul>
<p>Per implementare un Content Provider, √® necessario:</p>
<ul>
<li>Avere i dati e un modo per accedervi</li>
<li>Dichiarare il Content Provider nel file AndroidManifest.xml per renderlo disponibile. √à importante impostare l'attributo android:exported="true" se si desidera che altre app possano accedervi.</li>
<li>Creare una sottoclasse di ContentProvider che implementi i metodi per l'accesso e la manipolazione dei dati (query(), insert(), delete(), update(), getType()).</li>
<li>Definire una classe Contract pubblica che esponga l'URI scheme, i nomi delle tabelle, i tipi MIME e altre costanti importanti.</li>
</ul>
<h3 id="uri-e-tipi-mime"><strong>URI e tipi MIME</strong></h3>
<p>Le app inviano richieste ai Content Provider utilizzando gli <strong>Uniform Resource Identifier (URI)</strong>. Un content URI ha la forma generale scheme://authority/path/ID, dove lo scheme √® sempre content://, l'authority rappresenta il dominio del provider (solitamente il nome del package che termina con .provider), il path √® il percorso ai dati e l'ID identifica univocamente un set di dati. Il contract definisce costanti per l'AUTHORITY, il CONTENT_PATH e il CONTENT_URI.</p>
<p>Il <strong>tipo MIME</strong> indica il tipo e il formato dei dati restituiti dal Content Provider. Per i Content URI che puntano a righe di una tabella, si utilizzano tipi MIME specifici del vendor Android, con il formato generale type.subtype/provider-specific-part. Il type √® vnd, il subtype √® android.cursor.item/ per una singola riga e android.cursor.dir/ per pi√π righe, e la parte specifica del provider include solitamente il nome del package e il nome della tabella. Il metodo getType() del Content Provider restituisce il tipo MIME dei dati per un dato URI.</p>
<p>Il ContentResolver fornisce metodi (query(), insert(), delete(), update()) che corrispondono a quelli implementati nel ContentProvider.</p>
<ul>
<li>Il metodo query() viene utilizzato per recuperare dati e restituisce un oggetto Cursor, che √® un puntatore a una riga di dati strutturati in formato tabellare, simile a un risultato di una query SQL. La query pu√≤ includere una proiezione (le colonne da restituire), una clausola di selezione (il WHERE), gli argomenti di selezione e l'ordine di ordinamento (ORDER BY).</li>
<li>I metodi insert(), delete() e update() vengono utilizzati per modificare i dati. Il metodo insert() riceve i valori da inserire come ContentValues e restituisce l'URI della nuova riga.</li>
</ul>
<p>√à buona pratica utilizzare un UriMatcher per gestire il matching degli URI all'interno del Content Provider, associando ogni URI supportato a un codice intero.</p>
<h2 id="intent"><strong>INTENT</strong></h2>
<p>In Android, un <strong>Intent</strong> √® un meccanismo IPC per comunicare con il sistema operativo e fra le applicazioni. Gli Intent sono messaggi che effettuano una richiesta all'Android runtime per avviare un'activity o un altro componente dell'app o di un'altra app. Invece di avviare direttamente le activity, si costruiscono Intent con la classe Intent e si chiama il metodo startActivity() per inviare l'intent.</p>
<p>Un <strong>Intent esplicito</strong> specifica l'activity (o un altro componente) ricevente tramite il suo nome di classe completo. Si utilizzano Intent espliciti per avviare componenti all'interno della propria applicazione. Per creare un Intent esplicito, si utilizza un Context e un oggetto Class. Il metodo newIntent() pu√≤ essere utilizzato per configurare correttamente un Intent esplicito con gli extra necessari. L'activity ricevente ottiene l'Intent con getIntent() e recupera i dati dagli extra. √à anche possibile avviare un'activity aspettandosi un risultato utilizzando startActivityForResult(Intent, requestCode). L'activity chiamata invier√† un risultato tramite un altro Intent, e l'activity chiamante ricever√† il risultato nel metodo onActivityResult(). Una Activity avviata tramite startActivity √® indipendente da quella chiamante e non fornir√† alcun dato di risposta alla chiusura.</p>
<p>Laddove √® richiesto un feedback, √® possibile avviare un'attivit√† come subactivity che pu√≤ restituire irisultati al suo genitore. Per fare questi si utilizza startActivityForResult(). Quando la sub-activity √® pronta per essere restituita, si utilizza setResultprima della fine per restituire un risultato all'attivit√† chiamante.Il metodo setResultaccetta due parametri: <strong>il codice</strong> del risultato e <strong>i dati del risultato stesso</strong>, <strong>rappresentati come un Intent.</strong></p>
<p>Il codice del risultato indica il successo dell'esecuzione dell'attivit√† secondaria (RESULT_OK) o insuccesso (Activity.RESULT_CANCELED).</p>
<p>Un <strong>Intent implicito</strong> non specifica un'activity o un altro componente specifico per ricevere l'intent. Invece, si dichiara un'azione generica da eseguire nell'intent. Il sistema Android abbina la richiesta a un'activity o a un altro componente in grado di gestire l'azione richiesta (<strong>late binding</strong>). Se pi√π activity corrispondono, all'utente viene presentata una finestra di dialogo di selezione dell'app. Le activity dichiarano la loro capacit√† di gestire Intent impliciti tramite i <strong>filtri di intent</strong> definiti nel file AndroidManifest.xml. Per inviare un <strong>Intent implicito</strong>, si crea un oggetto Intent specificando l'azione, i dati (se presenti) e il tipo MIME dei dati. Prima di chiamare un Intent implicito, √® buona pratica verificare se ci sono activity in grado di gestirlo chiamando resolveActivity(getPackageManager()). Se si desidera mostrare sempre all'utente un chooser di app quando pi√π app possono gestire l'intent, si pu√≤ utilizzare Intent.createChooser(Intent target, String title).</p>
<p>Il passaggio da un'Activity ad un'altra coinvolge i cicli di vita di entrambe. La prima, quella messa a riposo, dovr√† passare almeno per onPause() e onStop() mentre la seconda percorrer√† la catena di creazione onCreate-onStart-onResume. La priorit√† del sistema √® <strong>il mantenimento della fluidit√† della <em>user-experience</em></strong>, quindi:</p>
<ul>
<li>La prima Activity passa per onPause e viene fermata in stato Paused;</li>
<li>La seconda Activity va in Running venendo attivata completamente. In tale maniera l'utente potr√† usarla al pi√π presto non subendo tempi di ritardo;</li>
<li>a questo punto, mentre l'utente sta gi√† usando la seconda Activity, il sistema pu√≤ invocare¬†onStop sulla prima.</li>
</ul>
<h3 id="filtri"><strong>FILTRI</strong></h3>
<p>I <strong>filtri di intent</strong> sono dichiarazioni nel file manifest di un componente dell'app (solitamente un'attivit√†, un servizio o un ricevitore di broadcast) che specificano i tipi di intent che il componente pu√≤ gestire.</p>
<p>I filtri di intent sono fondamentali per il funzionamento degli <strong>intent impliciti</strong>. Quando un'applicazione invia un intent implicito, il sistema Android utilizza i filtri di intent dichiarati da tutte le app installate per determinare quale componente √® il pi√π adatto a gestire la richiesta.</p>
<p>I filtri di intent sono dichiarati nel file AndroidManifest.xml all'interno dell'elemento <activity>, <service> o <receiver> usando uno o pi√π elementi <intent-filter> che pu√≤ contenere tre tipi di elementi che corrispondono alle informazioni contenute in un oggetto Intent:</p>
<ul>
<li><action>: Specifica l'azione generica che il componente pu√≤ eseguire. Le azioni sono definite come costanti nella classe Intent. Un intent implicito deve contenere un'azione che corrisponda ad almeno una delle azioni dichiarate nel filtro. √à possibile specificare pi√π azioni all'interno dello stesso filtro.</li>
<li><category>: Fornisce informazioni aggiuntive sulla categoria del componente che dovrebbe gestire l'intent. Le categorie sono definite come costanti nella classe Intent. Un intent deve corrispondere a tutte le categorie specificate in un filtro per passare. √à importante notare che tutte le attivit√† che intendono ricevere intent impliciti devono includere la categoria android.intent.category.DEFAULT, in quanto questa categoria viene aggiunta implicitamente a tutti gli oggetti Intent impliciti dal sistema Android.</li>
<li><data>: Specifica il tipo di dati che il componente pu√≤ gestire. Questo include il tipo MIME dei dati o altri attributi di un URI (come lo schema, l'host, la porta e il percorso). Un intent pu√≤ specificare un URI di dati e/o un tipo MIME. Il filtro pu√≤ dichiarare quali schemi URI e tipi MIME sono supportati.</li>
</ul>
<p>Per un intent implicito affinch√© venga consegnato a un componente, l'intent deve superare i test di <strong>tutti e tre gli elementi (azione, categoria e dati)</strong> definiti in almeno uno dei filtri di intent dichiarati dal componente. Se un componente ha pi√π filtri di intent, un intent che non corrisponde a un filtro potrebbe comunque corrispondere a un altro.</p>
<h3 id="gli-extras"><strong>GLI EXTRAS</strong></h3>
<p>Gli Intent √® che essi, nel recapitare questo messaggio, portano con se dati che possono essere letti dal destinatario. Questi valori condivisi mediante Intent vengono chiamati <strong>Extras</strong> e possono essere di varie tipologie, sia appartenenti a classi pi√π comuni che ad altre purch√© serializzabili. La gestione degli Extras negli Intent funziona in maniera simile ad una struttura dati HashMap: con dei metodi putviene inserito un valore etichettato con una chiave e con i corrispondenti metodi get viene prelevato il valore, richiedendolo mediante la chiave di riconoscimento.</p>
<h3 id="paramtri-intent"><strong>PARAMTRI INTENT</strong></h3>
<p><strong>Activity class (per Intent espliciti)</strong>: il nome della classe dell'activity o del componente che dovrebbe ricevere l'intent.</p>
<p><strong>Intent action</strong>: l'azione generica che l'activity ricevente dovrebbe eseguire. Le azioni disponibili sono definite come costanti nella classe Intent e iniziano con ACTION_. Esempi includono ACTION_VIEW, ACTION_SEND e ACTION_PICK.</p>
<p><strong>Intent category</strong>: fornisce informazioni aggiuntive sulla categoria del componente che dovrebbe gestire l'intent. Le categorie sono opzionali e possono essere aggiunte con il metodo addCategory(). Esempi includono CATEGORY_LAUNCHER, CATEGORY_DEFAULT e CATEGORY_BROWSABLE. Per rispondere a Intent impliciti, un filtro di intent deve impostare esplicitamente la categoria DEFAULT, che viene aggiunta implicitamente a ogni Intent implicito.</p>
<p><strong>Intent data</strong>: contiene un riferimento ai dati su cui l'activity ricevente dovrebbe operare, come un oggetto Uri. Pu√≤ rappresentare un URL web, un numero di telefono o un percorso a un file. Il tipo di dati pu√≤ anche essere specificato con il metodo setType(), utilizzando un tipo MIME.</p>
<p><strong>Intent extras</strong>: coppie chiave-valore che trasportano informazioni aggiuntive richieste dall'activity ricevente. I valori possono essere tipi primitivi o oggetti che implementano l'interfaccia Parcelable. I metodi putExtra() vengono utilizzati per aggiungere extra a un Intent, e getIntent().getExtras() o metodi specifici come getStringExtra() o getIntExtra() vengono utilizzati per recuperarli nell'activity ricevente.</p>
<p><strong>Intent flags</strong>: metadati aggiuntivi che istruiscono il sistema Android su come avviare un'activity o come trattarla dopo l'avvio.</p>
<h3 id="tipi-di-intent"><strong>TIPI DI INTENT</strong></h3>
<p>Un <strong>broadcast intent</strong> √® un tipo di intent che non avvia un'activity specifica, ma viene consegnato a tutti i <strong>broadcast receiver</strong> interessati registrati per tale intent. I broadcast receiver sono componenti che ascoltano specifici broadcast di sistema o personalizzati.</p>
<p>Un <strong>PendingIntent</strong> √® un token che si concede a un'altra applicazione per utilizzare le autorizzazioni del proprio processo per eseguire un'azione in un secondo momento. Viene spesso utilizzato per le notifiche.</p>
<p>Un <strong>IntentService</strong> √® una sottoclasse di Service che gestisce le richieste intent in background, una alla volta.</p>
<h1 id="interfaccia-utente"><strong>INTERFACCIA UTENTE</strong></h1>
<p>Quando sviluppiamo un‚Äôapp Android, dobbiamo pensare all‚Äôinterfaccia grafica, ovvero a come gli elementi vengono organizzati sullo schermo.</p>
<p>L'<strong>interfaccia utente (UI)</strong> di un'applicazione √® costruita attraverso una <strong>gerarchia di oggetti chiamati view</strong>. Ogni elemento visibile sullo schermo √® una view.</p>
<p>Tutti i componenti visivi in Android discendono dalla classe Viewe vengono indicati genericamente come Views.</p>
<p>La classe <strong>ViewGroup</strong> √® un'estensione di View che supporta <strong>l'aggiunta di visualizzazioni innestate</strong> che hanno la responsabilit√† di decidere le dimensioni della view di ogni figlio e di determinare la loroposizione.</p>
<p>I ViewGroup che si concentrano principalmente sulla disposizione delle viste contenute sono indicati come <strong>layout</strong>. I ViewGroup sono visti quindi possono anche disegnare la propria interfaccia utente personalizzata e gestire le interazioni degli utenti.</p>
<p><strong>Layouts</strong> ‚Üí definiscono la struttura e la disposizione degli elementi sulla schermata</p>
<p><strong>Views</strong> ‚Üí Sono gli elementi base dell‚Äôinterfaccia utente</p>
<p><strong>Widgets</strong> ‚Üí Sono particolari tipi di View con funzionalit√† specifiche</p>
<p>Per creare e disporre le viste all'interno della UI si possono utilizzare risorse di layout XML per creare e costruire lo scheletro statico della UI di un Actvity da fare evolvere dinamicamente in modo programmatico.</p>
<p>Questo approccio consente di specificare diversi layout ottimizzati per diverse configurazioni hardware, in particolare variazioni delle dimensioni dello schermo, potenzialmente anche modificandoli in fase di esecuzione in base a modifiche hardware (come i cambiamenti di orientamento).</p>
<p>L‚Äôinterfaccia utente √® organizzata in una struttura ad <strong>albero gerarchico</strong>, chiamata <strong>albero delle View</strong></p>
<ul>
<li>i nodi interni sono le ViewGroup</li>
<li>le foglie sono le View effettive</li>
</ul>
<p>Quando apriamo un‚Äôapplicazione Android, una delle prime cose che il sistema fa √® costruire l‚Äôinterfaccia grafica dell‚ÄôActivity in base alla struttura definita nel file XML del layout. Questo processo avviene all‚Äôinterno del metodo <strong>onCreate()</strong>, dove viene caricato l‚Äôalbero delle View.</p>
<p>Quando il metodo onCreate() viene eseguito, l‚ÄôActivity richiama setContentView(R.layout.activity_main), che ha il compito di leggere il file XML e tradurlo in un insieme di oggetti <strong>View</strong> e <strong>ViewGroup</strong> in memoria.</p>
<p>Android calcola la disposizione degli elementi, assegna loro le dimensioni e infine li disegna sullo schermo.</p>
<p>Android d√† la possibilit√† di <strong>modificare l‚Äôalbero delle View in tempo reale</strong>, aggiungendo, rimuovendo o modificando elementi dell‚Äôinterfaccia mentre l‚Äôutente sta interagendo con l‚Äôapp, senza dover ricaricare l‚Äôintera Activity</p>
<h2 id="eventi"><strong>EVENTI</strong></h2>
<p>Le view permettono di acquisire gli eventi dalla l'oggetto con cui interagisce l'utente. Per un'app Android, l'interazione in genere consiste nel toccare, premere, digitare o parlare e ascoltare.</p>
<p>La View che <strong>ha il focus</strong> sar√† la componente che riceve l'input dell'utente.</p>
<p>Il focus pu√≤ essere avviato dall'utente toccando una View. √à possibile definire un ordine di focus in cui l'utente viene guidato da un controllo UI a un altro controllo UI.
Il focus pu√≤ anche essere controllato a livello di programmazione; un programmatore pu√≤ richiedereFocus() su qualsiasi View che √® focalizzabile.</p>
<p>Un altro attributo di un controllo di input √® <strong>cliccabile</strong>. Se questo attributo √® true, allora la View pu√≤ reagire agli eventi di clic. Come per il focus, cliccabile pu√≤ essere controllato a livello di programmazione.</p>
<p>La differenza tra cliccabile e focalizzabile √® che cliccabile significa che la view pu√≤ essere cliccata o toccata, mentre focalizzabile significa che alla view √® consentito ottenere il focus da un dispositivo di input come una tastiera.
I dispositivi di input come le tastiere non possono determinare a quale view inviare i loro eventi di input, quindi li inviano alla view che ha il focus.</p>
<p>per intercettarlo, devi estendere la classe e sostituire il metodo. Tuttavia, l'estensione di ogni oggetto View per gestire un evento del genere non sarebbe pratica. Per questo motivo la classe View contiene anche una raccolta di interfacce nidificate con callback che puoi definire molto pi√π facilmente.
Un <strong>listener di eventi</strong> √® un'interfaccia della classe View che contiene un singolo di callback. Questi metodi verranno chiamati dal framework Android quando la view a cui il listener ha registrato viene attivato dall'interazione dell'utente con l'elemento nell'interfaccia utente.</p>
<p>Le interfacce del listener di eventi includono i seguenti metodi di callback:</p>
<p>onClick()da¬†View.OnClickListener. Questo viene chiamato quando l'utente tocca l'elemento. (in modalit√† touch) o si concentra sull'elemento con i tasti di navigazione o la trackball e preme il tasto "Invio" adatto o premi la trackball.</p>
<p>onLongClick()da¬†View.OnLongClickListener. Questo viene chiamato quando l'utente tocca e tiene premuto l'elemento (in modalit√† tocco) o si concentra sull'elemento con i tasti di navigazione o la trackball e tiene premuto il pulsante "Invio" o tenere premuto sulla trackball (per un secondo).</p>
<p>onFocusChange()Da¬†View.OnFocusChangeListener. Questo viene chiamato quando l'utente si avvicina o si allontana dall'elemento utilizzando i tasti di navigazione o la trackball.</p>
<p>onKey()da¬†View.OnKeyListener. Viene chiamato quando l'utente si concentra sull'elemento e preme o rilascia un tasto hardware sul dispositivo.</p>
<p>onTouch()da¬†View.OnTouchListener. Questo nome viene chiamato quando l'utente esegue un'azione qualificata come evento touch, ad esempio una stampa, un comunicato stampa o qualsiasi gesto di movimento sullo schermo (entro i limiti dell'elemento).</p>
<p>onCreateContextMenu() da¬†<a href="https://developer.android.com/reference/android/view/View.OnCreateContextMenuListener?hl=it">View.OnCreateContextMenuListener</a>. Questa operazione viene chiamata quando viene creato un menu contestuale (in seguito a un "clic lungo") prolungato.</p>
<p>Un¬†<strong>gesto di tocco</strong>¬†si verifica quando un utente posiziona una o pi√π dita sul il touchscreen e l‚Äôapp interpreta questa sequenza di tocchi come un gesto.
Il rilevamento dei gesti prevede due fasi:</p>
<ol>
<li>la raccolta di dati sugli eventi touch</li>
<li>l‚Äôinterpretazione dei dati per determinare se soddisfano i gesti supportati dall‚Äôapp.</li>
</ol>
<p>Quando un utente posiziona una o pi√π dita sullo schermo, viene attivata la <strong>callback</strong>onTouchEvent()sulla visualizzazione che riceve gli eventi touch.
e per ogni sequenza di tocco viene memorizzata la posizione, pressione, dimensione, il numero di dita usate e altre info utili. Queste info vengono memorizzate nell‚Äôoggetto MotionEvent.
Il gesto inizia quando l'utente tocca per la prima volta lo schermo, poi continua mentre il sistema tiene traccia della posizione del dito o delle dita dell'utente e termina acquisire l'evento finale dell'ultimo dito dell'utente che lascia lo schermo.</p>
<p>Gli eventi, in particolare gli eventi di input come i tocchi, possono essere propagati attraverso la gerarchia delle view. Una View pu√≤ consumare un evento o passarlo al suo parent ViewGroup per la gestione. Il sistema Android <strong>distribuisce (dispatch)</strong> questi eventi ai componenti appropriati per la gestione.</p>
<p><img alt="A small UML-style diagram showing the Chain of Responsibility pattern: - Left: an oval labeled &quot;Client&quot;. - Top-center: a rectangular abstract/base class labeled &quot;Handler&quot; with a public method +HandleRequest(). - Below: two rectangles for concrete handlers (both labeled &quot;ConcreteHandler2&quot; in the image) with +HandleRequest() each. - Open-triangle arrows from each concrete handler up to Handler indicate inheritance/generalization. - The client is associated with/uses the Handler (implied connection)." src="./Android_images/image_020.png" />Quando si verifica un evento di interazione, si propaga dall'activity andando fino alla view.</p>
<p>Quindi a tutti i componenti della gerarchia viene data la possibilit√† di gestire l'evento, iniziando con la vista in alto e tornando all'attivit√†. Quindi l'activity √® la prima a ricevere l'evento e l'ultima a cui viene data la possibilit√† di gestirlo.</p>
<p>Se qualche ViewGroup vuole gestire immediatamente l'evento touch, pu√≤ restituire true nel suo <strong>onInterceptTouchEvent()</strong>.</p>
<p>Una Activity non ha onInterceptTouchEvent() ma pu√≤ sovrascrivere dispatchTouchEvent() per fare la stessa cosa.</p>
<p>Se una vista (o un gruppo di viste) ha un OnTouchListener, l'evento tocco viene gestito da OnTouchListener.onTouch()</p>
<p>Altrimenti √® gestito da onTouchEvent(). Se onTouchEvent () restituisce true per qualsiasi evento di tocco, la gestione si interrompe. Nessun altro ne ha la possibilit√†.</p>
<p>La classe <strong>GestureDetector</strong> pu√≤ essere utilizzata per interpretare sequenze di MotionEvent e dispatchare eventi di gesto specifici (come tap, swipe, fling) a un listener OnGestureListener</p>
<h2 id="view-personalizzate"><strong>VIEW PERSONALIZZATE</strong></h2>
<p>La creazione di nuove visualizzazioni d√† la possibilit√† di modellare l'aspetto e il funzionamento delle applicazioni. Creando i propri controlli, si pu√≤ creare una interfacce utente che si adatta in modo perfetto ai requisiti.</p>
<p>Per creare nuovi controlli da un'area di disegno vuota, si usa la classe base <strong>View</strong> o <strong>SurfaceView</strong>.</p>
<p>La classe View fornisce un oggetto <strong>Canvas</strong> con una serie di metodi di disegno e classi Paint. Servono per creare un'interfaccia visiva con bitmap e grafica raster. √à possibile catturare e sovrascrivere gli eventi utente, inclusi i tocchi dello schermo o la pressione dei tasti per fornire l'interattivit√†.</p>
<p>La classe <strong>SurfaceView</strong> fornisce un oggetto Surface che supporta il disegno da un thread in background e, facoltativamente, l'uso di OpenGL per implementare la grafica.</p>
<p>Per creare una view custom dobbiamo fornire la classe:</p>
<ol>
<li>Costruttori
     a. Uno a cui passiamo solo il contesto
     b. Contesto e attributi
     c. Contesto attributi e stile</li>
<li>onMeasure() che viene chiamato quando la view deve essere disegnata. L‚Äôincarico di disegnare la view spetta al genitore che chiede al figlio le sue dimensioni: altezza e larghezza, chiamando i metodi della classe del figlio.
    a. Questa funzione viene chiamata ogni volta che la view viene invalidata.</li>
<li>onDraw() che serve per fare effettivamente il disegno della view. Questa funzione viene chiamata frequentemente e o in modo sincrono in base alla frequenza di refresh impostata dal dispositivo. Se la frequenza di refresh √® minore del tempo con cui questa funzione viene chiamata si hanno dei problemi nel rendering.</li>
</ol>
<h2 id="layout"><strong>LAYOUT</strong></h2>
<p>Alcuni ViewGroup sono designati come <strong>layout</strong> perch√© organizzano le View figlie in un modo specifico e sono tipicamente usati come <strong>ViewGroup</strong> radice.</p>
<p>I ViewGroup sono definiti nei file di <strong>layout XML</strong>, che si trovano nella cartella layout all'interno della cartella res del progetto Android. La gerarchia delle View, con un ViewGroup alla radice, pu√≤ diventare complessa in app con molte View sullo schermo. Comprendere questa gerarchia √® importante per l'efficienza del rendering e la visibilit√† delle View. √à possibile esplorare la gerarchia delle View di un'app utilizzando l'<strong>Hierarchy Viewer</strong>.</p>
<p><strong>1. LinearLayout</strong></p>
<p>Il <strong>LinearLayout</strong> organizza le sue View figlie in una singola direzione: <strong>verticale</strong> o <strong>orizzontale</strong>. Ogni elemento viene disposto uno dopo l'altro, rispettando l'ordine di dichiarazione. √à utile quando si desidera una disposizione semplice e sequenziale degli elementi.</p>
<p><strong>2. RelativeLayout</strong></p>
<p>Il <strong>RelativeLayout</strong> permette di posizionare le View figlie in relazione tra loro o rispetto al contenitore padre. Ad esempio, un elemento pu√≤ essere posizionato alla destra di un altro o allineato al bordo superiore del layout. Questo offre una maggiore flessibilit√† nella disposizione degli elementi rispetto al LinearLayout.</p>
<p><strong>3. FrameLayout</strong></p>
<p>Il FrameLayout √® progettato per contenere una singola View, ma pu√≤ gestire anche pi√π elementi sovrapposti. Le View aggiunte successivamente si posizionano sopra le precedenti, creando un effetto di stratificazione. √à spesso utilizzato per visualizzare una View principale con elementi sovrapposti, come pulsanti flottanti o indicatori di stato.</p>
<p><strong>4. ConstraintLayout</strong></p>
<p>Il <strong>ConstraintLayout</strong> offre un alto grado di flessibilit√†, permettendo di definire vincoli tra le View per determinare la loro posizione e dimensione. Questo layout √® stato introdotto per semplificare la creazione di interfacce complesse senza nidificare pi√π layout, migliorando le prestazioni dell'applicazione.</p>
<p><strong>6. GridLayout</strong></p>
<p>Un <strong>GridLayout</strong> (o GridLayoutManager per le liste) organizza gli elementi in <strong>righe e colonne</strong>, creando una struttura a griglia. √à utile quando si devono mostrare pi√π elementi con lo stesso peso visivo, come immagini o pulsanti.</p>
<p><strong>7. StaggeredGridLayout</strong></p>
<p>Uno <strong>StaggeredGridLayout</strong> √® simile a un GridLayout, ma con <strong>colonne o righe di altezze/larghezze diverse</strong>. Questo lo rende perfetto per layout pi√π dinamici e visivamente accattivanti.</p>
<p><img alt="Image: a simplified architecture diagram showing three apps (yellow, red, green) at the top, each connected to a corresponding &quot;Content Resolver&quot; box. All resolvers interact bidirectionally with a central horizontal &quot;Content Provider&quot; layer. The content provider then connects downward to three storage backends: a cloud SQL icon, a database cylinder, and a document/file icon. Arrows indicate request/response flow from apps ‚Üí resolvers ‚Üí provider ‚Üí storage and back." src="./Android_images/image_021.png" /><img alt="- Diagram of Android touch event delivery showing call flow top-to-bottom (notify) and return flow bottom-to-top (handle). - Top: Activity receives dispatchTouchEvent() and may handle in onTouchEvent(). - Middle: Nested containers ViewGroup A and ViewGroup B each get dispatchTouchEvent(), then onInterceptTouchEvent(): - If onInterceptTouchEvent() returns true, the ViewGroup handles the event in its onTouchEvent() (child bypassed). - If false, the event is dispatched down to the next child. - Bottom: Leaf View receives dispatchTouchEvent(); it first gives the event to an OnTouchListener (if present) and then to its onTouchEvent(). - OnTouchListener can consume the event (not shown explicitly) or fall through to onTouchEvent(). - Handling result propagates upward: once a view or viewgroup handles the event, the handled result is returned up the chain to the Activity." src="./Android_images/image_022.png" /></p>
<p>Il <strong>ConstraintLayout</strong> √® un <strong>ViewGroup</strong> in Android che offre un modo flessibile per disporre e allineare le View figlie all'interno di un layout. Utilizza un sistema di <strong>vincoli (constraints)</strong> per determinare la posizione e le dimensioni delle sue View figlie.</p>
<p>Il ConstraintLayout organizza le View figlie utilizzando <strong>punti di ancoraggio</strong>, <strong>bordi e linee guida</strong> per controllare come le View sono posizionate rispetto ad altri elementi nel layout. Un <strong>vincolo</strong> √® una connessione o un allineamento a un'altra View, al layout genitore o a una linea guida invisibile.</p>
<p>Ciascun vincolo definisce la posizione della vista lungo l'asse verticale o orizzontale; quindi ogni vista deve avere almeno un vincolo per ogni asse, ma spesso ne sono necessari di pi√π.</p>
<p><img alt="Image with four labeled panels showing common Android view groups and how child views are arranged: - FrameLayout (top-left): light background with two overlapping blue rectangles (children stacked). - LinearLayout (top-right): three blue rectangles laid out side-by-side in a single row (uniform spacing). - RelativeLayout (bottom-left): one large blue rectangle above two smaller side-by-side rectangles (children positioned relative to each other). - ConstraintLayout (bottom-right): a large rectangle and a tall right column with two small rectangles beneath the large one, illustrating flexible constraint-based placement." src="./Android_images/image_023.png" /><strong>Fissa</strong>: specifica una dimensione specifica nella casella di testo seguente o ridimensionando la vista nell'editor.</p>
<p><img alt="An illustration showing three UI/layout examples side-by-side, each inside a light-blue framed panel with a label below: - Linear: a single vertical column of equal-width horizontal bars stacked top to bottom (a list). - Grid: a uniform 2√ó3 grid of equal-sized square tiles. - Staggered Grid: two columns of tiles with varying heights arranged like a masonry layout, so rows don‚Äôt line up." src="./Android_images/image_024.png" /><strong>A capo</strong>: la visualizzazione si espande solo per adattarsi ai contenuti.</p>
<p><img alt="A small monochrome icon: a short horizontal line with a short vertical bar at each end, centered on a white background (looks like a dimension/measure or ‚Äúpinch to expand/contract‚Äù style symbol)." src="./Android_images/image_025.png" /><strong>Vincoli di corrispondenza</strong>: la vista si espande il pi√π possibile per soddisfare i vincoli su ogni lato, dopo aver tenuto conto dei margini della vista.</p>
<h2 id="modelli-navigazionali"><strong>MODELLI NAVIGAZIONALI</strong></h2>
<p><img alt="A small light-gray rounded-square icon containing three black chevrons (right-pointing arrows) arranged horizontally and evenly spaced." src="./Android_images/image_026.png" />Quando progettiamo l'interfaccia grafica e dobbiamo pensare all‚ÄôUX perch√© svolto in azioni troppo complesse tutte in una schermata pu√≤ portare l'utente a compiere errori.</p>
<p>Pu√≤ essere utile dividere una task complessa in pi√π task semplici e per questo √® possibile raggruppare task simili in N schermate diverse in modo che l‚Äôutente si focalizzi meglio di una singola parte.</p>
<p>√à necessario progettare come l'utente nave di chi e promuovere il <strong>way finding</strong> cio√® dare alle persone la possibilit√† di orientarsi e di muoversi all'interno delle schermate.</p>
<p>La navigazione si era voluta anche a capire le informazioni, cosa pu√≤ fare, dov'√® ora, dove pu√≤ andare e come tornare indietro.</p>
<p>Per aiutare gli utenti a navigare necessario usare <strong>elementi di segnaletica</strong> per aiutare l'utente a orientarsi.</p>
<ul>
<li>Indicatori di avanzamento</li>
<li>Barre di stato</li>
<li>Breadsceumbs</li>
</ul>
<p>La navigazione √® un overhead perch√© richiede tempo e risorse per realizzarle in quanto si potrebbe realizzare tutto in una singola schermata ma il motivo per cui si venne a realizzare √® di ridurre il carico cognitivo, lo sforzo mentale √® caduta anni fa per elaborare le informazioni. Dobbiamo raggruppare task simili perch√© troppe task che svolgono operazioni diverse ma anche troppe che ne svolgono simili portano all'utente a compiere errori e lapsus perch√© secondo le scienze cognitive l'uomo non riesce a concentrarsi pi√π su pi√π di sette oggetti alla volta.</p>
<p><img alt="A small square image with a light gray background showing five short, thick vertical black bars evenly spaced. A single slanted zigzag line connects the tops of the bars, creating a sawtooth/waveform-like shape." src="./Android_images/image_027.png" /><strong>Fully Connected Navigation</strong> Ogni sezione dell‚Äôinterfaccia pu√≤ portare direttamente a qualsiasi altra. Questo tipo di navigazione √® utile quando si vuole offrire <strong>massima libert√†</strong> all‚Äôutente. Tuttavia, c‚Äô√® un rischio che se tutto √® collegato a tutto, pu√≤ diventare difficile capire dove si √® e dove si sta andando. Serve dunque una forte coerenza visiva, una buona architettura dell‚Äôinformazione e magari qualche aiuto visivo come breadcrumb o menu ben organizzati.</p>
<p><img alt="A simple 3D gray humanoid figure stands on an orange path, scratching its head in a puzzled pose. The path splits into several orange arrows pointing in different directions against a white background, visually representing indecision, choices, or multiple possible directions." src="./Android_images/image_028.png" /><strong>Multilevel NavigationS</strong>i basa su una struttura gerarchica dei contenuti, dividendolo in categorie</p>
<p>Aiuta l‚Äôutente a <strong>orientarsi</strong> e a trovare ci√≤ che cerca seguendo un percorso logico per√≤ troppi livelli possono diventare dispersivi, quindi √® bene non esagerare con la profondit√† della struttura.</p>
<p><strong>Step-by-Step Flows</strong> Utilizzati per guidare l‚Äôutente in un processo lineare, come una registrazione, un acquisto online, o la configurazione di un profilo. Semplifica l‚Äôinterazione perch√© ogni passo √® chiaro, focalizzato, e l‚Äôutente sa sempre cosa deve fare. L'importante √® rendere visibile il progresso, con indicatori e consentire di tornare indietro senza perdere i dati inseriti.</p>
<p><img alt="A schematic labeled &quot;The fully connected model&quot; showing six rectangular nodes (one at the top is shaded darker) arranged roughly in a hexagon. Directed arrows connect every pair of nodes (including bidirectional arrows on adjacent nodes and crisscross/star-shaped arrows between nonadjacent nodes), illustrating a fully connected directed network." src="./Android_images/image_029.png" /></p>
<p><img alt="A grayscale diagram of a multilevel navigation hierarchy: a single dark top node centered at the top connects horizontally to four lighter second-level nodes. Each second-level node has one or more subordinate nodes stacked beneath it with arrows showing downward navigation (one column has three levels). Caption reads &quot;Figure 3-3. Multilevel navigation.&quot;" src="./Android_images/image_030.png" /><strong>Pyramidal Model</strong> SI parte da un‚Äôinformazione generale e consente all‚Äôutente di esplorare via via contenuti sempre pi√π specifici. Funziona bene quando si vuole <strong>gestire l‚Äôattenzione</strong> dell‚Äôutente e accompagnarlo in una lettura a livelli, senza sommergerlo subito di dettagli.</p>
<p><img alt="- Horizontal row of five rounded rectangles (four light gray, the rightmost one dark gray). - Solid right-pointing arrows connect each rectangle to the next, indicating forward progression. - Dashed (dotted) left-pointing arrows under the solid arrows show return/review flows to earlier steps. - Caption below reads: &quot;Figure 3‚Äì4. Step-by-step flows.&quot;" src="./Android_images/image_031.png" /><strong>Deep Link</strong> A volte non si parte dalla cima ma ci si ritrova direttamente ‚Äúall‚Äôinterno‚Äù dell‚Äôapp, grazie a un <strong>deep link</strong>, cio√® un collegamento diretto a una pagina interna. Devono essere progettati con cura, perch√© l‚Äôutente che ci arriva potrebbe <strong>non avere il contesto</strong>: √® quindi importante che la pagina sia autonoma, comprensibile da sola.</p>
<p><img alt="A simple diagram labeled &quot;Figure 3‚Äì5. Pyramid&quot;: - One dark rectangle at the top (a single apex node). - Five lighter rectangles in a horizontal row beneath it (a lower tier). - Single-headed arrows from the top rectangle pointing down to each of the five lower rectangles (one-to-many/top-down relationships). - Double-headed arrows between each adjacent pair of lower rectangles (peer-to-peer lateral connections)." src="./Android_images/image_032.png" /><strong>Clear Entry Point</strong> Cio√® una porta d‚Äôingresso ben visibile e comprensibile per l‚Äôutente. Appena apre l‚Äôapp o il sito, l‚Äôutente deve capire cosa pu√≤ fare, dove pu√≤ andare e quali sono le opzioni principali.Questo vale soprattutto per esperienze nuove o complesse, dove una schermata iniziale troppo carica o confusa rischia di scoraggiare. Meglio semplificare, dare una direzione e lasciare che il resto venga scoperto poco alla volta.</p>
<p><strong>Hub and Spoke</strong> L‚Äôutente parte da un <strong>hub</strong> e da l√¨ pu√≤ accedere a diverse <strong>spoke</strong>, sezioni o attivit√† isolate. Una volta completata un‚Äôattivit√†, torna all‚Äôhub per decidere cosa fare dopo.</p>
<p>Questo approccio √® utile quando si vuole <strong>mantenere un senso di controllo</strong> e di orientamento.</p>
<h2 id="rendering-pipeline"><strong>RENDERING PIPELINE</strong></h2>
<p>Il processo di rendering √® sincronizzato con il segnale <strong>VSync</strong> (<strong>vertical synchronization</strong>) generato dall'hardware del display scandendo il ritmo del rendering, sincronizzando ogni frame con il refresh dello schermo. Android sfrutta questo segnale per organizzare il lavoro su tre livelli principali:</p>
<ol>
<li>UI Thread</li>
<li>RenderThread</li>
<li>Graphics Pipeline.</li>
</ol>
<p>Il <strong>UI Thread</strong>, √® responsabile della gestione degli eventi di input, dell‚Äôaggiornamento dell‚Äôinterfaccia e delle animazioni. Quando il sistema riceve un segnale di <strong>VSync</strong>, il <strong>Choreographer</strong>, un componente di Android che orchestra il rendering, sveglia il UI Thread, che esegue una serie di operazioni:</p>
<ol>
<li>Input Handling ‚Üí Il primo compito √® elaborare gli input dell‚Äôutente, come tocchi, scroll o gesti. Se premiamo un pulsante, il sistema deve registrare l‚Äôevento e prepararsi a cambiare la UI.</li>
<li>Animations ‚Üí Se ci sono animazioni in corso (ad esempio, un pulsante che si ingrandisce quando viene premuto), vengono aggiornate e interpolate. Android calcola la nuova posizione, opacit√† o dimensione dell‚Äôelemento animato.</li>
<li>Measure e Layout ‚Üí Ora il sistema deve capire quanto spazio occupano le View e dove devono essere posizionate. Questo processo avviene in due fasi:
    <strong>Measure</strong> ‚Üí Ogni View calcola la propria dimensione basandosi sui suoi genitori e sul contenuto.
    <strong>Layout</strong> ‚Üí Una volta note le dimensioni, le View vengono posizionate nella finestra dell‚Äôapp.</li>
<li>Draw ‚Üí Dopo aver determinato le posizioni e le dimensioni delle View, il sistema esegue il disegno vero e proprio. Questo avviene nel metodo onDraw(Canvas canvas), che dipinge gli elementi grafici sullo schermo.</li>
<li>Sync ‚Üí Infine, il UI Thread invia i dati al RenderThread, il quale si occuper√† di trasformarli in qualcosa che la GPU pu√≤ elaborare.</li>
</ol>
<p>Se una propriet√† di una view cambia in modo da influire sul suo aspetto viene chiamato il metodo <strong>invalidate()</strong> sulla vista. Questa chiamata non causa un redraw immediato, ma marca la vista come "sporca" e segnala che deve essere ridisegnata. Una volta chiamato invalidate() su una vista, questa chiamata si propaga <strong>verso l'alto nella gerarchia delle viste</strong>, chiamando una serie di metodi, come <strong>invalidateChild()</strong>, sui suoi parent.</p>
<p>Questo processo continua fino a raggiungere la radice della gerarchia delle viste, in particolare la <strong>ViewRootImpl</strong>.</p>
<p>Quando la dimensione o la posizione di una vista deve cambiare viene chiamato <strong>requestLayout()</strong>. Questo √® simile all'invalidazione, ma innesca un processo di misurazione e layout per determinare le nuove dimensioni e posizioni delle viste coinvolte.</p>
<p>Quando la chiamata invalidateChild() raggiunge il <strong>ViewRootImpl</strong>, quest'ultimo non esegue immediatamente il ridisegno ma chiama il metodo <strong>scheduleTraversals()</strong> con cui pianifica l'esecuzione del processo di <strong>traversal</strong> (misurazione, layout e disegno) in un momento successivo, tipicamente in sincronia con il prossimo segnale VSync gestito dal Coreoghaph.</p>
<p>Per ottimizzare questo processo, Android utilizza un meccanismo chiamato <strong>Display List</strong>. Quando viene chiamato draw(), la vista (o i suoi antenati) ottiene (o rigenera) una <strong>display list</strong> tramite il metodo <strong>getDisplayList()</strong>. Una <strong>display list</strong> √® una registrazione di tutte le operazioni di disegno (ad esempio, drawBackground(), drawText()) che la vista deve eseguire per rendersi. L'intera gerarchia delle viste √® rappresentata da una gerarchia di display list.</p>
<p>Dopo che l'UI thread ha completato il traversal (misura, layout e disegno) e ha generato la gerarchia delle <strong>Display List</strong>, queste informazioni vengono sincronizzate con il <strong>Render Thread</strong>.</p>
<p>Per evitare di sovraccaricare il <strong>UI Thread</strong>, Android introduce il <strong>RenderThread</strong>, un thread separato che gestisce il disegno e l‚Äôinvio dei comandi alla GPU.</p>
<p>Una volta che il <strong>UI Thread</strong> ha terminato il suo lavoro, il <strong>RenderThread</strong> prende in carico il frame e segue questi passaggi:</p>
<ol>
<li>Sync ‚Üí Riceve i dati dal UI Thread e li sincronizza con lo stato attuale della grafica.</li>
<li>Execute ‚Üí Processa i comandi di rendering, preparando la scena da inviare alla GPU.</li>
<li>Get Buffer ‚Üí Recupera un buffer di rendering, ovvero un‚Äôarea di memoria in cui verr√† disegnato il frame.</li>
<li>Issue ‚Üí Converte i comandi in istruzioni per la GPU.</li>
<li>Swap Buffer ‚Üí Una volta che tutto √® pronto, il RenderThread invia il frame alla GPU e chiede il prossimo buffer per il frame successivo.</li>
</ol>
<p>Il Render Thread prende queste Display List, che sono una rappresentazione delle operazioni di disegno a livello Java, e le trasforma in qualcosa che pu√≤ effettivamente elaborare per la GPU. Queste rappresentazioni native delle operazioni di disegno sono chiamate <strong>Display List Operations (DL ops)</strong>.</p>
<p>Le DL ops sono quindi la forma in cui le intenzioni di disegno dell'applicazione, espresse tramite le API Canvas a livello Java, vengono tradotte in operazioni concrete che il Render Thread pu√≤ ottimizzare e inviare alla GPU.</p>
<p>Un esempio di DL op √® una <strong>fill operation</strong> che corrisponde all'operazione di riempire una determinata area con un colore. Altre DL ops rappresenterebbero il disegno di testo, linee, bitmap, ecc..</p>
<p>In sostanza, le DL ops sono un intermediario tra la rappresentazione astratta del disegno (Display List) e i comandi concreti inviati alla GPU.</p>
<p>Le DL ops vengono ottimizzate tramite <strong>riordinamento (reordering)</strong> delle operazioni di disegno.</p>
<p>L'obiettivo del riordinamento √® di raggruppare operazioni di disegno simili che non si sovrappongono per minimizzare i <strong>cambi di stato</strong> della GPU, che sono operazioni molto costose in termini di prestazioni.</p>
<p>Attraverso il riordinamento, il Render Thread analizza le DL ops e, se possibile, le raggruppa. Quindi, tutte le operazioni di disegno dei rettangoli verrebbero eseguite insieme, seguite da tutte le operazioni di disegno del testo. In alcuni casi, operazioni simili possono anche essere <strong>batching (raggruppate)</strong> ulteriormente in una singola chiamata alla GPU per maggiore efficienza.</p>
<p>Questa ottimizzazione pu√≤ portare a <strong>miglioramenti significativi nelle prestazioni del rendering</strong>, specialmente in scenari con molte operazioni di disegno simili, come ad esempio nel rendering di liste complesse.</p>
<p>Il riordinamento non pu√≤ essere applicato se le operazioni di disegno si sovrappongono, poich√© in tal caso l'ordine √® cruciale per rispettare il blending e l'alpha blending.</p>
<p>A questo punto, entra in gioco la <strong>Graphics Pipeline</strong>, ovvero la parte hardware responsabile del rendering finale. Il suo compito √® prendere i comandi ricevuti dal <strong>RenderThread</strong> e trasformarli in pixel sullo schermo.</p>
<ol>
<li>Get Buffer ‚Üí La GPU recupera il buffer con i dati da disegnare.</li>
<li>Swap Buffer ‚Üí Il buffer contenente il nuovo frame viene inviato allo schermo.</li>
<li>Composite ‚Üí Infine, la GPU compone il frame con altri layer grafici e lo mostra all‚Äôutente.</li>
</ol>
<p>A questo punto interviene il <strong>SurfaceFlinger</strong> √® un servizio di sistema responsabile della composizione di tutti i <strong>window</strong> (finestre) visibili sullo schermo.</p>
<p>Ogni finestra ha associata una <strong>BufferQueue</strong>, una coda di buffer grafici dove risiedono i dati pixel prodotti dall'applicazione (o da altri servizi di sistema). La BufferQueue ha due estremit√†: un produttore, il <strong>Window Manager</strong> che inserisce i buffer nella coda e un consumatore, l‚Äô<strong>Activity</strong> <strong>Manager</strong> che li preleva.</p>
<p>Quando il render thread chiama swapBuffers, accodando nel queue buffer il buffer renderizzato nella BufferQueue. SurfaceFlinger acquisisce questi buffer pronti per essere composti.</p>
<p>SurfaceFlinger comunica con l'<strong>Hardware Composer (HWC)</strong>, che √® un'astrazione hardware specifica del dispositivo in grado di comporre pi√π layer (bitmap) in modo molto efficiente, spesso senza utilizzare la GPU, per risparmiare energia. L'HWC decide come gestire ciascun layer:</p>
<ul>
<li>Se l'HWC supporta il formato pixel del layer e non ci sono troppe trasformazioni complesse, pu√≤ gestirlo come un overlay, componendolo direttamente sull'hardware.</li>
<li>In alcuni casi, l'HWC potrebbe non essere in grado di gestire un layer come overlay, allora il SurfaceFlinger deve utilizzare la GPU per comporre questi layer in un frame buffer (un buffer di rendering temporaneo) tramite comandi OpenGL, un'API utilizzata in Android per il rendering 2D e 3D.</li>
</ul>
<p>Indipendentemente dal fatto che la composizione avvenga tramite HWC o GPU, SurfaceFlinger combina tutti i layer visibili (le finestre di tutte le applicazioni, la barra di stato, la barra di navigazione) e invia il risultato all'hardware del display per essere visualizzato.</p>
<h1 id="architectural-ui-and-data-management-patterns"><strong>ARCHITECTURAL UI AND DATA MANAGEMENT PATTERNS</strong></h1>
<p>Prima ancora di scrivere codice, √® importante <strong>definire l‚Äôarchitettura del sistema</strong>. Progettare l‚Äôarchitettura in anticipo permette di avere una visionechiara di come sar√† strutturata l‚Äôapplicazione, come interagiranno i diversi componenti tra loro e quali saranno le dipendenze principali.</p>
<p>Questo ha un impatto diretto sulla qualit√† del progetto nel lungo periodo. Se in futuro sar√† necessario apportare modifiche, aggiungere funzionalit√†, sostituire una tecnologia, risolvere bug o adattarsi a nuove esigenze‚Ä¶ avere un‚Äôarchitettura solida e ben pensata render√† tutto pi√π semplice, veloce e sicuro.</p>
<p>√à necessario strutturare il sistema in modo che sia indipendente dai framework, librerie e linguaggi che usiamo perch√© cambiano nel tempo: nuove versioni, nuove API, a volte addirittura vengono abbandonati o sostituiti da soluzioni migliori. Se il nostro sistema dipende troppo da queste tecnologie, ogni cambiamento porta ad errori o riscritture pesanti del codice.</p>
<p>a <strong>modularit√†</strong> √® uno dei concetti pi√π importanti. Significa <strong>suddividere un sistema in parti indipendenti e riutilizzabili</strong>, chiamate moduli o componenti, ognuno dei quali ha una responsabilit√† chiara e ben definita.</p>
<p>Conviene pensare alla <strong>modularit√†</strong> cio√® dividere il codice in moduli in modo che sia pi√π semplice da capire, da testare, da manutenere e da evolvere. Ogni modulo pu√≤ essere sviluppato (e perfino sostituito) senza dover riscrivere tutto il resto. Dobbiamo fare attenzione alle <strong>dipendenze circolari</strong> che si verificano quando due (o pi√π) moduli dipendono l‚Äôuno dall‚Äôaltro direttamente o indirettamente. Questo crea una <strong>situazione di interdipendenza</strong>, dove nessuno dei moduli pu√≤ essere isolato, testato o riutilizzato in modo indipendente.</p>
<p>Il principio che si trova alla base di ogni pattern architetturale √® la <strong>separazione dei problemi</strong> in livelli in modo da avere le dipendenze verso un‚Äôunica direzione ed evitare le dipendenze circolari. I vari livelli non devono avere riferimenti ai livelli pi√π esterni di loro, questo violerebbe la modularit√† e renderebbe quindi i livelli dipendenti fra loro.</p>
<h2 id="clean-archicture"><strong>CLEAN ARCHICTURE</strong></h2>
<p>La <strong>Clean Architecture</strong> mira a creare sistemi <strong>intercambiabili</strong> con una forte <strong>separazione delle preoccupazioni</strong> e un <strong>accoppiamento debole</strong> tra i livelli.</p>
<p>L'idea fondamentale di Clean Architecture, concepita da Robert Martin (Uncle Bob), √® rendere <strong>intercambiabile</strong> ogni elemento all'interno di un certo confine architetturale, senza richiedere modifiche nei livelli sottostanti.</p>
<p>Le dipendenze del codice sorgente possono puntare solo verso l'interno. Questo significa che i livelli interni non devono dipendere da livelli. Questa direzione delle dipendenze √® fondamentale per ottenere un basso accoppiamento e facilitare il test e la manutenzione.</p>
<p>La Clean Architecture divide un'applicazione in diversi livelli con responsabilit√† distinte:</p>
<ol>
<li>Domain/Application Core: Contiene le entit√† e la logica di business dell'applicazione. Questo livello √® indipendente da qualsiasi framework o dettaglio di implementazione esterna.</li>
<li>Use Cases: Il software in questo livello contiene regole aziendali specifiche dell'applicazione ed incapsula e implementa tutti i casi d'uso del sistema. Questi casi d'uso orchestrano il flusso di dati da e verso le entit√† e indirizzano tali entit√† per raggiungere gli obiettivi del caso d'uso. I cambiamenti in questo livello non devono influenzare le entit√† e questo livello non √® influenzato da modifiche alle componenti esterne come il database, l'interfaccia utente o qualsiasi framework utilizzato. Questo strato √® isolato da tali problematiche. Tuttavia, modifiche alle funzioni di dominio dell'applicazione influenzeranno i casi d'uso e quindi il software in questo livello.</li>
<li>Infrastructure/Frameworks: Contiene i dettagli di implementazione dei sistemi esterni, come database, framework UI, librerie esterne e API. Le implementazioni delle interfacce definite nel livello Application risiedono qui.</li>
<li>Interface Adapters: Questo livello funge da ponte tra i livelli Application e Infrastructure. Contiene adapter, presentatori e controller che convertono i dati da un formato all'altro per soddisfare le esigenze dei diversi livelli.</li>
<li>API/UI: Il livello pi√π esterno che presenta l'applicazione all'utente (tramite un'API web o un'interfaccia utente grafica).</li>
</ol>
<p><strong><img alt="A simple diagram of a &quot;hub-and-spoke&quot; architecture: - A dark central rectangle (the hub) in the middle. - Five lighter rectangles arranged around it (the spokes): top, top-left, top-right, bottom-left, bottom-right. - Arrows between each outer rectangle and the central rectangle indicating connections/communication. - Caption beneath: &quot;Figure 3‚Äë1. Hub and spoke architecture.&quot;" src="./Android_images/image_034.png" /></strong></p>
<p>Per attraversare i confini (cerchi concentrici) si usano i controller e i Presenter che comunicano con i casi d'uso nel livello successivo.</p>
<ol>
<li>l'esecuzione inizia nel controller</li>
<li>si sposta attraverso il caso d'uso</li>
<li>finisce per essere eseguito nel presenter.</li>
</ol>
<p>Per implementare questa logica si utilizza il <strong>principio di inversione delle dipendenze</strong> che consente ad A di chiamare metodi su un'astrazione implementata da B, rendendo possibile per A chiamare B in fase di esecuzione, ma per B di dipendere da un'interfaccia controllata da A in fase di compilazione (invertendo cos√¨ la tipica dipendenza in fase di compilazione). In fase di esecuzione, il flusso di esecuzione del programma rimane invariato, ma l'introduzione di interfacce significa che diverse implementazioni di queste interfacce possono essere facilmente collegate. La stessa tecnica viene utilizzata per attraversare tutti i confini nelle architetture.</p>
<p>Sfruttiamo il polimorfismo dinamico per creare dipendenze del codice sorgente che si oppongono al flusso di controllo in modo che possiamo rispettare la regola delle dipendenze indipendentemente dalla direzione in cui sta andando il flusso di controllo.</p>
<p><img alt="A simple cartoon/clipart of a smiling man wearing an orange hard hat, brown suit, white shirt and blue tie. He holds a laptop in one hand and waves with the other; the style is flat, friendly, on a plain white background." src="./Android_images/image_035.png" /></p>
<p>Il <strong>Repository Pattern</strong> √® spesso integrato in Clean Architecture come un meccanismo per <strong>astrarre l'accesso ai dati</strong>. L'interfaccia del repository √® definita nel livello Application, mentre l'implementazione concreta che interagisce con il database si trova nel livello Infrastructure. Questo rispetta la regola della dipendenza, poich√© il livello Application dipende solo dall'interfaccia del repository, non dalla specifica implementazione del database.</p>
<p>La separazione dei livelli e la regola della dipendenza rendono le applicazioni Clean Architecture pi√π <strong>facili da testare</strong>. I casi d'uso e la logica di business nel livello Application possono essere testati unitariamente senza dipendere da database o UI. Le interfacce nel livello Application facilitano il <strong>mocking</strong> delle dipendenze esterne durante i test. L'accoppiamento debole tra i livelli rende le applicazioni Clean Architecture pi√π <strong>scalabili e manutenibili</strong>. Le modifiche a un livello hanno meno probabilit√† di influenzare altri livelli, facilitando l'aggiornamento e l'aggiunta di nuove funzionalit√†.</p>
<p>I ViewModel spesso interagiscono con un <strong>Repository</strong> per l'accesso ai dati. Questa struttura (UI - ViewModel - Repository - Data Source) in Android pu√≤ essere vista come un'implementazione pratica di alcuni principi di Clean Architecture, in particolare la separazione delle preoccupazioni e l'astrazione dell'accesso ai dati.</p>
<p>Una potenziale violazione della regola della dipendenza in Clean Architecture quando si implementa il Repository pattern utilizzando direttamente un ORM (come Entity Framework Core) nel livello Infrastructure. Questo introduce una dipendenza del livello Interface Adapters (dove si troverebbe l'implementazione del repository) verso un framework esterno e verso l'I/O diretto, violando la dipendenza verso l'interno. Per risolvere questo, si suggerisce di spostare l'implementazione del repository nel livello Frameworks/Infrastructure e di definire le interfacce nel livello Application.</p>
<h2 id="livedata"><strong>LIVEDATA</strong></h2>
<p>LiveData √® una classe di dati <strong>osservabile</strong> che √® legata al ciclo di vita dei componenti UI, come <strong>Activity</strong> o <strong>Fragment</strong>. Questo significa che <strong>LiveData</strong> permette di aggiornare la UI automaticamente quando i dati cambiano, ma solo quando la UI √® in uno stato attivo, evitando aggiornamenti inutili o errori quando la UI non √® visibile (ad esempio, se l'<strong>Activity</strong> √® in background). Implementa il pattern Observer.</p>
<h2 id="room"><strong>ROOM</strong></h2>
<p>Room √® una libreria di persistenza fornita da Google che si colloca all'interno dei componenti dell'architettura Android, con l'obiettivo di semplificare l'interazione con il database <strong>SQLite</strong> del sistema operativo, fornendo un <strong>livello di astrazione</strong>.</p>
<p>Room √® descritta come un modo efficace per creare database e salvare dati. Fornisce un accesso al database SQLite <strong>mappando oggetto-relazionale (ORM)</strong> basato su annotazioni.</p>
<p>L'utilizzo di Room si articola principalmente su tre tipi di classi:</p>
<ul>
<li>Entit√†: Sono Plain Old Java Objects (POJO) che modellano i dati da trasferire verso e dal database. Sono annotate con @Entity, specificando la tabella del database a cui corrispondono. Almeno una propriet√† deve essere designata come chiave primaria usando l'annotazione @PrimaryKey. Room crea una tabella nel database per ogni entit√†.</li>
<li>DAOs - Data Access Objects: Definiscono l'API per interagire con i dati, contenendo metodi per operazioni come query, inserimenti, aggiornamenti ed eliminazioni. I DAOs sono interfacce o classi astratte annotate con @Dao. Le operazioni sul database sono definite all'interno dei metodi del DAO tramite annotazioni come @Query, @Insert, @Update e @Delete. Room genera l'implementazione concreta di queste interfacce o classi astratte in fase di compilazione.</li>
<li>Database: Rappresenta l'interfaccia principale al database SQLite sottostante. √à una classe astratta che estende RoomDatabase ed √® annotata con @Database, elencando tutte le entit√† utilizzate dal database e la sua versione. Contiene metodi astratti che restituiscono istanze dei DAO. Si ottiene un'istanza del database tramite un RoomDatabase.Builder.</li>
<li>Relazioni tra Entit√†: Sebbene Room supporti relazioni tramite chiavi esterne definite con l'annotazione @ForeignKey, non supporta riferimenti diretti tra entit√†. Per rappresentare relazioni uno-a-molti o molti-a-molti e accedere agli oggetti correlati, si utilizza l'annotazione @Relation all'interno di una classe POJO separata che contiene i campi per le entit√† correlate. Per le relazioni molti-a-molti √® necessario implementare una "join entity" che crea la tabella di join associata.</li>
</ul>
<p><img alt="Image: a diagram of &quot;The Clean Architecture.&quot; - Four concentric colored rings with inward dependency rule: - Center (yellow): &quot;Entities&quot; ‚Äî Enterprise business rules. - Next (red): &quot;Use Cases&quot; ‚Äî Application business rules. - Next (green): &quot;Controllers / Presenters / Gateways&quot; ‚Äî Interface adapters. - Outer (blue): &quot;Devices / Web / UI / DB / External Interfaces&quot; ‚Äî Frameworks &amp; drivers. - Arrows pointing inward showing that outer layers depend on inner layers, not vice versa. - Legend mapping colors to layer types. - Small flow diagram at right: Controller ‚Üí Use Case Input Port ‚Üí Use Case Interactor ‚Üí Use Case Output Port ‚Üí Presenter, with a &quot;Flow of control&quot; arrow indicated." src="./Android_images/image_036.png" /></p>
<p>In Room, le <strong>entit√† sono pensate pi√π come Data Transfer Objects (DTO)</strong> oggetti concepiti come un <strong>mezzo per trasferire dati</strong> tra diversi punti di un'applicazione. Modellano una risposta o sono ottimizzati per la creazione e la persistenza dei dati. Le Entity in Room rappresentano i dati che si desidera memorizzare nel database e sono anche l'unit√† tipica di un set di risultati recuperato dal database</p>
<p><img alt="The diagram shows two views of the same design: &quot;Compile Time&quot; (left) and &quot;Run Time&quot; (right). - Compile Time (left): a dashed box containing Class A (blue) that holds references to Interface B (gray). Interface B points to Class B (green) as its implementation/reference. Similarly, Interface C (gray) points to Class C (purple). Labels &quot;References&quot; mark the connections ‚Äî the code compiles against interfaces, and concrete classes are referenced indirectly. - Run Time (right): a dashed box showing control flow. Class A (blue) calls into Interface B which at runtime is bound to Class B (gray/green stacked). Control flow continues from Class B into Interface C bound to Class C (gray/purple stacked). Labels &quot;Control Flow&quot; indicate actual runtime linking of interface to implementation." src="./Android_images/image_037.png" /></p>
<p>Room pu√≤ essere integrato con <strong>LiveData</strong> per <strong>osservare i cambiamenti nel database</strong>. Un DAO pu√≤ restituire un oggetto <strong>LiveData</strong> da una query, consentendo all'interfaccia utente di aggiornarsi automaticamente quando i dati sottostanti cambiano.</p>
<p>Room si integra bene con <strong>ViewModel</strong>, che gestisce i dati relativi alla View in modo indipendente dai cambiamenti di configurazione. Il ViewModel pu√≤ interagire con il database tramite un repository che utilizza Room.</p>
<p>√à una buona pratica utilizzare il <strong>pattern Repository</strong> come livello intermedio tra Room e il resto dell'applicazione. Questo permette di <strong>astrarre l'accesso ai dati</strong> e, se in futuro vorrai cambiare il tipo di persistenza (ad esempio passare da Room a una sorgente di rete o cache), potrai farlo <strong>senza modificare</strong> i ViewModel o altri componenti della business logic.</p>
<h2 id="mvc"><strong>MVC</strong></h2>
<p>Il <strong>[[MVC]] Model View Controller</strong> √® un modo per organizzare le funzionalit√† di un'applicazione separando gli oggetti in tre ruoli distinti:</p>
<p><img alt="Diagram of how a Room database is used in an app: - Top: &quot;Room Database&quot; (blue rounded box). - Middle left: &quot;Data Access Objects&quot; (DAOs, green). - Arrow to/from Room Database: DAOs fetch entities from the DB and persist changes back to it. - Arrow from the app into DAOs: &quot;Get DAO&quot;. - Middle right: &quot;Entities&quot; (red). - DAOs return Entities to the app; the app reads/writes entity fields (&quot;get / set field values&quot;). - Bottom: &quot;Rest of The App&quot; (gray). - The app obtains DAOs, receives Entities, and manipulates entity fields; persistence flows through DAOs to the Room Database." src="./Android_images/image_038.png" /></p>
<p><img alt="- A layered architecture diagram showing how data flows from client DTOs through service and DAO layers into the database. - Left: blue &quot;DTO&quot; circles feed into a blue &quot;Service Implementation&quot; box that exposes operations like &quot;findBy...&quot; and &quot;create&quot;. - Middle: orange &quot;Bean&quot; nodes connect the service layer to a red &quot;DAO Implementation&quot; box that provides &quot;findByCriteria&quot;, &quot;create&quot;, &quot;update&quot;, &quot;delete&quot;. - Right: a cylindrical &quot;Database&quot; with a &quot;Table&quot; receives CRUD requests from the DAO. - Arrows illustrate call flow: DTO ‚Üí Service ‚Üí Bean ‚Üí DAO ‚Üí Database (and results flow back the same path)." src="./Android_images/image_039.png" />Gli oggetti del modello non hanno alcuna conoscenza dell'interfaccia utente (UI). Il loro unico scopo √® la gestione e la detenzione dei dati.</p>
<p><strong>Model</strong> Il modello contiene i dati dell'applicazione e la logica di business.Le classi del modello sono progettate per rappresentare le entit√† con cui l'app lavora, come una domanda vero/falso. In Android, il livello del modello √® generalmente costituito da classi personalizzate create dallo sviluppatore. Il modello pu√≤ anche specificare la struttura dei dati dell'app e il codice per accedervi e manipolarli.</p>
<p><strong>View</strong> La vista √® responsabile della visualizzazione dei dati all'utente e della risposta alle azioni dell'utente. Ogni elemento visibile sullo schermo √® una vista. Android fornisce molteplici tipi di viste. Le viste sanno come disegnarsi sullo schermo e come rispondere all'input dell'utente, come i tocchi.</p>
<p><strong>Controller</strong> Il controllore agisce come un intermediario tra il modello e la vista. Contiene la logica dell'applicazione .I controllori rispondono agli eventi innescati dalle viste e gestiscono il flusso di dati da e verso il modello e la vista. In Android, un controllore √® tipicamente una sottoclasse di Activity, Fragment o Service.</p>
<p>√à importante notare che il modello e la vista non comunicano direttamente. Il controllore si trova al centro, ricevendo messaggi da un lato e inviando istruzioni all'altro.</p>
<h3 id="benefici-dellmvc"><strong>Benefici dell'MVC</strong></h3>
<ul>
<li>Separazione delle responsabilit√†: Aiuta a progettare e comprendere l'applicazione come un insieme di classi distinte.</li>
<li>Migliore organizzazione del codice: La separazione in livelli (modello, vista, controllore) facilita la progettazione e la comprensione dell'applicazione a un livello superiore.</li>
<li>Riutilizzabilit√† del codice: Le classi con responsabilit√† limitate sono pi√π riutilizzabili.</li>
</ul>
<h3 id="observer-synchronization"><strong>Observer Synchronization</strong></h3>
<p>Questo approccio, strettamente associato all'MVC, si basa sul concetto che <strong>le viste e i controllori osservano il modello</strong>.</p>
<p>Quando il <strong>modello subisce una modifica</strong>, viene notificato a tutti i suoi osservatori (le viste e potenzialmente i controllori).</p>
<p>Le <strong>viste reagiscono a queste notifiche</strong> aggiornando la propria visualizzazione in base ai nuovi dati del modello.</p>
<p>Il <strong>controllore</strong>, in questo modello, √® <strong>relativamente "ignorante"</strong> di quali altre viste potrebbero aver bisogno di essere aggiornate quando l'utente interagisce con una specifica vista. Il controllore si limita a modificare il modello, lasciando che il meccanismo di osservazione si occupi di propagare i cambiamenti alle viste interessate.</p>
<h3 id="flow-synchronization"><strong>Flow Synchronization</strong></h3>
<p>Nella sincronizzazione tramite flusso, √® l'applicazione (spesso il controllore) che manipola direttamente le viste per riflettere i cambiamenti nel modello. Ad esempio, quando si apre una schermata o si preme un pulsante di salvataggio, il codice dell'applicazione si occupa di aggiornare esplicitamente i vari controlli (viste) con i dati del modello. In questo caso, il form (o l'attivit√†/il fragment in Android) deve tenere traccia di quali controlli devono essere aggiornati in seguito a un cambiamento, il che pu√≤ diventare complesso in schermate elaborate.</p>
<h2 id="mvvm"><strong>MVVM</strong></h2>
<p><img alt="- A schematic of the Model‚ÄìView‚ÄìController (MVC) design pattern. - Three main boxes: - Controller (blue, top) ‚Äî labeled ‚ÄúMediator‚Äù. - View (green, left) ‚Äî inside a dotted ‚ÄúUI‚Äù oval. - Model (orange, right) ‚Äî inside a dotted ‚ÄúData‚Äù oval. - Labeled interactions (arrows): - ‚ÄúUser action‚Äù from View ‚Üí Controller. - ‚ÄúUpdate‚Äù from Controller ‚Üí Model. - ‚ÄúNotify‚Äù from Model ‚Üí Controller. - ‚ÄúUpdate‚Äù from Model ‚Üí View. - Overall: the controller mediates user actions, updates the model; the model notifies the controller and/or pushes updates to the view, and the view renders the UI." src="./Android_images/image_040.png" />Il pattern <strong>MVVM Model-View-ViewModel</strong> permette una gestione pi√π fluida della UI e una separazione pi√π chiara tra la logica di business e l'interfaccia utente.</p>
<p>Il pattern MVVM √® composto da tre componenti principali:</p>
<ol>
<li>Model</li>
<li>View</li>
<li>ViewModel che da intermediario tra la View e il Model. √à responsabile della gestione dei dati da visualizzare nella UI e dell'elaborazione della logica necessaria per presentarli. La ViewModel fornisce i dati alla View tramite LiveData, che consente di osservare i cambiamenti dei dati e aggiornare automaticamente la UI quando necessario. La ViewModel non ha conoscenza diretta della View. Comunica con il Model per recuperare i dati e li prepara in una forma che la View pu√≤ facilmente consumare.</li>
</ol>
<h3 id="interazione-tra-i-componenti-nel-pattern-mvvm"><strong>Interazione tra i componenti nel pattern MVVM</strong></h3>
<ol>
<li>L'utente interagisce con la View (ad esempio, tocca un pulsante).</li>
<li>La View invia un'azione al ViewModel (ad esempio, invoca un metodo che cambia i dati).</li>
<li>Il ViewModel interagisce con il Model per recuperare o modificare i dati. In caso di operazioni asincrone, il ViewModel gestisce il flusso di lavoro.</li>
<li>Quando il Model restituisce i dati (ad esempio tramite una chiamata API), il ViewModel li prepara (ad esempio, li converte in un formato adatto alla visualizzazione).</li>
<li>Il ViewModel aggiorna un LiveData, che √® osservato dalla View.</li>
<li>La View riceve i nuovi dati tramite LiveData e aggiorna automaticamente l'interfaccia utente.</li>
</ol>
<p>In questo modo, ogni componente ha un compito preciso:</p>
<ul>
<li>la UI si concentra solo sulla presentazione e l‚Äôinterazione,</li>
<li>il ViewModel gestisce la logica di visualizzazione,</li>
<li>il Repository coordina l‚Äôaccesso ai dati,</li>
<li>e il livello Model (Room + Retrofit) fornisce le sorgenti dati reali.</li>
</ul>
<h1 id="notifiche"><strong>NOTIFICHE</strong></h1>
<p>Una <strong>notifica</strong> √® un messaggio che un'app visualizza all'utente al di fuori interfaccia utente dell'applicazione. Quando si indica al sistema di emettere una notifica, questa appare per la prima volta all'utente come un'icona nell'area di notifica, sul lato sinistro della barra di stato. Per vedere i dettagli della notifica, l'utente apre il <strong>drawer</strong> di notifica o visualizza la notifica sulla schermata di blocco se il dispositivo √® bloccato. L'area di notifica, la schermata di blocco e il drawer di notifica sono aree controllate dal sistema che l'utente pu√≤ visualizzare in qualsiasi momento.</p>
<p>Le notifiche sono il modo in cui Android consente di visualizzare informazioni al di fuori della propria applicazione. Consentono all'utente di essere avvisato delle informazioni dalle applicazioni installate, anche se non le sta utilizzando al momento. Questo √® particolarmente utile quando nuove informazioni, come email o messaggi, arrivano sul dispositivo in modo <strong>asincrono</strong>. Quando progettiamo le notifiche dobbiamo evitare di disturbare l‚Äôutente per notizie inutile, perch√© l‚Äôutente distraendosi pu√≤ decidere di cancellare l‚Äôapplicazione.</p>
<p>Quando si progettano le notifiche, √® fondamentale ricordare che <strong>interrompono sempre l'utente</strong>. Pertanto, devono essere,:</p>
<h1 id="1-brevi-utilizza-il-minor-numero-possibile-di-parole-sii-conciso-evita-di-irritare-gli-utenti-inviando-troppe-notifiche-o-notifiche-con-contenuti-inutili-o-fastidiosi">1. Brevi: Utilizza il minor numero possibile di parole. Sii conciso. Evita di irritare gli utenti inviando troppe notifiche o notifiche con contenuti inutili o fastidiosi.</h1>
<h1 id="2-tempestive-le-notifiche-devono-apparire-quando-sono-utili-altrimenti-se-arrivano-i-ritardo-potremmo-non-servire-piu">2. Tempestive: Le notifiche devono apparire quando sono utili, altrimenti se arrivano i ritardo potremmo non servire pi√π.</h1>
<h1 id="3-pertinenti-linformazione-deve-essere-utile-per-lutente-notifiche-che-disturbino-inutilmente-lutente-o-che-lo-possono-trarre-in-inganno-posso-partare-la-cancellazione-dellapplicazione">3. Pertinenti: l'informazione deve essere utile per l'utente. Notifiche che disturbino inutilmente l‚Äôutente o che lo possono trarre in inganno posso partare la cancellazione dell‚Äôapplicazione.</h1>
<p>La classe NotificationCompat.Builder permette di creare le notifiche ed √® costruita secondo il pattern Builder. La notifica deve avere:</p>
<ul>
<li>Un ID che la identifica;</li>
<li>Il contesto;</li>
<li>Icona piccola da mostrare nella barra di stato. Questa √® impostata con setSmallIcon().</li>
<li>Titolo mostrato sopra il testo dettagliato. √à impostato con setContentTitle().</li>
<li>Testo dettagliato cio√® il messaggio della notifica, un breve testo che descrive alcuni aspetti importanti √à impostato con setContentText().</li>
</ul>
<p>Questi metodi setter fanno parte della classe Builder e sono costruiti usando l‚Äô<strong>interfaccia fluent</strong> un <strong>modello di progettazione</strong> che permette di scrivere il codice in modo pi√π leggibile e "fluente", simile a un linguaggio naturale, concatenando pi√π metodi attraverso il <strong>method chaining</strong><em>.</em> Quindi tutti i metodi di settaggio della notifica, in questo caso, restituiscono l‚Äôoggetto Builder in modo da apportare pi√π modifiche. Poi alla fine del settaggio si dovr√† invocare un metodo di chiusura per ottenere l‚Äôoggetto.</p>
<p>La notifica pu√≤ essere estesa mostrando pi√π informazioni. Si usano le <strong>viste espanse</strong> nel drawer di notifica</p>
<h1 id="1-notificationcompatbigtextstyle-utilizzata-per-notifiche-di-grande-formato-che-includono-molto-testo">1. NotificationCompat.BigTextStyle: Utilizzata per notifiche di grande formato che includono molto testo.</h1>
<h1 id="2-notificationcompatinboxstyle-utilizzata-per-notifiche-di-grande-formato-che-includono-una-lista-di-fino-a-cinque-stringhe">2. NotificationCompat.InboxStyle: Utilizzata per notifiche di grande formato che includono una lista di fino a cinque stringhe.</h1>
<h1 id="3-notificationcompatbigpicturestyle-utilizzata-per-notifiche-di-grande-formato-che-includono-un-grande-allegato-immagine-puoi-impostare-limmagine-grande-con-bigpicture-e-anche-un-titolo-per-il-contenuto-grande-con-setbigcontenttitle">3. NotificationCompat.BigPictureStyle: Utilizzata per notifiche di grande formato che includono un grande allegato immagine. Puoi impostare l'immagine grande con bigPicture() e anche un titolo per il contenuto grande con setBigContentTitle().</h1>
<h1 id="4-notificationmediastyle-utilizzata-per-notifiche-di-riproduzione-multimediale">4. Notification.MediaStyle: Utilizzata per notifiche di riproduzione multimediale.</h1>
<p>Per applicare uno di questi stili a una notifica, utilizzi il metodo setStyle() sull'oggetto NotificationCompat.Builder. Quindi oltre ad implementare un pattern Builder, ne implementa anche una decorator.</p>
<p>Oltre al contenuto testuale o multimediale aggiuntivo, puoi mostrare pi√π informazioni aggiungendo <strong>azioni</strong> alla notifica che l'utente pu√≤ eseguire sulla notifica stessa, resa disponibile tramite un pulsante di azione. Queste azioni aggiungono funzionalit√† e permettono all'utente di interagire direttamente con la notifica per accedere o manipolare le informazioni.</p>
<p><strong>Pending Intent</strong></p>
<p>Quando usiamo delle notifiche modifichiamo il pattern navigazionale dell‚Äôapplicazione, perch√© per evitare di far percorrere tutta la strada per arrivare al punto di interesse, possiamo permettere all‚Äôutente di cliccare sulla notifica e di essere indirizzato direttamente li. Quindi aggiungiamo dei deep link per arrivare direttamente nelle zone di interesse.</p>
<p>Questo √® realizzato tramite PendingIntent un oggetto che <strong>incapsula un Intent</strong>. Il suo scopo √® permettere a un'altra applicazione o al sistema Android di eseguire un Intent per conto della tua applicazione, in un momento futuro. Questo √® particolarmente utile perch√© garantisce che il sistema possa consegnare l'Intent anche se la tua app non √® in esecuzione nel momento in cui l'utente interagisce con esso.</p>
<p>Quando si crea un PendingIntent si ottiene un <strong>token</strong> che non √® l'Intent stesso, ma una <strong>riferimento o un permesso</strong> mantenuto dal sistema operativo. Quando consegni questo PendingIntent (token) a un altro componente, quel componente pu√≤ utilizzare il token per chiedere al sistema di eseguire l'Intent originale come se fosse stato avviato dalla app che l‚Äôha creato.</p>
<p>I PendingIntent sono comunemente utilizzati in vari scenari in cui un'azione deve essere posticipata o eseguita da un altro componente di sistema o un'altra app per conto della tua:</p>
<ul>
<li>Notifiche: Quando l'utente tocca una notifica, solitamente si vuole che venga avviata un'Activity della tua app. Per fare ci√≤, si incapsula l'Intent che avvia l'Activity in un PendingIntent e lo si imposta sulla notifica usando setContentIntent().</li>
<li>Allarmi: L'AlarmManager pu√≤ attivare un PendingIntent dopo un certo periodo di tempo o a intervalli regolari.</li>
<li>Broadcast: Un PendingIntent pu√≤ incapsulare un Intent da inviare come broadcast,</li>
</ul>
<p>Per creare un'istanza di un PendingIntent, si utilizzano metodi statici appropriati a seconda di come si desidera che l'Intent contenuto venga consegnato:</p>
<ul>
<li>PendingIntent.getActivity(): Per un Intent che dovrebbe essere consegnato usando startActivity(). Si passa un Intent esplicito per l'Activity che si desidera avviare.</li>
<li>PendingIntent.getService(): Per un Intent che dovrebbe essere passato a startService()</li>
<li>PendingIntent.getBroadcast(): Per un Intent broadcast consegnato con sendBroadcast().</li>
</ul>
<p>Ciascuno di questi metodi per creare PendingIntent richiede solitamente i seguenti argomenti:</p>
<h1 id="1-il-contesto-dellapplicazione">1. Il contesto dell'applicazione.</h1>
<h1 id="2-un-codice-di-richiesta-un-id-per-distinguere-i-pendingintent">2. Un codice di richiesta (un ID per distinguere i PendingIntent).</h1>
<h1 id="3-lintent-da-consegnare">3. L'Intent da consegnare.</h1>
<h1 id="4-un-flag-pendingintent-che-determina-come-il-sistema-gestisce-piu-oggetti-pendingintent-dalla-stessa-applicazione">4. Un flag PendingIntent che determina come il sistema gestisce pi√π oggetti PendingIntent dalla stessa applicazione.</h1>
<p>Se richiedi un PendingIntent due volte con gli stessi parametri si ottiene lo stesso oggetto PendingIntent.</p>
<p><strong>Notification Channel</strong></p>
<p>Un altro principio di progettazione √® quello di <strong>dare agli utenti la possibilit√† di scegliere</strong> tramite le impostazioni dell‚Äôapp i tipi di notifiche che desiderano ricevere e come desiderano riceverle. Questo √® possibile realizzarlo a partire dall‚ÄôAPI26 che permette di creare dei <strong>NotificationChannel</strong> per offrire all'utente un maggiore controllo sui tipi di notifiche che riceve dall'applicazione. Quando si crea un canale, si definiscono alcune impostazioni iniziali, ma l'utente pu√≤ personalizzare ciascun canale e decidere come si comporta.</p>
<ul>
<li>Azioni: Un'azione che l'utente pu√≤ intraprendere sulla notifica. L'azione √® resa disponibile tramite un pulsante adiacente al contenuto della notifica. Un'azione utilizza un PendingIntent per completare l'azione. Si aggiunge un'azione usando il metodo addAction() passando l'icona, la stringa del titolo e il PendingIntent da attivare.</li>
<li>Importance</li>
<li>Priorit√†: Influenzano il modo in cui il sistema Android consegner√† la notifica. Le notifiche hanno una priorit√† tra MIN (-2) e MAX (2). Le priorit√† disponibili includono PRIORITY_MAX (critiche/urgenti), PRIORITY_HIGH (comunicazioni importanti come messaggi), PRIORITY_DEFAULT (quelle che non rientrano nelle altre categorie), PRIORITY_LOW (informazioni non urgenti) e PRIORITY_MIN (informazioni di sfondo "nice-to-know"). La priorit√† √® impostata con setPriority(). Sono rimaste pi√π per un fatto di compatibilit√† con le versioni precedenti.</li>
<li>Notifiche continue/Servizi in foreground (setOngoing(), startForeground()): Le notifiche continue non possono essere eliminate dall'utente e devono essere esplicitamente cancellate dall'app. Vengono utilizzate per indicare attivit√† in background con cui l'utente interagisce attivamente (come la riproduzione di musica) o attivit√† che occupano il dispositivo (come download). Per rendere una notifica continua, si imposta setOngoing() su true. Un servizio in foreground richiede che visualizzi una notifica visibile all'utente. Per avviare un servizio in modalit√† foreground e visualizzare la notifica, si utilizza startForegroundService() e startForeground(), passando un ID di notifica univoco e l'oggetto notifica. L'ID intero passato a startForeground() non deve essere 0. Per rimuovere un servizio dal foreground, si chiama stopForeground(), specificando se rimuovere la notifica.</li>
</ul>
<p><strong>Gestione delle notifiche</strong></p>
<p>Il <strong>NotificationManager</strong> √® un <strong>servizio di sistema</strong> utilizzato per <strong>consegnare</strong> o attivare le notifiche. Per ottenere un'istanza del NotificationManager, devi chiamare il metodo getSystemService(), passando la costante NOTIFICATION_SERVICE. Non si dovrebbe mai chiamare questo direttamente, ma usare il NotificationMangerCompact che garantisce anche la retrocomatibilit√† con le versioni precedenti.</p>
<p>La funzione principale del NotificationManager √® quella di <strong>mostrare la notifica all'utente</strong>. Ci√≤ si fa chiamando il metodo notify(). Il metodo notify() richiede due parametri:</p>
<h1 id="1-un-id-di-notifica-un-numero-intero-utilizzato-per-aggiornare-o-annullare-la-notifica-in-seguito-dovrebbe-essere-unico-allinterno-della-tua-applicazione-se-chiami-notify-piu-volte-con-lo-stesso-tag-e-id-sostituira-qualsiasi-notifica-esistente-con-lo-stesso-tag-e-id-questo-e-il-modo-in-cui-puoi-implementare-ad-esempio-una-barra-di-avanzamento-o-altre-visualizzazioni-dinamiche-in-una-notifica">1. Un ID di notifica (un numero intero), utilizzato per aggiornare o annullare la notifica in seguito. Dovrebbe essere unico all'interno della tua applicazione. Se chiami notify() pi√π volte con lo stesso tag e ID, sostituir√† qualsiasi notifica esistente con lo stesso tag e ID. Questo √® il modo in cui puoi implementare, ad esempio, una barra di avanzamento o altre visualizzazioni dinamiche in una notifica.</h1>
<h1 id="2-loggetto-notification-stesso-questo-oggetto-viene-tipicamente-costruito-utilizzando-la-classe-notificationcompatbuilder">2. L'oggetto Notification stesso. Questo oggetto viene tipicamente costruito utilizzando la classe NotificationCompat.Builder.</h1>
<p>A partire dall'API 26 , il NotificationManager √® anche responsabile della gestione dei <strong>canali di notifica</strong>, infatti √® obbligatorio associare la notifica ad un canale. Puoi utilizzare il NotificationManager per controllare se un canale esiste gi√† e, in caso contrario, creare un nuovo oggetto. Questo d√† all'utente un maggiore controllo sui tipi di notifiche che riceve dall'applicazione, poich√© pu√≤ personalizzare le impostazioni per ciascun canale.</p>
<p>Le notifiche rimangono visibili fino a quando non si verifica una delle seguenti condizioni:</p>
<ul>
<li>L'utente le ignora individualmente o tramite "Cancella tutto"</li>
<li>Chiami setAutoCancel(true) sul builder della notifica, in tal caso la notifica scompare quando l'utente ci clicca sopra.</li>
<li>Chiami cancel() per un ID di notifica specifico.</li>
<li>Chiami cancelAll() per far sparire tutte le notifiche che hai emesso.</li>
</ul>
<p><img alt="- Diagram: a simple sequence diagram for the MVC pattern. - Top row: three labeled boxes ‚Äî Controller (orange), Model (purple), View (blue). - Each box has a vertical dashed lifeline descending beneath it. - Message flow (top to bottom): 1. Controller: handleEvent (internal/starting action). 2. Controller ‚Üí Model: updateModel (synchronous message). 3. Model ‚Üí View: update (notifies view). 4. View ‚Üí Model: getData (view requests data). - Arrows connect lifelines to show the call/notification sequence; colors match the participant boxes." src="./Android_images/image_041.png" /><strong>APP SETTING</strong></p>
<p>Le app settings si riferiscono alle <strong>preferenze dell'utente</strong> che consentono di <strong>modificare le caratteristiche e i comportamenti dell'applicazione</strong>. Sono controlli che catturano le preferenze degli utenti che influiscono sulla maggior parte di essi o forniscono supporto critico a una minoranza. Esempi includono l'abilitazione delle notifiche o la frequenza di sincronizzazione dei dati con il cloud. In iOS, concetti simili ("user defaults") sono usati per preferenze come lingua, stile UI o unit√† di misura.</p>
<p>Gli utenti dovrebbero poter navigare alle impostazioni dell'app toccando un'opzione <strong>Settings</strong>. Questa opzione √® solitamente collocata nella <strong>navigazione lateral</strong> o nel <strong>menu opzioni</strong>. Secondo le linee guida di design, l'opzione "Settings" dovrebbe trovarsi al di sotto di tutti gli altri elementi (eccetto Help e Send Feedback) sia nella navigazione laterale che nel menu opzioni.</p>
<p>Le impostazioni sono solitamente accessibili <strong>infrequentemente</strong>, poich√© una volta che l'utente cambia un'impostazione, raramente ha bisogno di modificarla di nuovo. Se un controllo o una preferenza necessita di accesso frequente, √® meglio spostarlo nel menu opzioni della app bar o in un menu di navigazione laterale. √à importante impostare dei <strong>valori di default</strong> per le impostazioni che siano familiari agli utenti e migliorino l'esperienza dell'app. I default dovrebbero rappresentare la scelta pi√π comune, usare meno batteria, comportare il minor rischio per la sicurezza/perdita di dati, e interrompere solo quando importante. Informazioni sull'app come numero di versione o licenze dovrebbero essere spostate in una schermata di Help separata.</p>
<p><strong>Settings UI</strong></p>
<p>Per costruire la UI delle impostazioni, si usano <strong>sottoclassi della classe</strong> Preference piuttosto che oggetti View. La classe Preference fornisce la View da visualizzare per ogni impostazione e si associa a un'interfaccia SharedPreferences per memorizzare/recuperare i dati.</p>
<p>Per visualizzare una lista di impostazioni, si usa una <strong>Activity o un Fragment specializzato</strong>. La best practice per Android 3.0+ √® usare una SettingsActivity che ospita un PreferenceFragment. Per compatibilit√† con la v7 appcompat library, si estende la Settings Activity con AppCompatActivity e il fragment con PreferenceFragmentCompat. Per versioni pi√π vecchie di Android (\&lt;3.0), si usa PreferenceActivity. L'uso di PreferenceFragment √® generalmente pi√π flessibile rispetto alla sola PreferenceActivity.</p>
<p>Android Studio fornisce un <strong>template Settings Activity</strong>. Questo template facilita la creazione di schermate di impostazioni, specialmente se si hanno pi√π gruppi di impostazioni. Fornisce layout diversi per smartphone (header links) e tablet (master/detail view). Il template crea i file XML (res/xml/) che definiscono le impostazioni (pref_data_sync.xml, pref_general.xml, pref_headers.xml, pref_notification.xml), risorse stringa (strings.xml), e le classi Activity/Fragment necessarie (SettingsActivity, AppCompatPreferenceActivity). Il template include anche la funzionalit√† per ascoltare i cambiamenti delle impostazioni e aggiornare il riassunto (summary).</p>
<p>La gerarchia delle impostazioni inizia con un layout PreferenceScreen.</p>
<h1 id="1-tipi-di-controlli-ui-diverse-sottoclassi-di-preference-offrono-ui-appropriate-per-modificare-le-impostazioni">1. Tipi di Controlli UI: Diverse sottoclassi di Preference offrono UI appropriate per modificare le impostazioni:</h1>
<ul>
<li>CheckBoxPreference: Per impostazioni abilitate/disabilitate (valore booleano).</li>
<li>ListPreference: Mostra una lista di pulsanti radio in un dialogo.</li>
<li>SwitchPreference: Un'opzione toggle con due stati (on/off, true/false).</li>
<li>EditTextPreference: Un campo di testo in un dialogo per l'inserimento di stringhe.</li>
<li>RingtonePreference: Consente all'utente di scegliere una suoneria.</li>
</ul>
<p>I valori delle impostazioni vengono memorizzati in un file <strong>SharedPreferences</strong>. Questo √® un modo comune per persistere piccole quantit√† di dati primitivi come coppie chiave-valore tra le sessioni dell'app. Ogni oggetto Preference (impostazione) ha una coppia chiave-valore corrispondente che il sistema usa per salvare il valore in un file SharedPreferences predefinito.</p>
<p>Dopo aver salvato le impostazioni, √® necessario <strong>leggere i valori</strong> dallo SharedPreferences file per usarli nella logica dell'app. Si pu√≤ anche implementare un listener (Preference.OnPreferenceChangeListener) per reagire immediatamente ai cambiamenti di un'impostazione.</p>
<p><img alt="The image is a simple MVVM-style diagram with three rectangular components and labeled arrows: - View (top-left) - ViewModel (below View) ‚Äî contains an inner box labeled &quot;State and Operations&quot; - Model (right) Arrows and labels: - Solid arrow from View to ViewModel: &quot;Data Binding and Commands&quot; - Solid arrow from ViewModel to Model: &quot;ViewModel updates the model&quot; - Dashed curved arrow from ViewModel back to View: &quot;Send Notifications&quot; - Dashed curved arrow from Model back to ViewModel: &quot;Send Notifications&quot;" src="./Android_images/image_042.png" /></p>
<p>Il testing √® fondamentale per assicurarsi che un'app si comporti come previsto in ogni situazione, specialmente man mano che l'app cresce e cambia.</p>
<p>Aiuta a <strong>identificare i problemi nelle prime fasi dello sviluppo</strong>, quando sono meno costosi da risolvere, e migliora la robustezza del codice. Ci sono vari tipi di test:</p>
<ul>
<li>unit test √® una verifica che si concentra sul comportamento di una singola unit√† di codice. Questa "unit√†" di codice √® solitamente una singola funzione o un metodo. L'obiettivo √® garantire che quella specifica parte del codice funzioni correttamente in isolamento, senza dipendenze esterne.</li>
<li>Component test si verifica se le classi fra loro collaborano bene</li>
<li>integration test si concentrano sull'interazione tra pi√π unit√† di codice, per verificare che diversi componenti funzionino insieme come previsto. Mentre i unit test testano singole unit√† in isolamento, gli integration test verificano la corretta integrazione di pi√π unit√†, come moduli, librerie o servizi, e se queste interazioni producono il comportamento desiderato.</li>
</ul>
<p>Il testing automatizzato rende pi√π facile eseguire test su diverse configurazioni di dispositivi e stati. Scriverli da tutti sarebbe una follia.ü§™</p>
<p>Bisogna individuare i test suite e usare dei framework per poter scrivere test in modo automatico. Lo scopo dei test non √® di rimuovere gli errori, ma di capire cosa non funziona per poterli risolvere il problema.</p>
<p><img alt="- Simple clip‚Äëart showing two interlocking gears (cogwheels). - One larger gear on the left and a smaller gear on the right. - Bluish‚Äëgray color with lighter inner rings; plain white background." src="./Android_images/image_043.png" /></p>
<p>I test suite vengono dati ad un <strong>test runner</strong> che gli esegue e crea delle <strong>test class</strong> con i <strong>method test</strong> eseguendo per ogni metodo delle operazioni:</p>
<ul>
<li>Setup: Prima dell'esecuzione dei metodi di test, il test runner pu√≤ invocare metodi di setup che sono utilizzati per configurare le risorse necessarie per il test</li>
<li>Esecuzione dei Test: I metodi di test vengono eseguiti uno alla volta.</li>
<li>Tear Down: Dopo l'esecuzione di un test, possono essere invocati metodi di teardown per liberare risorse, come la chiusura di connessioni al database o la pulizia di dati temporanei.</li>
</ul>
<p>Una volta che i test sono stati eseguiti, il test runner crea un <strong>report dei risultati</strong>. Questo report mostra:</p>
<ul>
<li>I test che sono passati.</li>
<li>I test che sono falliti.</li>
<li>I test che hanno generato errori (ad esempio, eccezioni non gestite).</li>
</ul>
<p>Android supporta diverse tipologie di test e framework di testing.</p>
<p><strong>JUnit 4</strong> √® un framework comune per scrivere unit test in Java per Android.</p>
<p><img alt="The image is a horizontal, numbered workflow diagram (green panels) for building a software/mobile app, with Italian labels. Key elements: - Five main stages, left‚Üíright: 1. Requirements Analysis 2. Wireframing 3. Development / Designing 4. Testing 5. Deployment - Stages 3 and 4 are highlighted with a red dashed box and linked to detailed action lists. - Top annotations (Italian): define view navigation, define content structure for each view, verify/validate the app, generate acceptance reports, obtain client approval after changes. - Under each stage are short bullets (Italian/English): - Requirements: understand user needs, identify functions to implement, identify constraints/limits. - Development: application design, application coding, meetings with stakeholders. - Deployment: deploy to app stores, deploy to client server, make app available to users. - Two detailed boxes below: - Development (3.x): 3.1 Definire le risorse 3.2 Progettare ed implementare l'applicazione 3.3 Generare il package dell'applicazione 3.4 Installare &amp; e lanciare l'applicazione - Testing (4.x): 4.1 Verificare il comportamento dell'applicazione 4.2 Identificare i problemi 4.3 Ristrutturare il codice sorgente 4.4 Rigenerare il package dell'applicazione - Visual style: flat green tiles with icons, circular number markers, connector lines from stages to the detailed boxes." src="./Android_images/image_044.png" />Il framework JUnit implementa il composite, quindi possiede il TestSuite (compose) e i TestCase (leaf).</p>
<p>Per creare gli unit Test si crea una classe test che implementa i metedi:</p>
<ul>
<li>setUp()</li>
<li>tearDown</li>
<li>TestXXX</li>
<li>Suite()</li>
</ul>
<p>Nei metodi di test ci mettiamo le <strong>asserzioni</strong> per verificare che il comportamento del codice corrisponda a quanto previsto.</p>
<p>La libreria Hamcrest √® uno strumento utile per scrivere asserzioni nei test, permettendo di creare regole di matching in modo dichiarativo.</p>
<p><strong>1. Framework di Unit Test di "Prima Generazione"</strong></p>
<p>Nei framework di unit test di prima generazione, il concetto di base √® che un test deve verificare che una condizione sia vera durante l'esecuzione del codice. Questo avviene tramite l'istruzione assert, che verifica una condizione booleana e, se la condizione non √® vera, fa fallire il test.</p>
<p>I framework di "prima generazione" forniscono un messaggio di errore generico, come "Assertion failed", che non √® particolarmente utile per capire cosa sia andato storto.</p>
<p><strong>2. Framework di Unit Test di "Seconda Generazione"</strong></p>
<p>I framework di unit test di seconda generazione migliorano la situazione fornendo una serie di <strong>asserzioni specializzate</strong> che sono in grado di produrre messaggi di errore pi√π chiari e specifici, adattandosi a diversi tipi di confronti (ad esempio, uguaglianza, differenza, ecc.).</p>
<p>Alcuni esempi includono:</p>
<ul>
<li>assert_equal(x, y): Verifica che x e y siano uguali.</li>
<li>assert_not_equal(x, y): Verifica che x e y non siano uguali.</li>
</ul>
<p>Queste asserzioni specializzate sono pi√π esplicite e forniscono messaggi di errore pi√π significativi. Tuttavia, il problema principale di questo approccio √® che il numero di macro di asserzione tende a crescere rapidamente, perch√© ogni tipo di confronto richiede una macro di asserzione</p>
<p><strong>3. Framework di Unit Test di "Terza Generazione"</strong></p>
<p>I framework di unit test di <strong>terza generazione</strong> (come <strong>Hamcrest</strong>, un popolare framework di asserzione in Java) risolvono questo problema introducendo un approccio pi√π <strong>generico e composibile</strong>. In questi framework, l'operatore assert_that viene combinato con <strong>matcher</strong> (oggetti che eseguono verifiche su una condizione).</p>
<p>Un <strong>matcher</strong> √® una classe o un oggetto che definisce una condizione che pu√≤ essere verificata. In questo caso, assert_that viene utilizzato per affermare che un oggetto soddisfi una determinata condizione definita dal matcher.</p>
<p><strong><img alt="A diagram showing how an automated unit test runs: - Left: a &quot;Test runner&quot; box with an arrow labeled &quot;Executes&quot; pointing to a vertical &quot;Test class&quot; column containing several &quot;Test method&quot; boxes. - From one test method a dashed line leads to a four-step block: Setup ‚Üí Execute ‚Üí Verify ‚Üí Teardown. - Arrows from Setup/Execute/Teardown point into an oval labeled &quot;Fixture&quot; that contains a highlighted rectangle labeled &quot;SUT&quot; (system under test). - Caption: each automated test is a test method in a test class and follows four phases ‚Äî setup (initialize fixture), execute (invoke SUT), verify (check outcome), teardown (clean up fixture)." src="./Android_images/image_045.png" />MOCKITO (mock a mamm‚Äôt) üòµ</strong></p>
<p><strong>Mockito</strong> √® un framework di mocking che pu√≤ essere utilizzato per isolare le unit√† di codice durante l'esecuzione di unit test.</p>
<p>Permette di creare oggetti <strong>mock</strong> (fittizi o simulati) che si comportano come le dipendenze di un'unit√† di codice che stai testando. Questo √® utile perch√© consente di <strong>testare la logica specifica di un componente in isolamento</strong>, senza doversi preoccupare del comportamento reale delle sue dipendenze.</p>
<p><strong>Mockito</strong> √® specificamente menzionato nel contesto della creazione di unit test. Quando si esegue un unit test, l'obiettivo √® verificare la logica di una piccola porzione di codice (come un metodo o una classe).</p>
<p>Android permette due tipi di test:</p>
<ul>
<li>Local Unit TestQuesti test vengono compilati ed eseguiti interamente sulla tua macchina locale utilizzando la Java Virtual Machine (JVM). Sono utilizzati per testare la logica interna dell'app che non richiede l'accesso all'Android framework o a un dispositivo/emulatore1 .</li>
<li>Instrumented TestQuesti test vengono eseguiti su un dispositivo o emulatore Android.</li>
</ul>
<p><img alt="Image: a UML-style diagram titled &quot;JUnit framework&quot;. - Center/top: a small box labeled &quot;Test&quot; with arrows from a &quot;Testing client&quot; (left) and a return arrow labeled &quot;fTests&quot;. - Left-center: &quot;TestCase&quot; box showing methods: run(TestResult), setUp(), runTest(), tearDown(). - Right-center: &quot;TestSuite&quot; box showing methods: run(TestResult), addTest(Test); a note: &quot;for all test in fTests test.run(TestResult)&quot;. - Middle: &quot;TestResult&quot; box linked to TestCase (result collection). - Lower-center: &quot;ConcreteTestCase&quot; (subclass of TestCase) listing setUp(), runTest(), tearDown(), test1(), test2(), fName. - Bottom-left: &quot;TestedClass&quot; with action() method; arrow from ConcreteTestCase to TestedClass (uses the class under test). - Various solid and dashed lines/arrows indicate inheritance, aggregation, and method-calling relationships (TestCase runs tests and reports to TestResult; TestSuite contains Tests and runs them)." src="./Android_images/image_046.png" /></p>
<p><strong>ESPRESSO</strong></p>
<p>Il UI testing si concentra sul test degli aspetti dell'interfaccia utente e delle interazioni con gli utenti.</p>
<p><strong>Espresso</strong> lavora con il test runner AndroidJUnitRunner e richiede instrumentation.</p>
<p>I test Espresso si basano sulla simulazione delle azioni che un utente potrebbe compiere: <strong>trovare una view</strong>, <strong>eseguire un'azione</strong> (es. clic) e <strong>verificare il risultato</strong> (asserzione sullo stato della view).</p>
<p><img alt="A logo showing a clear drinking glass with water, mint leaves and two black straws, above the lowercase word &quot;mockito&quot; (the &quot;mock&quot; in green and &quot;ito&quot; in black) with a faint reflection beneath the text." src="./Android_images/image_047.png" />I test Espresso vengono eseguiti su dispositivi Android reali o emulatori. Richiedono l'instrumentazione e funzionano con il test runner AndroidJUnitRunner.</p>
<ul>
<li>L'app restituisce l'output UI corretto in risposta a una sequenza di azioni dell'utente.</li>
<li>I controlli di navigazione e input dell'app aprono le Activity, le View e i campi corretti.</li>
<li>L'app risponde correttamente con dipendenze "mockate" (false) o pu√≤ lavorare con metodi backend "stubbed out" (simulati).</li>
</ul>
<p>Un vantaggio fondamentale di Espresso √® l'accesso alle informazioni di strumentazione, come il contesto dell'app. Sincronizza automaticamente le azioni di test con l'UI dell'app, rilevando quando il thread principale √® inattivo. Ci√≤ permette ai test di essere eseguiti al momento opportuno, migliorando l'affidabilit√† ed evitando la necessit√† di workaround basati sul tempo, come i ritardi (sleep) nel codice di test.</p>
<p>La scrittura dei test Espresso si basa su ci√≤ che farebbe un utente. I passaggi fondamentali sono:</p>
<h1 id="1-trovare-una-vista-match-a-view-individuare-lelemento-ui-con-cui-interagire-spesso-usando-il-metodo-onview">1. Trovare una vista (Match a view): Individuare l'elemento UI con cui interagire, spesso usando il metodo onView().</h1>
<h1 id="2-eseguire-unazione-perform-an-action-interagire-con-la-vista-trovata-ad-esempio-cliccando-click">2. Eseguire un'azione (Perform an action): Interagire con la vista trovata, ad esempio cliccando (click()).</h1>
<h1 id="3-asserire-e-verificare-il-risultato-assert-and-verify-the-result-controllare-lo-stato-della-vista-o-loutput-per-vedere-se-corrisponde-allo-stato-o-al-comportamento-atteso">3. Asserire e verificare il risultato (Assert and verify the result): Controllare lo stato della vista o l'output per vedere se corrisponde allo stato o al comportamento atteso.</h1>
<p>Espresso ha una sintassi fluida e un paradigma funzionale. Il framework Hamcrest √® comunemente usato con Espresso per le asserzioni. Permette di creare <strong>matcher</strong> personalizzati e combinare espressioni per definire regole di corrispondenza in modo dichiarativo. Questo porta a messaggi di errore pi√π utili rispetto alle semplici asserzioni booleane.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.tabs", "search.share"], "search": "../../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>