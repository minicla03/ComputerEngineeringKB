[
  {
    "sid": "/1-ricezione-fisica-dello-stimolo",
    "title": "1. ricezione fisica dello stimolo",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-elaborazione-e-uninterpretazione-dello-stimolo",
    "title": "2. elaborazione e un'interpretazione dello stimolo",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-esecuzione",
    "title": "1. Esecuzione",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-valutazione",
    "title": "2. Valutazione",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-raccoglie-informazioni-sul-target-delloggetto-intent-utilizzando-il-metodo-resolveintent-sulloggetto-packagemanager-con-i-flag-packagemanagermatch_default_only-e-packagemanagerget_shared_library_files-utilizzati-per-impostazione-predefinita",
    "title": "1. Raccoglie informazioni sul target dell'oggetto intent utilizzando il metodo resolveIntent() sull'oggetto PackageManager, con i flag PackageManager.MATCH_DEFAULT_ONLY e PackageManager.GET_SHARED_LIBRARY_FILES utilizzati per impostazione predefinita.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-salva-le-informazioni-sul-target-nelloggetto-intent-per-evitare-di-ripetere-questo-passaggio",
    "title": "2. Salva le informazioni sul target nell'oggetto intent per evitare di ripetere questo passaggio.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-verifica-se-lutente-ha-privilegi-sufficienti-per-richiamare-il-componente-target-dellintent-chiamando-il-metodo-granturipermissionlocked",
    "title": "3. Verifica se l'utente ha privilegi sufficienti per richiamare il componente target dell'intent chiamando il metodo grantUriPermissionLocked().",
    "level": 1,
    "children": []
  },
  {
    "sid": "/4-se-lutente-ha-le-autorizzazioni-necessarie-lactivitymanagerservice-verifica-se-lattività-target-richiede-di-essere-avviata-in-un-nuovo-task-in-base-ai-flag-dellintent-come-flag_activity_new_task-e-flag_activity_clear_top",
    "title": "4. Se l'utente ha le autorizzazioni necessarie, l'ActivityManagerService verifica se l'attività target richiede di essere avviata in un nuovo task, in base ai flag dell'Intent come FLAG_ACTIVITY_NEW_TASK e FLAG_ACTIVITY_CLEAR_TOP.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/5-verifica-se-esiste-già-un-processrecord-per-il-processo-se-il-processrecord-è-null-lactivitymanager-deve-creare-un-nuovo-processo-per-istanziare-il-componente-target",
    "title": "5. Verifica se esiste già un ProcessRecord per il processo. Se il ProcessRecord è null, l'ActivityManager deve creare un nuovo processo per istanziare il componente target.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-oncreate-in-questo-momento-lactivity-viene-effetivamente-creata-e-in-questa-fase-si-inizializzano-tutte-le-risorse-necessarie-viene-carocato-in-memoria-lalbero-delle-views-che-formano-lactivity",
    "title": "1. onCreate() in questo momento l’activity viene effetivamente creata e in questa fase si inizializzano tutte le risorse necessarie. Viene carocato in memoria l’albero delle views che formano l’activity.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-subito-dopo-android-chiama-il-metodo-onstart-che-permette-allactivity-di-essere-visibile-allutente-ma-non-è-ancora-interattiva-linterfaccia-viene-renderizzata-visualizzando-le-componenti-che-formano-lactivity",
    "title": "2. Subito dopo, Android chiama il metodo onStart() che permette all’Activity di essere visibile all’utente, ma non è ancora interattiva. L’interfaccia viene renderizzata visualizzando le componenti che formano l’activity.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-con-linvocazione-di-onresume-lactivity-diventa-pienamente-attiva-e-interattiva-e-lutente-può-effetti-interagire-con-le-componenti-dellappliczione-gli-event-generati-vengono-catturati-dal-looper-e-fa-cambiare-stato-allactivity-durante-questa-fase-lactivity-è-in-primo-piano-e-qualsiasi-altra-activity-aperta-in-precedenza-è-stata-messa-in-pausa-o-nascosta",
    "title": "3. Con l’invocazione di onResume() l’Activity diventa pienamente attiva e interattiva e l’utente può effetti interagire con le componenti dell’appliczione. Gli event generati vengono catturati dal looper e fa cambiare stato all’activity. Durante questa fase, l’Activity è in primo piano e qualsiasi altra Activity aperta in precedenza è stata messa in pausa o nascosta.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-standardla-modalità-predefinita-il-sistema-crea-una-nuova-istanza-dellattività-nellattività-da-cui-è-stato-avviato-e-instrada-lintent-a-questultimo-lattività-può-essere-creata-più-volte-ogni-istanza-può-appartenere-ad-attività-diverse-unattività-può-avere-più-istanze",
    "title": "1. StandardLa modalità predefinita. Il sistema crea una nuova istanza dell'attività nell'attività da cui è stato avviato e instrada l'intent a quest'ultimo. L'attività può essere creata più volte, ogni istanza può appartenere ad attività diverse un'attività può avere più istanze.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-singletopse-nella-parte-superiore-dellattività-corrente-esiste-già-unistanza-dellattività-il-sistema-instrada-lintent-a-quellistanza-tramite-una-chiamata-alla-suaonnewintentanziché-creare-una-nuova-istanza-dellattività-lattività-è-creata-più-volte-ogni-istanza-può-appartenere-ad-attività-diverse-e-unattività-può-avere-più-istanze-ma-solo-se-lattività-in-alto-dello-stack-posteriorenonè-unistanza-esistente-dellattività",
    "title": "2. SingleTopSe nella parte superiore dell'attività corrente esiste già un'istanza dell'attività, il sistema instrada l'intent a quell'istanza tramite una chiamata alla sua onNewIntent() anziché creare una nuova istanza dell'attività. L'attività è creata più volte, ogni istanza può appartenere ad attività diverse e un'attività può avere più istanze (ma solo se l'attività in alto dello stack posteriore non è un'istanza esistente dell'attività).",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-singletaskil-sistema-crea-lattività-alla-base-di-una-nuova-attività-o-individua-la-su-unattività-esistente-con-la-stessa-affinità-se-unistanza-del-componente-esiste-già-unattività-il-sistema-instrada-allistanza-esistente-tramite-una-chiamata-alla-sua-onnewintent-anziché-creare-una-nuova-istanza-nel-frattempo-tutti-gli-altri-vengono-distrutte",
    "title": "3. singleTaskIl sistema crea l'attività alla base di una nuova attività o individua la su un'attività esistente con la stessa affinità. Se un'istanza del componente esiste già un'attività, il sistema instrada all'istanza esistente tramite una chiamata alla sua onNewIntent() anziché creare una nuova istanza. Nel frattempo, tutti gli altri vengono distrutte.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/4-singleinstanceil-comportamento-è-lo-stesso-disingletask-ad-eccezione-del-fatto-che-il-sistema-non-avvia-nessun-altro-delle-attività-nellattività-che-contiene-listanza-lattività-è-sempre-lunico-e-unico-membro-della-sua-attività-tutte-le-attività-iniziate-da-questa-si-aprono-tra-per-unattività-a-parte",
    "title": "4. singleInstanceIl comportamento è lo stesso di \"singleTask\", ad eccezione del fatto che il sistema non avvia nessun altro delle attività nell'attività che contiene l'istanza. L'attività è sempre l'unico e unico membro della sua attività. Tutte le attività iniziate da questa si aprono tra per un'attività a parte.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/5-singleinstancepertasklattività-può-essere-eseguita-solo-come-attività-principale-dellattività-la-prima-allattività-che-ha-creato-lattività-perciò-può-esserci-una-sola-istanza-di-questa-attività-in-unattività-a-differenza-della-modalità-di-avvio-disingletask-questa-lattività-può-essere-avviata-in-più-istanze-in-diverse-attività-seflag_activity_multiple_taskoflag_activity_new_documentè-stato-impostato",
    "title": "5. singleInstancePerTaskL'attività può essere eseguita solo come attività principale dell'attività, la prima all'attività che ha creato l'attività, perciò può esserci una sola istanza di questa attività in un'attività. A differenza della modalità di avvio di singleTask, questa l'attività può essere avviata in più istanze in diverse attività se FLAG_ACTIVITY_MULTIPLE_TASK o FLAG_ACTIVITY_NEW_DOCUMENT è stato impostato.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-sovrascrivendo-il-metodo-onsaveinstancestatebundle-lo-stato-viene-salvato-come-una-serie-di-coppie-chiavevalore-in-un-oggetto-bundle-che-viene-passato-a-oncreate-quando-lactivity-viene-ricreata-è-anche-possibile-utilizzare-il-callback-onrestoreinstancestate-per-ripristinare-lo-stato",
    "title": "1. sovrascrivendo il metodo onSaveInstanceState(Bundle). Lo stato viene salvato come una serie di coppie chiave/valore in un oggetto Bundle che viene passato a onCreate() quando l'Activity viene ricreata. È anche possibile utilizzare il callback onRestoreInstanceState() per ripristinare lo stato.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-oppure-con-il-model-view-controller",
    "title": "2. Oppure con il model-view-controller",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-setretaininstancetrue-è-stato-chiamato-sul-fragment",
    "title": "1. setRetainInstance(true) è stato chiamato sul fragment",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-lattività-ospitante-viene-distrutta-per-un-cambio-di-configurazione",
    "title": "2. l'attività ospitante viene distrutta per un cambio di configurazione",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-gli-intent-broadcast-di-sistema-vengono-inviati-quando-si-verifica-un-evento-di-sistema-che-potrebbe-interessare-la-tua-app-come-lavvio-del-dispositivi-la-connessione-o-disconnessione-dallalimentazione-ecc",
    "title": "1. Gli intent broadcast di sistema vengono inviati quando si verifica un evento di sistema che potrebbe interessare la tua app, come l'avvio del dispositivi, la connessione o disconnessione dall'alimentazione ecc.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-gli-intent-broadcast-personalizzati-vengono-utilizzati-quando-vuoi-che-la-tua-app-esegua-unazione-senza-avviare-unattività-ad-esempio-per-informare-altre-app-che-sono-stati-scaricati-dei-dati",
    "title": "2. Gli intent broadcast personalizzati vengono utilizzati quando vuoi che la tua app esegua un'azione senza avviare un'attività, ad esempio per informare altre app che sono stati scaricati dei dati.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-staticamente-nel-file-manifest-aggiungendo-un-elemento--al-file-androidmanifestxml-e-usare-il-percorso-della-tua-sottoclasse-broadcastreceiver-come-attributo-androidname",
    "title": "1. staticamente nel file manifest aggiungendo un elemento  al file AndroidManifest.xml e usare il percorso della tua sottoclasse BroadcastReceiver come attributo android:name.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-dinamica-sulla-base-del-contesto-con-cui-si-chiamava-il-broadcast-receiver-la-registrazione-avviene-chiamando-il-metodo-registerreceiver-e-passando-un-oggetto-broadcastreceiver-e-un-intentfilter-i-receiver-registrati-dinamicamente-sono-legati-al-ciclo-di-vita-del-componente-in-cui-sono-registrati-infatti-è-necessario-gestire-anche-la-loro-cancellazione-perché-potrebbero-contenere-dati-che-sprecherebbero-risorse",
    "title": "2. dinamica sulla base del contesto con cui si chiamava il broadcast receiver. La registrazione avviene chiamando il metodo registerReceiver() e passando un oggetto BroadcastReceiver e un IntentFilter. I receiver registrati dinamicamente sono legati al ciclo di vita del componente in cui sono registrati, infatti è necessario gestire anche la loro cancellazione perché potrebbero contenere dati che sprecherebbero risorse",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-la-raccolta-di-dati-sugli-eventi-touch",
    "title": "1. la raccolta di dati sugli eventi touch",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-linterpretazione-dei-dati-per-determinare-se-soddisfano-i-gesti-supportati-dallapp",
    "title": "2. l’interpretazione dei dati per determinare se soddisfano i gesti supportati dall’app.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-costruttori",
    "title": "1. Costruttori",
    "level": 1,
    "children": [
      {
        "sid": "/a-uno-a-cui-passiamo-solo-il-contesto",
        "title": "a. Uno a cui passiamo solo il contesto",
        "level": 2,
        "parent": "/1-costruttori",
        "children": []
      },
      {
        "sid": "/b-contesto-e-attributi",
        "title": "b. Contesto e attributi",
        "level": 2,
        "parent": "/1-costruttori",
        "children": []
      },
      {
        "sid": "/c-contesto-attributi-e-stile",
        "title": "c. Contesto attributi e stile",
        "level": 2,
        "parent": "/1-costruttori",
        "children": []
      }
    ]
  },
  {
    "sid": "/2-onmeasure-che-viene-chiamato-quando-la-view-deve-essere-disegnata-lincarico-di-disegnare-la-view-spetta-al-genitore-che-chiede-al-figlio-le-sue-dimensioni-altezza-e-larghezza-chiamando-i-metodi-della-classe-del-figlio",
    "title": "2. onMeasure() che viene chiamato quando la view deve essere disegnata. L’incarico di disegnare la view spetta al genitore che chiede al figlio le sue dimensioni: altezza e larghezza, chiamando i metodi della classe del figlio.",
    "level": 1,
    "children": [
      {
        "sid": "/a-questa-funzione-viene-chiamata-ogni-volta-che-la-view-viene-invalidata",
        "title": "a. Questa funzione viene chiamata ogni volta che la view viene invalidata.",
        "level": 2,
        "parent": "/2-onmeasure-che-viene-chiamato-quando-la-view-deve-essere-disegnata-lincarico-di-disegnare-la-view-spetta-al-genitore-che-chiede-al-figlio-le-sue-dimensioni-altezza-e-larghezza-chiamando-i-metodi-della-classe-del-figlio",
        "children": []
      }
    ]
  },
  {
    "sid": "/3-ondraw-che-serve-per-fare-effettivamente-il-disegno-della-view-questa-funzione-viene-chiamata-frequentemente-e-o-in-modo-sincrono-in-base-alla-frequenza-di-refresh-impostata-dal-dispositivo-se-la-frequenza-di-refresh-è-minore-del-tempo-con-cui-questa-funzione-viene-chiamata-si-hanno-dei-problemi-nel-rendering",
    "title": "3. onDraw() che serve per fare effettivamente il disegno della view. Questa funzione viene chiamata frequentemente e o in modo sincrono in base alla frequenza di refresh impostata dal dispositivo. Se la frequenza di refresh è minore del tempo con cui questa funzione viene chiamata si hanno dei problemi nel rendering.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-ui-thread",
    "title": "1. UI Thread",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-renderthread",
    "title": "2. RenderThread",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-graphics-pipeline",
    "title": "3. Graphics Pipeline.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-input-handling--il-primo-compito-è-elaborare-gli-input-dellutente-come-tocchi-scroll-o-gesti-se-premiamo-un-pulsante-il-sistema-deve-registrare-levento-e-prepararsi-a-cambiare-la-ui",
    "title": "1. Input Handling → Il primo compito è elaborare gli input dell’utente, come tocchi, scroll o gesti. Se premiamo un pulsante, il sistema deve registrare l’evento e prepararsi a cambiare la UI.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-animations--se-ci-sono-animazioni-in-corso-ad-esempio-un-pulsante-che-si-ingrandisce-quando-viene-premuto-vengono-aggiornate-e-interpolate-android-calcola-la-nuova-posizione-opacità-o-dimensione-dellelemento-animato",
    "title": "2. Animations → Se ci sono animazioni in corso (ad esempio, un pulsante che si ingrandisce quando viene premuto), vengono aggiornate e interpolate. Android calcola la nuova posizione, opacità o dimensione dell’elemento animato.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-measure--layout--ora-il-sistema-deve-capire-quanto-spazio-occupano-le-view-e-dove-devono-essere-posizionate-questo-processo-avviene-in-due-fasi",
    "title": "3. Measure & Layout → Ora il sistema deve capire quanto spazio occupano le View e dove devono essere posizionate. Questo processo avviene in due fasi:",
    "level": 1,
    "children": []
  },
  {
    "sid": "/4-draw--dopo-aver-determinato-le-posizioni-e-le-dimensioni-delle-view-il-sistema-esegue-il-disegno-vero-e-proprio-questo-avviene-nel-metodo-ondrawcanvas-canvas-che-dipinge-gli-elementi-grafici-sullo-schermo",
    "title": "4. Draw → Dopo aver determinato le posizioni e le dimensioni delle View, il sistema esegue il disegno vero e proprio. Questo avviene nel metodo onDraw(Canvas canvas), che dipinge gli elementi grafici sullo schermo.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/5-sync--infine-il-ui-thread-invia-i-dati-al-renderthread-il-quale-si-occuperà-di-trasformarli-in-qualcosa-che-la-gpu-può-elaborare",
    "title": "5. Sync → Infine, il UI Thread invia i dati al RenderThread, il quale si occuperà di trasformarli in qualcosa che la GPU può elaborare.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-sync--riceve-i-dati-dal-ui-thread-e-li-sincronizza-con-lo-stato-attuale-della-grafica",
    "title": "1. Sync → Riceve i dati dal UI Thread e li sincronizza con lo stato attuale della grafica.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-execute--processa-i-comandi-di-rendering-preparando-la-scena-da-inviare-alla-gpu",
    "title": "2. Execute → Processa i comandi di rendering, preparando la scena da inviare alla GPU.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-get-buffer--recupera-un-buffer-di-rendering-ovvero-unarea-di-memoria-in-cui-verrà-disegnato-il-frame",
    "title": "3. Get Buffer → Recupera un buffer di rendering, ovvero un’area di memoria in cui verrà disegnato il frame.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/4-issue--converte-i-comandi-in-istruzioni-per-la-gpu",
    "title": "4. Issue → Converte i comandi in istruzioni per la GPU.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/5-swap-buffer--una-volta-che-tutto-è-pronto-il-renderthread-invia-il-frame-alla-gpu-e-chiede-il-prossimo-buffer-per-il-frame-successivo",
    "title": "5. Swap Buffer → Una volta che tutto è pronto, il RenderThread invia il frame alla GPU e chiede il prossimo buffer per il frame successivo.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-get-buffer--la-gpu-recupera-il-buffer-con-i-dati-da-disegnare",
    "title": "1. Get Buffer → La GPU recupera il buffer con i dati da disegnare.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-swap-buffer--il-buffer-contenente-il-nuovo-frame-viene-inviato-allo-schermo",
    "title": "2. Swap Buffer → Il buffer contenente il nuovo frame viene inviato allo schermo.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-composite--infine-la-gpu-compone-il-frame-con-altri-layer-grafici-e-lo-mostra-allutente",
    "title": "3. Composite → Infine, la GPU compone il frame con altri layer grafici e lo mostra all’utente.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-domainapplication-core-contiene-le-entità-e-la-logica-di-business-dellapplicazione-questo-livello-è-indipendente-da-qualsiasi-framework-o-dettaglio-di-implementazione-esterna",
    "title": "1. Domain/Application Core: Contiene le entità e la logica di business dell'applicazione. Questo livello è indipendente da qualsiasi framework o dettaglio di implementazione esterna.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-use-cases-il-software-in-questo-livello-contiene-regole-aziendali-specifiche-dellapplicazione-ed-incapsula-e-implementa-tutti-i-casi-duso-del-sistema-questi-casi-duso-orchestrano-il-flusso-di-dati-da-e-verso-le-entità-e-indirizzano-tali-entità-per-raggiungere-gli-obiettivi-del-caso-duso-i-cambiamenti-in-questo-livello-non-devono-influenzare-le-entità-e-questo-livello-non-è-influenzato-da-modifiche-alle-componenti-esterne-come-il-database-linterfaccia-utente-o-qualsiasi-framework-utilizzato-questo-strato-è-isolato-da-tali-problematiche-tuttavia-modifiche-alle-funzioni-di-dominio-dellapplicazione-influenzeranno-i-casi-duso-e-quindi-il-software-in-questo-livello",
    "title": "2. Use Cases: Il software in questo livello contiene regole aziendali specifiche dell'applicazione ed incapsula e implementa tutti i casi d'uso del sistema. Questi casi d'uso orchestrano il flusso di dati da e verso le entità e indirizzano tali entità per raggiungere gli obiettivi del caso d'uso. I cambiamenti in questo livello non devono influenzare le entità e questo livello non è influenzato da modifiche alle componenti esterne come il database, l'interfaccia utente o qualsiasi framework utilizzato. Questo strato è isolato da tali problematiche. Tuttavia, modifiche alle funzioni di dominio dell'applicazione influenzeranno i casi d'uso e quindi il software in questo livello.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-infrastructureframeworks-contiene-i-dettagli-di-implementazione-dei-sistemi-esterni-come-database-framework-ui-librerie-esterne-e-api-le-implementazioni-delle-interfacce-definite-nel-livello-application-risiedono-qui",
    "title": "3. Infrastructure/Frameworks: Contiene i dettagli di implementazione dei sistemi esterni, come database, framework UI, librerie esterne e API. Le implementazioni delle interfacce definite nel livello Application risiedono qui.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/4-interface-adapters-questo-livello-funge-da-ponte-tra-i-livelli-application-e-infrastructure-contiene-adapter-presentatori-e-controller-che-convertono-i-dati-da-un-formato-allaltro-per-soddisfare-le-esigenze-dei-diversi-livelli",
    "title": "4. Interface Adapters: Questo livello funge da ponte tra i livelli Application e Infrastructure. Contiene adapter, presentatori e controller che convertono i dati da un formato all'altro per soddisfare le esigenze dei diversi livelli.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/5-apiui-il-livello-più-esterno-che-presenta-lapplicazione-allutente-tramite-unapi-web-o-uninterfaccia-utente-grafica",
    "title": "5. API/UI: Il livello più esterno che presenta l'applicazione all'utente (tramite un'API web o un'interfaccia utente grafica).",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-lesecuzione-inizia-nel-controller",
    "title": "1. l'esecuzione inizia nel controller",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-si-sposta-attraverso-il-caso-duso",
    "title": "2. si sposta attraverso il caso d'uso",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-finisce-per-essere-eseguito-nel-presenter",
    "title": "3. finisce per essere eseguito nel presenter.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-model",
    "title": "1. Model",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-view",
    "title": "2. View",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-viewmodel-che-da-intermediario-tra-la-view-e-il-model-è-responsabile-della-gestione-dei-dati-da-visualizzare-nella-ui-e-dellelaborazione-della-logica-necessaria-per-presentarli-la-viewmodel-fornisce-i-dati-alla-view-tramite-livedata-che-consente-di-osservare-i-cambiamenti-dei-dati-e-aggiornare-automaticamente-la-ui-quando-necessario-la-viewmodel-non-ha-conoscenza-diretta-della-view-comunica-con-il-model-per-recuperare-i-dati-e-li-prepara-in-una-forma-che-la-view-può-facilmente-consumare",
    "title": "3. ViewModel che da intermediario tra la View e il Model. È responsabile della gestione dei dati da visualizzare nella UI e dell'elaborazione della logica necessaria per presentarli. La ViewModel fornisce i dati alla View tramite LiveData, che consente di osservare i cambiamenti dei dati e aggiornare automaticamente la UI quando necessario. La ViewModel non ha conoscenza diretta della View. Comunica con il Model per recuperare i dati e li prepara in una forma che la View può facilmente consumare.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-lutente-interagisce-con-la-view-ad-esempio-tocca-un-pulsante",
    "title": "1. L'utente interagisce con la View (ad esempio, tocca un pulsante).",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-la-view-invia-unazione-al-viewmodel-ad-esempio-invoca-un-metodo-che-cambia-i-dati",
    "title": "2. La View invia un'azione al ViewModel (ad esempio, invoca un metodo che cambia i dati).",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-il-viewmodel-interagisce-con-il-model-per-recuperare-o-modificare-i-dati-in-caso-di-operazioni-asincrone-il-viewmodel-gestisce-il-flusso-di-lavoro",
    "title": "3. Il ViewModel interagisce con il Model per recuperare o modificare i dati. In caso di operazioni asincrone, il ViewModel gestisce il flusso di lavoro.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/4-quando-il-model-restituisce-i-dati-ad-esempio-tramite-una-chiamata-api-il-viewmodel-li-prepara-ad-esempio-li-converte-in-un-formato-adatto-alla-visualizzazione",
    "title": "4. Quando il Model restituisce i dati (ad esempio tramite una chiamata API), il ViewModel li prepara (ad esempio, li converte in un formato adatto alla visualizzazione).",
    "level": 1,
    "children": []
  },
  {
    "sid": "/5-il-viewmodel-aggiorna-un-livedata-che-è-osservato-dalla-view",
    "title": "5. Il ViewModel aggiorna un LiveData, che è osservato dalla View.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/6-la-view-riceve-i-nuovi-dati-tramite-livedata-e-aggiorna-automaticamente-linterfaccia-utente",
    "title": "6. La View riceve i nuovi dati tramite LiveData e aggiorna automaticamente l'interfaccia utente.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-brevi-utilizza-il-minor-numero-possibile-di-parole-sii-conciso-evita-di-irritare-gli-utenti-inviando-troppe-notifiche-o-notifiche-con-contenuti-inutili-o-fastidiosi",
    "title": "1. Brevi: Utilizza il minor numero possibile di parole. Sii conciso. Evita di irritare gli utenti inviando troppe notifiche o notifiche con contenuti inutili o fastidiosi.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-tempestive-le-notifiche-devono-apparire-quando-sono-utili-altrimenti-se-arrivano-i-ritardo-potremmo-non-servire-più",
    "title": "2. Tempestive: Le notifiche devono apparire quando sono utili, altrimenti se arrivano i ritardo potremmo non servire più.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-pertinenti-linformazione-deve-essere-utile-per-lutente-notifiche-che-disturbino-inutilmente-lutente-o-che-lo-possono-trarre-in-inganno-posso-partare-la-cancellazione-dellapplicazione",
    "title": "3. Pertinenti: l'informazione deve essere utile per l'utente. Notifiche che disturbino inutilmente l’utente o che lo possono trarre in inganno posso partare la cancellazione dell’applicazione.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-notificationcompatbigtextstyle-utilizzata-per-notifiche-di-grande-formato-che-includono-molto-testo",
    "title": "1. NotificationCompat.BigTextStyle: Utilizzata per notifiche di grande formato che includono molto testo.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-notificationcompatinboxstyle-utilizzata-per-notifiche-di-grande-formato-che-includono-una-lista-di-fino-a-cinque-stringhe",
    "title": "2. NotificationCompat.InboxStyle: Utilizzata per notifiche di grande formato che includono una lista di fino a cinque stringhe.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-notificationcompatbigpicturestyle-utilizzata-per-notifiche-di-grande-formato-che-includono-un-grande-allegato-immagine-puoi-impostare-limmagine-grande-con-bigpicture-e-anche-un-titolo-per-il-contenuto-grande-con-setbigcontenttitle",
    "title": "3. NotificationCompat.BigPictureStyle: Utilizzata per notifiche di grande formato che includono un grande allegato immagine. Puoi impostare l'immagine grande con bigPicture() e anche un titolo per il contenuto grande con setBigContentTitle().",
    "level": 1,
    "children": []
  },
  {
    "sid": "/4-notificationmediastyle-utilizzata-per-notifiche-di-riproduzione-multimediale",
    "title": "4. Notification.MediaStyle: Utilizzata per notifiche di riproduzione multimediale.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-il-contesto-dellapplicazione",
    "title": "1. Il contesto dell'applicazione.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-un-codice-di-richiesta-un-id-per-distinguere-i-pendingintent",
    "title": "2. Un codice di richiesta (un ID per distinguere i PendingIntent).",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-lintent-da-consegnare",
    "title": "3. L'Intent da consegnare.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/4-un-flag-pendingintent-che-determina-come-il-sistema-gestisce-più-oggetti-pendingintent-dalla-stessa-applicazione",
    "title": "4. Un flag PendingIntent che determina come il sistema gestisce più oggetti PendingIntent dalla stessa applicazione.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-un-id-di-notifica-un-numero-intero-utilizzato-per-aggiornare-o-annullare-la-notifica-in-seguito-dovrebbe-essere-unico-allinterno-della-tua-applicazione-se-chiami-notify-più-volte-con-lo-stesso-tag-e-id-sostituirà-qualsiasi-notifica-esistente-con-lo-stesso-tag-e-id-questo-è-il-modo-in-cui-puoi-implementare-ad-esempio-una-barra-di-avanzamento-o-altre-visualizzazioni-dinamiche-in-una-notifica",
    "title": "1. Un ID di notifica (un numero intero), utilizzato per aggiornare o annullare la notifica in seguito. Dovrebbe essere unico all'interno della tua applicazione. Se chiami notify() più volte con lo stesso tag e ID, sostituirà qualsiasi notifica esistente con lo stesso tag e ID. Questo è il modo in cui puoi implementare, ad esempio, una barra di avanzamento o altre visualizzazioni dinamiche in una notifica.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-loggetto-notification-stesso-questo-oggetto-viene-tipicamente-costruito-utilizzando-la-classe-notificationcompatbuilder",
    "title": "2. L'oggetto Notification stesso. Questo oggetto viene tipicamente costruito utilizzando la classe NotificationCompat.Builder.",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-tipi-di-controlli-ui-diverse-sottoclassi-di-preference-offrono-ui-appropriate-per-modificare-le-impostazioni",
    "title": "1. Tipi di Controlli UI: Diverse sottoclassi di Preference offrono UI appropriate per modificare le impostazioni:",
    "level": 1,
    "children": []
  },
  {
    "sid": "/1-trovare-una-vista-match-a-view-individuare-lelemento-ui-con-cui-interagire-spesso-usando-il-metodo-onview",
    "title": "1. Trovare una vista (Match a view): Individuare l'elemento UI con cui interagire, spesso usando il metodo onView().",
    "level": 1,
    "children": []
  },
  {
    "sid": "/2-eseguire-unazione-perform-an-action-interagire-con-la-vista-trovata-ad-esempio-cliccando-click",
    "title": "2. Eseguire un'azione (Perform an action): Interagire con la vista trovata, ad esempio cliccando (click()).",
    "level": 1,
    "children": []
  },
  {
    "sid": "/3-asserire-e-verificare-il-risultato-assert-and-verify-the-result-controllare-lo-stato-della-vista-o-loutput-per-vedere-se-corrisponde-allo-stato-o-al-comportamento-atteso",
    "title": "3. Asserire e verificare il risultato (Assert and verify the result): Controllare lo stato della vista o l'output per vedere se corrisponde allo stato o al comportamento atteso.",
    "level": 1,
    "children": []
  }
]